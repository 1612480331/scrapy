{"title": "如何基于微信小程序开发网约车应用", "author": "Rolan", "time": "2020-5-20 00:54", "content": "项 目描述为了解决长途如跨城市的出行撮合需求，满足乘客和司机双方自由定价的意愿，特开发一款非及时的打车应用。基本功能是出行用户登录小程序后，根据自己角色选择发布行程计划。行程计划包括出行时间和起始位置以及期望价格；如果是乘客，发布自己的出行计划之后跳转到乘客发布的出行计划列表页，乘客可以点击期望的行程计划，邀请司机接单；如果是司机，需要验证是否已经认证通过。如果没有认证通过则跳转到认证页面，否则跳转到乘客发布的出行计划列表页，选择期望的出行计划，完成接单。司机和乘客通过聊天页面协调出行计划。暂不支持支付功能，由双方线下完成交易。用流程图描述为：系统原型主要提供3个Tab页面：“首页”、“消息”和“我的”。其中“首页”聚焦行程发布、行程查看和聊天会话等核心功能。“消息”聚焦历史会话检索等功能，在首页进行的会话会跳转到该tab页面。“我的”聚焦车主认证、司机或者乘客查看历史行程记录以及客服服务等功能。原型图如下所示：系统存储设计根据业务，存储表主要有以下几种：driver：司机认证记录表，包括司机个人信息以及认证状态等driver_route:司机发布的行程记录表passager_route：乘客发布的行程记录表bargin_route：成交的行程记录表chat_partner：聊天的双方参与者message：会话记录存储表 结构 和各表之间的关系如下所示：开发准备a. 帐号申请开发小程序的第一步需要注册一个小程序帐号，可能这一步是小程序开发最大的障碍，因为不管哪种帐号都需要认证，特别是企业类型帐号认证需要企业工商营业执照和组织机构代码证，如果小程序需要支付功能，还需要提供对公帐号。但是你也可以使用个人帐号类型，但是个人帐号具备的功能很有限，比如不能支持支付功能等。有关小程序的注册类型和认证的疑问可以参考小程序注册类型和认证（https://kf.qq.com/product/wx_xcx.html#hid=hot_faq）。注册小程序帐号之后，就可以得到一个appId和secret key，它们跟小程序应用相绑定的，在后续API调用中是不可缺少的。b. 开发工具同开发其他应用程序一样，微信团队同样也有自己的开发集成工具。有关如何注册和下载开发工具，可以参考官方文档：注册和下载开发工具( https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/getstart.html )。下面简要介绍开发工具的常用功能：从上面图中可以看到开发工具由以下几个区域组成：功能预览区：代码编辑保存，开发工具会自动编译并生成预览，在该区域可以及时看到小程序渲染后的效果；文件浏览区：也就是文件浏览器，树状图形式可以展开和收拢；代码编辑区：提供代码阅读、搜索和编辑提示功能；网络调试区：集成的是google开发工具组件，功能相信大家已经很熟悉。最上面一排的按钮功能区，主要包括编译、代码上传和代码仓库版本管理以及云服务入口功能等。这里唯一需要普及的是小程序的代码构成。c.小程序代码组成一个小程序通常由一个描述整体程序的 app 和多个描述各自页面的 page页面模块组成。其中app主体部分由三个文件组成，必须放在项目的根目录，文件为：app.js: 控制小程序的全局业务逻辑；app.json：小程序的全局公共配置信息；app.wxml：小程序的全局公共样式，每个页面模块由4钟类型的文件组成，放置一个目录里面，四种类型的文件为：.json 后缀的 JSON 配置文件：存放配置信息；.wxml 后缀的 WXML 模板文件：页面内容模板，支持变量的动态渲染；.wxss 后缀的 WXSS 样式文件：页面样式定义；.js 后缀的 JS 脚本逻辑文件：js实现的业务逻辑，是页面模块中最重要的文件。比如我们项目的代码结构组成如下图所示：更多信息可以参考文档：小程序目录结构( https://developers.weixin.qq.com/miniprogram/dev/framework/structure.html )和代码构成( https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/code.html )前端设计我们先确定小程序的总体展现框架，在app.wxml圈定整体结构： 1{\r\n 2  \"cloud\": true,\r\n 3  \"pages\": [\r\n 4    \"pages/home/home\",//home tab页面\r\n 5    \"pages/position/position\",//定位服务页面\r\n 6    \"pages/drivers/drivers\",//司机和乘客发布的行程列表页面\r\n 7    \"pages/myroutes/myroutes\",//我的历史行程\r\n 8    \"pages/messages/messages\",//“message”tab页面\r\n 9    \"pages/chat/chat\",//聊天会话页面\r\n10    \"pages/detail/detail\",//行程信息详情\r\n11    \"pages/certificate/certificate\",//企业认证页面\r\n12    \"pages/enterprise/enterprise\",//\r\n13    \"pages/mine/mine\" //“我的”tab页面\r\n14  ],\r\n15  \"window\": {\r\n16    \"backgroundTextStyle\": \"light\",\r\n17    \"navigationBarBackgroundColor\": \"#fff\",\r\n18    \"navigationBarTitleText\": \"WeChat\",\r\n19    \"navigationBarTextStyle\": \"black\"\r\n20  },\r\n21  \"tabBar\": {\r\n22    \"color\": \"#ccc\",\r\n23    \"selectedColor\": \"#35495e\",\r\n24    \"borderStyle\": \"white\",\r\n25    \"backgroundColor\": \"#f9f9f9\",\r\n26    \"list\": [\r\n27      {\r\n28        \"text\": \"首页\",\r\n29        \"pagePath\": \"pages/home/home\",\r\n30        \"iconPath\": \"resources/icon_home.png\",\r\n31        \"selectedIconPath\": \"resources/icon_home.png\"\r\n32      },\r\n33      {\r\n34        \"text\": \"消息\",\r\n35        \"pagePath\": \"pages/messages/messages\",\r\n36        \"iconPath\": \"resources/icon_cate.png\",\r\n37        \"selectedIconPath\": \"resources/icon_home.png\"\r\n38      },\r\n39      {\r\n40        \"text\": \"我的\",\r\n41        \"pagePath\": \"pages/mine/mine\",\r\n42        \"iconPath\": \"resources/icon_member.png\",\r\n43        \"selectedIconPath\": \"resources/icon_home.png\"\r\n44      }\r\n45    ]\r\n46  },\r\n47  \"sitemapLocation\": \"sitemap.json\"\r\n48}\r\n其中\"cloud\": true表示我们接下来用到云服务，pages定义我们应用所有定义的页面模块路径，tabBar定义应用的展示框架，它是一个list结构，每个列表项目由tab名称、页面路径和图标路径组成。各个tab接下来详细介绍。首页Tab首页主要功能为司机和乘客发布行程计划，一旦行程计划发布就分别跳转到对应的列表页面。具体说就是，如果是乘客，则可以查看司机发布的出行列表信息，并可以邀请司机接单；如果是司机，则可以看到乘客的出行列表信息，并可以选择主动接单。我们将这一部分核心功能放在主页面内完成，因为无论是司机还是乘客都有共同的行为：发布行程信息，且基本项目一样，故可以复用该功能。a.行程计划行程计划页面是司机和乘客发布行程的主入口，主要展示行程发布的起始位置和价格等。我们定义一个模板：publishRoute.wxml，有关模板的更多信息可以参考模板( https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000ee2c29d4f805b0086a37a254c0a ) 1<template name=\"publishRoute\">\r\n 2  <form bindsubmit=\"publishRoute\">\r\n 3      <view style=\"display: flex;flex-direction: column;\">\r\n 4          <input bindtap=\"inputStartPosition\" style='padding: 10rpx;width:300px;margin-top: 10px;' placeholder=\"当前位置?\" value=\"{{startLocation.title}}\"></input>\r\n 5          <input name=\"startLocation\" style='display:none;' value=\"{{startLocation.title}}\"></input>\r\n 6          <input name=\"startAddr\" style='display:none;' value=\"{{startLocation.title}}\"></input>\r\n 7          <input name=\"startLatitude\" style='display:none;' value=\"{{startLocation.location.lat}}\"></input>\r\n 8          <input name=\"startLongitude\" style='display:none;' value=\"{{startLocation.location.lng}}\"></input>\r\n 9          <input bindtap=\"inputEndPosition\" style='padding: 10rpx;width:300px;'placeholder=\"想要去哪儿?\" value=\"{{endLocation.title}}\"></input>\r\n10          <input name=\"endLocation\" style='display:none;' value=\"{{endLocation.title}}\"></input>\r\n11          <input name=\"endAddr\" style='display:none;' value=\"{{endLocation.title}}\"></input>\r\n12          <input name=\"endLatitude\" style='display:none;' value=\"{{endLocation.location.lat}}\"></input>\r\n13          <input name=\"endLongitude\" style='display:none;' value=\"{{endLocation.location.lng}}\"></input>\r\n14          <input name=\"price\" type=\"number\"style='padding: 10rpx;width:300px;'placeholder=\"出价（单位:元）\"></input>\r\n15          <view class=\"btn-area\">\r\n16            <button type=\"primary\" formType=\"submit\">发布行程</button>\r\n17          </view>\r\n18      </view>\r\n19  </form>\r\n20</template>\r\n其中style='display:none;'的input组件是隐藏域，在表单提交时用到，它们的值在搜索定位完成后回显。输入起始位置的input组件分别绑定到事件回调函数inputStartPosition和inputEndPosition，当输入焦点落到输入框时候，调用对应函数进入搜索定位页面。我们将模版导入到首页home.wxml中: 1view class=\"nav\">\r\n 2  <view class='{{isDriver?\"default\":\"red\"}}'bindtap=\"passengerTabed\">我是乘客</view>\r\n 3  <view class='{{isDriver?\"red\":\"default\"}}' bindtap=\"driverTabed\">我是司机</view>\r\n 4</view>\r\n 5<view class='{{isDriver?\"show\":\"hidden\"}}'>\r\n 6  <import src=\"../home/publishRoute.wxml\"/>\r\n 7  <template is=\"publishRoute\" data=\"{{isDriver:isDriver,startLocation:startLocation,endLocation:endLocation,dateTimeArray:dateTimeArray,dateTime:dateTime}}\"/>\r\n 8</view>\r\n 9<view class=\"{{isDriver?'hidden':'show'}}\">\r\n10 <import src=\"../home/publishRoute.wxml\"/>\r\n11 <template is=\"publishRoute\" data=\"{{isDriver:isDriver,startLocation:startLocation,endLocation:endLocation,dateTimeArray:dateTimeArray,dateTime:dateTime}}\"/>\r\n12</view>\r\n13因为publishRoute.wxml作为home.wxml内容的一部分而存在，故我们将回调函数inputStartPosition和inputEndPosition定义在home.js文件中：\r\n14  inputStartPosition: function (e) {\r\n15    wx.navigateTo({\r\n16      url: '../position/position?isStartPos=true&isDriver=' + this.data.isDriver\r\n17    })\r\n18  },\r\n19  inputEndPosition: function (e) {\r\n20    wx.navigateTo({\r\n21      url: '../position/position?isStartPos=false&isDriver=' + this.data.isDriver\r\n22    })\r\n23  }\r\n在上面回调函数中导航到位置搜索页面。通过下面我们详细介绍搜索定位的实现。当发布行程的必要信息填写完毕后提交发布，发布事件回调函数绑定在form表单上：，函数定义接下来我们再做介绍。有关小程序事件的更多信息可以参考文档：小程序事件( https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000846df9a03909b0086a50025180a&highline=wx.navigateTo )b.位置搜索搜索页面提供位置模糊搜索功能，示意图如下：我们创建页面模块position，提供搜索关键词的查询、搜索历史记录查询等高级功能，为此我们把这部分功能封装为一个模块。为了简化开发，这里引入了一个第三方开源组件，可以参考: https://github.com/icindy/wxSearch 。 这里我们不需要这么复杂的功能，只是将我们根据关键词搜索到的候选位置信息展现在下拉列表即可。 wxSearch的展现部分核心代码wxSearch.wxml模板内容为： 1<template name=\"wxSearch\">\r\n 2  <view class=\"wxSearch\" bindtap=\"wxSearchTap\"  style=\"display:{{wxSearchData.view.isShow ? 'block':'none'}};height:{{wxSearchData.view.seachHeight}}px;top:{{wxSearchData.view.barHeight}}px;\">\r\n 3    <view  class=\"wxSearchInner\">\r\n 4        <view class=\"wxSearchMindKey\">\r\n 5            <view class=\"wxSearchMindKeyList\">\r\n 6                <block wx:for=\"{{wxSearchData.mindKeys}}\">\r\n 7                    <view class=\"wxSearchMindKeyItem\" bindtap=\"wxSearchKeyTap\" data-key=\"{{item}}\">{{item}}</view>\r\n 8                </block>\r\n 9            </view>\r\n10        </view>\r\n11      </view>\r\n12    </view>\r\n13</template>\r\nwxSearchData.mindKeys这里就是将位置列表遍历显示出来。在position.wxml中引入上述代码： 1<import src=\"wxSearch/wxSearch.wxml\"/>\r\n 2<form bindsubmit=\"confirm\">\r\n 3  <view class=\"wxSearch-section\">\r\n 4    <view class=\"wxSearch-pancel\">\r\n 5      <input name=\"position\" bindinput=\"wxSearchInput\" bindfocus=\"wxSerchFocus\" value=\"{{wxSearchData.value}}\" bindblur=\"wxSearchBlur\" class=\"wxSearch-input\" placeholder=\"搜索\"/>\r\n 6      <button class=\"wxSearch-button\" size=\"mini\" formType=\"submit\" plain=\"true\">确定</button>\r\n 7    </view>\r\n 8  </view>\r\n 9</form>\r\n10<template is=\"wxSearch\" data=\"{{wxSearchData}}\"/>\r\n11<view class=\"container\">\r\n12</view>\r\n然后在postion.js中定义函数wxSearchInput： 1 wxSearchInput: function (e) {\r\n 2    var that = this\r\n 3    this.data.queryLocations=[]\r\n 4    console.log(\"Searching \" + e.detail.value)\r\n 5    getApp().globalData.qqmapsdk.getSuggestion({\r\n 6      keyword: e.detail.value,\r\n 7      region: getApp().globalData.city,\r\n 8      success: function (res) {\r\n 9        var targets=new Array()\r\n10        for (let i = 0; i < res.data.length; i++) {\r\n11            targets.push(res.data[i].title)\r\n12            that.data.queryLocations[res.data[i].title] = res.data[i]\r\n13        }\r\n14        WxSearch.initMindKeys(targets)\r\n15      }\r\n16    })\r\n17    WxSearch.wxSearchInput(e, that); \r\n18  }\r\n其中WxSearch.initMindKeys(targets)将搜索到的候选位置名称放入wxSearch组件展示。当提交确认表单，将返回上一页面即home页面，将查询到的位置详细信息回显到上层页面，表单提交处理逻辑为： 1  confirm: function (event) {\r\n 2    console.log(event)\r\n 3    //WxSearch.wxSearchAddHisKey(this);\r\n 4    let pages = getCurrentPages();//当前页面\r\n 5    let prevPage = pages[pages.length - 2];//上一页面\r\n 6    var data={}\r\n 7    if (this.data.isStartPos=='true'){\r\n 8      data = { isStartPos: this.data.isStartPos, startLocation: this.data.selectedLocation}\r\n 9    }else{\r\n10      data = { isStartPos: this.data.isStartPos, endLocation: this.data.selectedLocation}\r\n11    }\r\n12    //直接给上一页面赋值\r\n13    prevPage.setData(data);\r\n14    wx.navigateBack({\r\n15      delta: 1\r\n16    })\r\n17  }\r\n有关页面导航接口的详细信息可以参考：页面导航( https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html )qqmapsdk.getSuggestion就是接下来要介绍的定位服务。c.定位服务上面调用的api接口：qqmapsdk.getSuggestion用的是腾讯位置服务：提供了地点搜索、关键词提示、（逆）地址解析、路径规划、距离计算、获取城市等功能。接口getSuggestion(options:Object) 中有两个比较重要的参数：关键词：keyword和当前区域：region。其中region参数可选，可以设置城市名，用于限定搜索范围，默认是全国。调用该接口需要申请密钥和下载JavaScriptSDK。有关该接口如何使用的更多信息可以参考官方文档：申请密钥( https://lbs.qq.com/qqmap_wx_jssdk/index.html )。在本小程序中，我们使用到根据输入关键词获取位置列表接口的详细指导可以参考：获取位置列表接口( https://lbs.qq.com/qqmap_wx_jssdk/method-getsuggestion.html )。这里详细介绍下如何获取当前region，因为当前region使用贯穿于打开小程序的整个请求生命周期，所以把获取的region作为全局变量，在小程序启动时候调用。我们在app.js中加载sdk组件：1var QQMapWX = require('utils/qqmap-wx-jssdk1.0/qqmap-wx-jssdk.js');\r\n2App({\r\n3  onLaunch: function () {\r\n4    var that = this;\r\n5    that.globalData.qqmapsdk = new QQMapWX({\r\n6      key: conf.getQqMapKey()\r\n7    });\r\n8}\r\n9})\r\n为了能够获取到当前region，首先需要获取到当前位置的经纬度坐标，然后根据经纬度坐标解析出文字表示的region，具体步骤如下：1. 获取当前经纬度坐标这里我们使用微信小程序提供的api接口，接口的详细说明可以参考文档：经纬度坐标( https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getLocation.html ) 1   wx.getLocation({\r\n 2      type: \"gcj02\",\r\n 3      success: function (res) {\r\n 4        console.log(res)\r\n 5        var latitude = res.latitude\r\n 6        var longitude = res.longitude\r\n 7        that.globalData.location = {\r\n 8          latitude: latitude,\r\n 9          longitude: longitude\r\n10        }\r\n11      }\r\n12    })\r\n2. 逆地址解析这里我们用到腾信位置服务的另一个接口：reverseGeocoder(options:Object)，该接口提供由坐标到坐标所在位置的文字描述的转换，输入坐标返回地理位置信息和附近poi列表。有关该接口的详细信息可以参考这里：逆地址解析]( https://lbs.qq.com/qqmap_wx_jssdk/method-reverseGeocoder.html )我们在home.js首页加载时候调用获取当前城市位置的文字描述。 1onLoad: function (option) {\r\n 2getApp().globalData.qqmapsdk.reverseGeocoder({\r\n 3      location: {\r\n 4        latitude: getApp().globalData.location.latitude,\r\n 5        longitude: getApp().globalData.location.longitude\r\n 6      },\r\n 7      success: function (res) {\r\n 8        console.log(res);\r\n 9        const { city } = res.result.address_component\r\n10        getApp().globalData.city = city\r\n11      }\r\n12  }）\r\n13}\r\n这里将上面获取的经纬度参数传进去，返回城市city名称。d.行程发布回到发布行程的函数定义，因为我们需要持久化用户的行程信息，这里我们使用了腾讯的云开发能力。所谓云开发能力就是微信为开发者提供了全套的云原生支持和微信服务支持，弱化后端开发和运维概念，用户无须搭建自己的服务器即可调用云端API实现自己的业务逻辑，目前微信提供的云开发能力包括云函数、云数据库、存储以及云调用。我们这里使用到云数据库。云数据库是一个 JSON 数据库，数据库中的每条记录都是一个 JSON 格式的对象。一个数据库可以有多个集合（相当于关系型数据中的表），集合可看做一个 JSON 数组，数组中的每个对象就是一条记录，记录的格式是 JSON 对象。使用云数据库需要先初始化，获取数据库实例的引用，我们在app.js中应用启动时候调用：1App({\r\n2  onLaunch: function () {\r\n3    wx.cloud.init({\r\n4      env: conf.getCloudEnv()\r\n5    })\r\n6  }\r\n7})\r\n其中env参数指定获取的数据库实例所在环境，比如开发环境和生产环境，用于数据库实例的区分。获取数据库实例之后，我们还需要通过文章开头提到的云开发入口，登录控制台创建集合：通过控制台我们可以手动创建集合，对集合进行增删改查，数据导入导出等功能。除此之外，集合还提供了丰富的常用api调用接口。有关云数据库的更多信息可以参考这里：云数据库( https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database.html ) 。。回到我们发布行程记录，虽然司机和乘客行程信息可以共享一个集合，但是为了方便后续的数据检索和分析，我们将其分开存储，分别命名为driver_route和passenger_route。行程记录包含的基本信息如下：基本字段包括用户的openid、起始位置（包含经纬度坐标和经过转换后的文字表示的地址）、价格、发布时间、出发时间以及用户信息（包含用户的图像、注册地）等。以下是司机发布行程核心逻辑，这里省略有关认证状态的验证逻辑: 1publishRoute: function (event) {\r\n 2    var userInfo = getApp().globalData.userInfo\r\n 3    var openId = getApp().globalData.openId\r\n 4    var that=this\r\n 5    userInfo.openId = openId\r\n 6    var route_collection = that.data.isDriver ? 'driver_route': 'passenger_route';\r\n 7    console.log(\"publish \" + route_collection)\r\n 8    publishRoute.addRoute(db, route_collection, event, userInfo)\r\n 9     wx.navigateTo({\r\n10     url: '../drivers/drivers?isDriver=' + that.data.isDriver\r\n11      })\r\n12}\r\npublishRoute.addRoute根据当前用户角色是司机还是乘客将记录存到不同的集合里面，定义如下： 1var utils = require('util.js');\r\n 2function addRoute(db,collect,event,userInfo){\r\n 3  db.collection(collect).add({\r\n 4    // data 字段表示需新增的 JSON 数据\r\n 5    data: {\r\n 6      // _id: 'todo-identifiant-aleatoire', \r\n 7      // 可选自定义 _id，在此处场景下用数据库自动分配的就可以了\r\n 8      publishDate: utils.formatTime(new Date()),\r\n 9      userInfo: userInfo,\r\n10      // endPoint: new db.Geo.Point(113, 23),\r\n11      startLocation: {\r\n12        address:event.detail.value.startLocation,\r\n13        addr: event.detail.value.startAddr,\r\n14        longitude: event.detail.value.startLongitude,                          \r\n15        latitude:event.detail.value.startLatitude\r\n16      },\r\n17      endLocation: {\r\n18        address:event.detail.value.endLocation,\r\n19        addr: event.detail.value.endAddr,\r\n20        longitude: event.detail.value.endLongitude, \r\n21        latitude:event.detail.value.endLatitude\r\n22      },\r\n23      price: event.detail.value.price,\r\n24      routeTime: event.detail.value.routeTime,\r\n25      routeTimeMills: new Date(event.detail.value.routeTimeMills).getTime()\r\n26    }\r\n27  })\r\n28}\r\ne.出行列表在出行列表里面，我们主要披露行程的创建人昵称、价格、起始位置和出发时间。我们新建driver页面模块。driver.wxml实现页面展示内容： 1{{isDriver?\"寻找的乘客列表\":\"寻找的司机列表\"}}\r\n 2<block wx:for=\"{{routes}}\" wx:for-item=\"route\">\r\n 3  <view class=\"list-item\" data-routeId=\"{{route._id}}\" bindtap=\"detail\">\r\n 4    <view style=\"width: 60px; height: 60px;margin:10px\">\r\n 5        <image style=\"width: 60px; height: 60px; background-color: #eeeeee;\" mode=\"{{driver}}\" src=\"{{route.userInfo.avatarUrl}}\"></image>\r\n 6    </view>\r\n 7    <view class='right'>\r\n 8      <view style=\"display: flex;flex-direction: column;height:40px;border-block-start: 10px;\">\r\n 9          <label class='title'>{{route.userInfo.gender}}</label>\r\n10          <label class='title'>{{route.userInfo.nickName}}</label>\r\n11      </view>\r\n12      <label class='price'>¥{{route.price}}</label>\r\n13    </view>\r\n14  </view>\r\n15  <view style=\"margin-top:30px;\">\r\n16    <view style=\"display: flex;flex-direction: column;margin:10px\">\r\n17        <label class='position'>{{route.startLocation.addr}}</label>\r\n18        <label class='position'>{{route.endLocation.addr}}</label>\r\n19        <label class='position'>{{route.routeTime}}</label>\r\n20      </view>\r\n21  </view>\r\n22</block>\r\n其中routes就是我们获取到的出行记录列表，注意到 每条记录绑定了一个到达详情页的回调函数和当前行程记录id，接下来再介绍。获取记录列表的函数定义如下： 1//pages/drivers/drivers.js\r\n 2const db = wx.cloud.database()\r\n 3 onLoad: function (options) {\r\n 4    this.setData({ isDriver: options.isDriver=='true'?true:false })\r\n 5    if (this.data.isDriver)\r\n 6      publishRoute.get_passenger_route(db, this,null)\r\n 7    else\r\n 8      publishRoute.get_driver_route(db, this, null)\r\n 9  }\r\n10这里我们同样是根据当前用户角色加载不同的出行记录：\r\n11function get_driver_route(db, that, condition){\r\n12  var coll=db.collection('driver_route')\r\n13  if (condition != null)\r\n14    coll = coll.where(condition)\r\n15   coll.get({\r\n16      success: function (res) {\r\n17        // res.data 是一个包含集合中有权限访问的所有记录的数据，不超过 20 条\r\n18        that.setData({ routes: res.data})\r\n19      }\r\n20    })\r\n21}\r\nf. 出行记录详情我们创建新的页面模块：detail，用用于展示记录详情，在详情页可以根据不同的角色进行不同的操作，比如如果是司机的出行记录，那么乘客可以邀请司机接单，如果是乘客记录，那么司机可以主动接单。原型图如下所示：detail.wxml页面展示内容为： 1  <view wx:for=\"{{routes}}\" wx:for-item=\"route\">\r\n 2   <view class=\"list-item\">\r\n 3    <view style=\"width: 60px; height: 60px;margin:10px\">\r\n 4        <image style=\"width: 60px; height: 60px; background-color: #eeeeee;\" mode=\"{{driver}}\" src=\"{{route.userInfo.avatarUrl}}\"></image>\r\n 5    </view>\r\n 6    <view class='right'>\r\n 7      <view style=\"display: flex;flex-direction: column;height:40px;border-block-start: 10px;\">\r\n 8          <label class='title'>{{route.userInfo.gender}}</label>\r\n 9          <label class='title'>{{route.userInfo.nickName}}</label>\r\n10      </view>\r\n11      <label class='price'>¥{{route.price}}</label>\r\n12    </view>\r\n13  </view>\r\n14  <view>\r\n15    <view style=\"display: flex;flex-direction: column;\">\r\n16        <label class='position'>{{route.startLocation.addr}}</label>\r\n17        <label class='position'>{{route.endLocation.addr}}</label>\r\n18        <label class='position'>{{route.routeTime}}</label>         \r\n19    </view>\r\n20  </view>\r\n21  <map class=\"map\" longitude=\"{{route.startLocation.longitude}}\" latitude=\"{{route.startLocation.latitude}}\"></map>\r\n22</view>\r\n23\r\n24<form bindsubmit=\"formSubmit\" report-submit=\"true\">\r\n25   <view>\r\n26    <input name=\"receiver_openid\" style='display:none;' value=\"{{route.publish_openid}}\"></input>\r\n27    <button formType=\"submit\" lang=\"zh_CN\" type=\"primary\">{{isDriver=='true'?'接单':'请他来接我'}}</button>\r\n28  </view>\r\n29</form>\r\n其中详情页面的内容跟列表中每个出行记录内容差不多，唯一差别就是样式而且多了个map地图组件，用户可视化展示出行记录的地点。map组件只需要告诉需要展示的经纬度既可。有关地图组件的详细信息可以参考文档：地图组件( https://developers.weixin.qq.com/miniprogram/dev/component/map.html )。记录详情页面根据行程id从集合读取一条记录： 1// pages/drivers/drivers.js\r\n 2const db = wx.cloud.database()\r\n 3 onLoad: function (options) {\r\n 4    var isDriver=(options.isDriver == 'true' ? true : false);\r\n 5    var routeId=options.routeId\r\n 6    console.log(options)\r\n 7    if (isDriver)\r\n 8      publishRoute.get_driver_route(db, this, { _id: routeId})\r\n 9    else\r\n10      publishRoute.get_passenger_route(db, this, { _id: routeId })\r\n11    this.setData({\r\n12      isDriver: isDriver,\r\n13    })\r\n14  }\r\n15})\r\n集合读取记录跟读取记录列表一样，唯一的区别就是可以根据出行id筛选一条记录。当乘客邀请接单时候，触发表单提交： 1formSubmit: function (event) {\r\n 2    console.log(event.detail.formId)\r\n 3    wx.navigateTo({\r\n 4      url: '../chat/chat?id=' + event.detail.value.receiver_openid,\r\n 5      success: function (res) {\r\n 6        console.log(res)\r\n 7      }, fail: function (res) {\r\n 8        console.log(res)\r\n 9      }\r\n10    })\r\n11  }\r\n实现逻辑是跳转到聊天页面，参数是司机的openid。有关聊天会话页面的实现逻辑，下文详细介绍。（本篇文章为付费文章，这里之前为预览部分。后续部分包括完整的开发流程详解和完整源代码，除了在这里付费阅读之外，如果您是gitchat会员，也可以在gitchat阅读：https://gitbook.cn/gitchat/activity/5d8ed1d5f261bd7c2b9e4ba1"}
{"title": "微信小程序bindtap与catchtap的区别", "author": "Rolan", "time": "2020-5-26 00:22", "content": "1、bindtap和catchtap的区别(1) 相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分。\r\n(2) 不同点：他们的不同点主要是bindtap是冒泡的，catchtap是非冒泡的。2、例子1、假如有三个view点击事件都是用的bindtap，三个view是层级包含关系?123456789<view id=\"outer\" bindtap=\"out\">    outer view    <view id=\"middle\" bindtap=\"middle\">        middle view        <view id=\"inner\" bindtap=\"inner\">            inner view        </view>    </view></view>　　 2、我么在js里代码是在相对应的事件打印出log，代码如下?out:function(e){\r\n    console.log(\"--out bindtap click\")\r\n}, middle: function (e) {\r\n    console.log(\"--middle bindtap click\")\r\n}, inner: function (e) {\r\n    console.log(\"--inner bindtap click\")\r\n} 3、bindtap执行结果点击out view打印出一条log --> out bindtap click\r\n\r\n点击middle view打印出两条log --> middle bindtap click--out bindtap click\r\n\r\n点击innew view打印出三条log --> inner bindtap click--middle bindtap click--out bindtap click\r\n\r\n可以看出bindtap不阻止向上冒泡，所以点击inner一直冒泡到了最外层。 4、如果我们只修改middle view的bindtap为catchtap点击out view打印出一条log --> out bindtap click（因为没有上层元素故而无法向上冒泡）\r\n\r\n点击middle view打印出一条log --> middle bindtap click（catchtap阻止向上冒泡）\r\n\r\n点击innew view打印出两条log --> inner bindtap click（catchtap阻止向上冒泡）本博客主要记录自己的学习点滴~，文章来源于总结，还有在工作中实际碰到的问题以记录。"}
{"title": "TensorFlow.js 微信小程序插件开始支持 WebAssembly", "author": "Rolan", "time": "2020-5-26 00:31", "content": "我们知道，微信小程序由一个描述整体程序的 app 和多个描述各自页面的 page 组成。小程序主体部分由 app.js、app.json、app.wxss三个文件组成，页面 page 则通常包含 js、wxml、json、wxss 文件。这些文件都是文本文件，由微信小程序引擎解析并解释执行。然而，随着业务需求越来越复杂，微信小程序的逻辑越来越复杂，相应的代码量随之变的越来越多。对于 js 代码的执行，通常需要进行 词法分析 -> 语法分析 -> 预解析 -> 解释执行 等过程，性能太差。当然，随着 JS 引擎在发展的过程中引入了许多优化手段如字节码缓存，可以省掉每次解释执行时重新遍历语法树的过程。特别是谷歌的 V8 的 JIT 技术，在运行过程中直接生成并缓存机器码，下次执行时可由计算机直接执行，极大的提升了执行速度。然而，由于 JavaScript 这门语言本身的缺陷，使得优化变得越来越困难。由于JavaScript没有静态变量类型，只有动态变量，上一秒可能是Array，下一秒就变成了Object，那么引擎所做的优化就失去了作用，这会导致运行效率降低。为了应对这一问题， WebAssembly 出现了。WebAssembly官方对 WebAssembly 的定义如下：WebAssembly（wasm）是一个可移植、体积小、加载快并且兼容 Web 的全新格式。嗯，估计你看了这个定义还是不知道 WebAssembly 是什么。简单来说，WebAssembly是一种新的字节码格式，旨在成为高级语言的编译目标，目前可以使用C、C++、Rust、Go、Java、C#等编译器（未来还有更多）来创建wasm模块（见下图）。该模块以二进制的格式发送到浏览器，并在专有虚拟机上执行，与JavaScript虚拟机共享内存和线程等资源。它是由 Google、Microsoft、Mozilla、Apple 等几家大公司合作发起的一个关于面向Web的通用二进制和文本格式的项目。关于字节码格式，可以参考 Java，因为 Java 程序就是一种与平台无关的字节码。首先，字节码是一种经过编译器编译之后的二进制代码，无需经过 解析 和 字节码编译 这两步。其次，WebAssembly强制使用静态类型，在语法上完全脱离JavaScript，同时具有沙盒化的执行环境，安全性更好。最后，WebAssembly可直接和html以及浏览器进行交互。相对于 JS，WebAssembly 有如下优点：体积小：由于浏览器运行时只加载编译成的字节码，一样的逻辑比用字符串描述的 JS 文件体积要小很多；加载快：由于文件体积小，再加上无需解释执行，WebAssembly 能更快的加载并实例化，减少运行前的等待时间；兼容性问题少：WebAssembly 是非常底层的字节码规范，制订好后很少变动，就算以后发生变化,也只需在从高级语言编译成字节码过程中做兼容。可能出现兼容性问题的地方在于 JS 和 WebAssembly 桥接的 JS 接口。微信小程序对WebAssembly的支持微信小程序在Android / iOS上用于执行脚本以及渲染组件的环境都不尽相同。在Android上，微信小程序的 Javascript 引擎采用了 V8，原生支持 WebAssembly，所以微信小程序在 Android 手机上提供 WebAssembly的支持。在iOS上，微信小程序采用了苹果公司的 JavaScriptCore 引擎，并没有原生支持 WebAssembly，但最新 JavaScriptCore 也已经支持 WebAssembly。在不久的将来，IOS 手机 的微信小程序会支持 WebAssembly。使用TensorFlow.js的WASM backendTensorFlow.js的WASM backend非常适合在中低端Android手机上使用。中低端手机的GPU往往相对CPU要弱一些，而WASM backend是跑在CPU上的，这就为中低端手机提供了另一个加速平台。而且WASM的能耗一般会更低。使用WASM backend需要修改package.json文件：{\r\n  \"name\": \"yourProject\",\r\n  \"version\": \"0.0.1\",\r\n  \"main\": \"dist/index.js\",\r\n  \"license\": \"Apache-2.0\",\r\n  \"dependencies\": {\r\n    \"@tensorflow/tfjs-core\": \"1.7.3\"，\r\n    \"@tensorflow/tfjs-converter\": \"1.7.3\",\r\n    \"@tensorflow/tfjs-backend-wasm\": \"1.7.3\",\r\n    ...\r\n  }\r\n}\r\n然后在app.js中设置 wasm backend, 你可以自行在服务器上托管 wasm 文件以提高下载速度, 下面例子中的 wasmUrl 可以替代成你的URL。const info = wx.getSystemInfoSync();\r\n    const wasmUrl = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@1.7.3/wasm-out/tfjs-backend-wasm.wasm';\r\n    const usePlatformFetch = true;\r\n    console.log(info.platform);\r\n    if (info.platform == 'android') {\r\n      setWasmPath(wasmUrl, usePlatformFetch);\r\n      tf.setBackend('wasm').then(() => console.log('set wasm backend'));\r\n    }\r\n注意使用WASM需要导入>= 1.7.3的tfjs库。小结本文介绍了 WebAssembly 以及微信小程序对 WebAssembly 的支持情况，最后介绍了如何启用TensorFlow.js的WASM backend。由于在苹果手机上还未能全面支持 WebAssembly，在加上 WebAssembly 技术出现的比较晚（2015年），需要时间的检验，要在项目中全面采用 WebAssembly 不现实。但是如果项目中某个功能模块存在性能瓶颈，使用传统的 JS 实现效率太低，这个时候可以考虑 WebAssembly。另外, 如果在低端 Android 手机上运行 tfjs 微信小程序，也可以考虑采用WASM backend。参考https://github.com/tensorflow/tfjs-wechatWebAssembly进阶系列一：WebAssembly是什么"}
{"title": "解决 uni-app 微信小程序项目中腾讯统计 mta 不上报数据的问题", "author": "Rolan", "time": "2020-5-26 00:31", "content": "# 解决 uni-app 微信小程序项目中腾讯统计 mta 不上报数据的问题\r\n\r\n在 `uni-app` 微信小程序项目开发中，发现腾讯统计 `mta` 不上报数据。\r\n\r\n## 1. 原因\r\n\r\n1. `uni-app` 框架与 `mta` 组件都对原生的 `Page` 对象进行了重写，在 `onLoad` 生命周期函数中上报数据，这一点开发者无感知\r\n2. 因为 `uni-app` 框架会首先加载自身框架脚本，导致 `mta` 后加载的脚本对 `Page` 对象重写无效（两者冲突）\r\n3. 所以，`mta` 组件中设置了 `\"autoReport\": true` 会导致数据不上报（`\"autoReport\": false` 配置不受影响，因为不需要重写 `Page`）\r\n\r\n`uni-app 框架脚本重写 Page`:var MPPage = Page;Page = function Page() {var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};initHook('onLoad', options);return MPPage(options);};mta-wechat-analysis.js 重写 Page`:function initOnload() {var a = Page;Page = function (b) {var c = b.onLoad;\r\nb.onLoad = function (a) {\r\n  c && c.call(this, a);\r\n  MTA.Data.lastPageQuery = MTA.Data.pageQuery;\r\n  MTA.Data.pageQuery = a;\r\n  MTA.Data.lastPageUrl = MTA.Data.pageUrl;\r\n  MTA.Data.pageUrl = getPagePath();\r\n  MTA.Data.show = !1;\r\n  MTA.Page.init()\r\n};\r\na(b)}}按理说，前后两次对 `Page` 进行重写，应该是不冲突、都有效的，但 `uni-app` 在对 Vue 组件转微信小程序原生组件时，使用了局部封装的函数，导致后面其他脚本对 `Page` 的重写无效function createPage(vuePageOptions) {return Component(parsePage(vuePageOptions));}## 2. 解决\r\n\r\n有两个解决方案：\r\n\r\n1. 把 `mta-wechat-analysis.js` 脚本放到 `uni-app` 框架脚本之前加载，但官方并没有提供这个功能，所以放弃这个方法\r\n2. 重写 Vue 组件，在 Vue 组件里上报统计数据\r\n\r\n因为 Vue 组件是不能重写生命周期函数的，所以只能重写调用生命周期函数的方法 `Vue.prototype.__call_hook`：\r\n\r\n`mta-wechat-analysis.js`:function initOnload() {var a = Page;Page = function (b) {var c = b.onLoad;b.onLoad = function (a) {c && c.call(this, a);MTA.Data.lastPageQuery = MTA.Data.pageQuery;MTA.Data.pageQuery = a;MTA.Data.lastPageUrl = MTA.Data.pageUrl;MTA.Data.pageUrl = getPagePath();MTA.Data.show = !1;MTA.Page.init()};a(b)import Vue from 'vue';+function initOnload() {// 重写 Vue.prototype.__call_hook 方法Vue.prototype.__call_hook_proxy = Vue.prototype.__call_hook;Vue.prototype.__call_hook = function(hook, args) {if (hook === 'onLoad') {MTA.Data.lastPageQuery = MTA.Data.pageQuery;MTA.Data.pageQuery = args;MTA.Data.lastPageUrl = MTA.Data.pageUrl;MTA.Data.pageUrl = getPagePath();MTA.Data.show = !1;MTA.Page.init();this.__call_hook_proxy(hook, args);};改写后的 [mta-wechat-analysis.js](https://github.com/senntyou/blogs/blob/master/resources/mta-wechat-analysis.js) 脚本可以[点这里下载](https://github.com/senntyou/blogs/blob/master/resources/mta-wechat-analysis.js)。\r\n\r\n## 后续\r\n\r\n更多博客，查看 [https://github.com/senntyou/blogs](https://github.com/senntyou/blogs)\r\n\r\n作者：[深予之 (@senntyou)](https://github.com/senntyou)\r\n\r\n版权声明：自由转载-非商用-非衍生-保持署名（[创意共享 3.0 许可证](https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh)）"}
{"title": "小程序运行机制以及相关知识点", "author": "Rolan", "time": "2020-5-27 00:09", "content": "可能今天在很多人眼中，小程序已经成为别人印象中的app，功能齐全，且可以完成各种功能以及业务。但是个人从小程序的诞生使用至今，在我眼中他依然是个轻量级应用，虽逐步的壮大，一些功能还是有所限制，但是从功能上的角度却无法与app相媲美。以微信小程序为例，也许今天大小限制8M，页面栈已经是15层，大小可开发约50~70个页面，的确已经很好的支持业务的开发以及功能的扩张。但是在小程序开始之初，页面栈仅为5，包大小限制1M，很多业务的确无法扩展。小程序也因业务的扩展，逐步逐渐支持工程化，如当前支持npm包。但我们从小程序的产品整体设计上，还是不能忘记这个限制，无止境的叠加页面以及业务。小程序的编译原理简单的借助大神的思路，描述一下小程序的编译原理。 我们都知道，小程序页面由View（视图层）,App Service(逻辑层)组成。它们在两个线程中运行（我们传统的h5,是单线程运行）。他们之间是由系统的JSBridage（常用于原生与h5交互的工具，可自行百度）进行交互的。视图层使用 WebView 渲染，iOS 中使用自带 WKWebView，在 Android 使用腾讯的 x5 内核（基于 Blink）运行。 逻辑层使用在 iOS 中使用自带的 JSCore 运行，在 Android 中使用腾讯的 x5 内核（基于 Blink）运行。以上原理借鉴来自大神yck。看到这里，是否明白，为什么小程序不支持直接获取dom跟bom了吧？因为不像h5在同一个层级，在逻辑层时间上压根没有dom，只有通过官方的写法，通过系统层去操作dom。小程序的常用第三方框架原生官方概念：官方自带笔者观点：只有原生代码，才能在对应的小程序环境跑起来。任何第三方框架，都是经过自己的bable编译成原生支持代码才能运行。因此，在不考虑多端的情况下，强烈推荐使用原生，这样可以绕过第三方的坑。Taro官方概念:官方命名解释为多端统一开发解决方案。京东研发笔者观点：这在多端中的需求中，相比原生的优势。此外，个人实践的应用中，taro是个人觉得为数不多兼容性较好的，坑相对较少。此外，官方还提供了taro-ui，ui从性能还有从外观，个人都是觉得写得非常的不错。 此外，他是利用React的方式开发小程序的框架。 使用 React的方式开发小程序的框架，同时支持生成多端应用，此外还支持转换rn等，如果同一项目需求有多个终端的要求。可以建议使用。kbone官方概念：Web 与小程序同构解决方案，腾讯研发。曾有这么一句话：kbone，十分钟让 Vue 项目同时支持小程序笔者观点：如果有当前vue项目，急需支持微信小程序的话，可以考虑。这是一个求快不求精的选择。为腾讯官方出品，但是时间上的沉淀并不长，坑位估计不会少。有兴趣继续深入可查看： wechat-miniprogram.github.io/kbone/docs/…mpvue官方概念：基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系笔者观点：小程序第三方中较早起家的框架。这是曾经vue开发者非常喜欢的框架，无成本的从vue的开发者，成为小程序开发者。植入了很多vue的概念，重写了babel，支持vuex，vue常用api等。不过貌似已经停止迭代了，使用慎重。uni-app官方概念：使用 Vue 语法开发小程序、H5、App的统一框架笔者观点：历史悠长，从hridyapp的时代就有了uni至今。将微信的api二次讽刺，用自己的uni-对象替换了wx对应去转移成对应的api。目前还是有部分使用者，部分培训机构也有提到（毕竟培训的都是重点）。WePY官方概念：支持组件化的小程序开发框架，腾讯原生框架笔者观点：只是略有了解，身边以及个人无人使用，不评论。chameleon官方概念：一套代码运行多端，一端所见即多端所见，滴滴研发笔者观点：同上。megalo官方概念：基于 Vue 的小程序开发框架，网易考拉研发笔者观点：同上。小程序如何工程化我们都知道，当前前端项目都有自己的脚手架，可随时更改自己的编译，如create-react-app，vue-cli等都自带webpack。而小程序的编译器属于内置编译器，我们没法对进行编译处理，当我们需要对整个项目进行编译或者工程化处理的时候，就会遇到瓶颈。这时候我们只能考虑自己嵌入工程化。实际上，今天的小程序工程化的意义不是特别大。我们曾经有很多需要工程化小程序的需要，比如：支持npm包，支持es7，支持代码压缩，支持自定义指令，支持typescript等。但是，小程序在长达几年的迭代中，也逐步支持着一些（但是总是慢前端架构一段很长的时间，比如es7到2019年才支持，前端早几年就可以用）那当前工程化可以解决什么问题呢？1)我们前端框架是否都用了css预处理。如less，sass。小程序由于自身定位是一个“小”项目，所以，官方可能认为不需要。但是我们实际业务中，或者手写代码的习惯，都习惯了less或者sass。2)植入eslint 等代码检查工具可能当前从这两个角度出发意义不大。但是，就跟上边所说，如再有什么新的技能点，是否还是要慢个几拍等官方支持？我们可提前做好准备。使用gulp支持多页面打包到对应的位置，相信对前端来说不是很困难吧？晚点可上传demo。小程序特别说明尺寸单位换算rpx换算px (屏幕宽度/750)\r\npx换算rpx (750/屏幕宽度)\r\n复制代码小程序bug转发（分享）小程序不能拿到成功结果\r\n复制代码小程序优化建议代码压缩，分包加载，控制图片源文件，首屏优化。\r\n复制代码小程序官方优势（相比web）1.支持服务通知推送。\r\n2.支持缓存数据推送。\r\n3.开放能力\r\n4.支持云端开发\r\n5.无需考虑兼容性\r\n6.成本较低，体验较好（相比web）\r\n复制代码"}
