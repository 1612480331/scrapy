{"title": "如何基于微信小程序开发网约车应用", "author": "Rolan", "time": "2020-5-20 00:54", "content": "项 目描述为了解决长途如跨城市的出行撮合需求，满足乘客和司机双方自由定价的意愿，特开发一款非及时的打车应用。基本功能是出行用户登录小程序后，根据自己角色选择发布行程计划。行程计划包括出行时间和起始位置以及期望价格；如果是乘客，发布自己的出行计划之后跳转到乘客发布的出行计划列表页，乘客可以点击期望的行程计划，邀请司机接单；如果是司机，需要验证是否已经认证通过。如果没有认证通过则跳转到认证页面，否则跳转到乘客发布的出行计划列表页，选择期望的出行计划，完成接单。司机和乘客通过聊天页面协调出行计划。暂不支持支付功能，由双方线下完成交易。用流程图描述为：系统原型主要提供3个Tab页面：“首页”、“消息”和“我的”。其中“首页”聚焦行程发布、行程查看和聊天会话等核心功能。“消息”聚焦历史会话检索等功能，在首页进行的会话会跳转到该tab页面。“我的”聚焦车主认证、司机或者乘客查看历史行程记录以及客服服务等功能。原型图如下所示：系统存储设计根据业务，存储表主要有以下几种：driver：司机认证记录表，包括司机个人信息以及认证状态等driver_route:司机发布的行程记录表passager_route：乘客发布的行程记录表bargin_route：成交的行程记录表chat_partner：聊天的双方参与者message：会话记录存储表 结构 和各表之间的关系如下所示：开发准备a. 帐号申请开发小程序的第一步需要注册一个小程序帐号，可能这一步是小程序开发最大的障碍，因为不管哪种帐号都需要认证，特别是企业类型帐号认证需要企业工商营业执照和组织机构代码证，如果小程序需要支付功能，还需要提供对公帐号。但是你也可以使用个人帐号类型，但是个人帐号具备的功能很有限，比如不能支持支付功能等。有关小程序的注册类型和认证的疑问可以参考小程序注册类型和认证（https://kf.qq.com/product/wx_xcx.html#hid=hot_faq）。注册小程序帐号之后，就可以得到一个appId和secret key，它们跟小程序应用相绑定的，在后续API调用中是不可缺少的。b. 开发工具同开发其他应用程序一样，微信团队同样也有自己的开发集成工具。有关如何注册和下载开发工具，可以参考官方文档：注册和下载开发工具( https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/getstart.html )。下面简要介绍开发工具的常用功能：从上面图中可以看到开发工具由以下几个区域组成：功能预览区：代码编辑保存，开发工具会自动编译并生成预览，在该区域可以及时看到小程序渲染后的效果；文件浏览区：也就是文件浏览器，树状图形式可以展开和收拢；代码编辑区：提供代码阅读、搜索和编辑提示功能；网络调试区：集成的是google开发工具组件，功能相信大家已经很熟悉。最上面一排的按钮功能区，主要包括编译、代码上传和代码仓库版本管理以及云服务入口功能等。这里唯一需要普及的是小程序的代码构成。c.小程序代码组成一个小程序通常由一个描述整体程序的 app 和多个描述各自页面的 page页面模块组成。其中app主体部分由三个文件组成，必须放在项目的根目录，文件为：app.js: 控制小程序的全局业务逻辑；app.json：小程序的全局公共配置信息；app.wxml：小程序的全局公共样式，每个页面模块由4钟类型的文件组成，放置一个目录里面，四种类型的文件为：.json 后缀的 JSON 配置文件：存放配置信息；.wxml 后缀的 WXML 模板文件：页面内容模板，支持变量的动态渲染；.wxss 后缀的 WXSS 样式文件：页面样式定义；.js 后缀的 JS 脚本逻辑文件：js实现的业务逻辑，是页面模块中最重要的文件。比如我们项目的代码结构组成如下图所示：更多信息可以参考文档：小程序目录结构( https://developers.weixin.qq.com/miniprogram/dev/framework/structure.html )和代码构成( https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/code.html )前端设计我们先确定小程序的总体展现框架，在app.wxml圈定整体结构： 1{\r\n 2  \"cloud\": true,\r\n 3  \"pages\": [\r\n 4    \"pages/home/home\",//home tab页面\r\n 5    \"pages/position/position\",//定位服务页面\r\n 6    \"pages/drivers/drivers\",//司机和乘客发布的行程列表页面\r\n 7    \"pages/myroutes/myroutes\",//我的历史行程\r\n 8    \"pages/messages/messages\",//“message”tab页面\r\n 9    \"pages/chat/chat\",//聊天会话页面\r\n10    \"pages/detail/detail\",//行程信息详情\r\n11    \"pages/certificate/certificate\",//企业认证页面\r\n12    \"pages/enterprise/enterprise\",//\r\n13    \"pages/mine/mine\" //“我的”tab页面\r\n14  ],\r\n15  \"window\": {\r\n16    \"backgroundTextStyle\": \"light\",\r\n17    \"navigationBarBackgroundColor\": \"#fff\",\r\n18    \"navigationBarTitleText\": \"WeChat\",\r\n19    \"navigationBarTextStyle\": \"black\"\r\n20  },\r\n21  \"tabBar\": {\r\n22    \"color\": \"#ccc\",\r\n23    \"selectedColor\": \"#35495e\",\r\n24    \"borderStyle\": \"white\",\r\n25    \"backgroundColor\": \"#f9f9f9\",\r\n26    \"list\": [\r\n27      {\r\n28        \"text\": \"首页\",\r\n29        \"pagePath\": \"pages/home/home\",\r\n30        \"iconPath\": \"resources/icon_home.png\",\r\n31        \"selectedIconPath\": \"resources/icon_home.png\"\r\n32      },\r\n33      {\r\n34        \"text\": \"消息\",\r\n35        \"pagePath\": \"pages/messages/messages\",\r\n36        \"iconPath\": \"resources/icon_cate.png\",\r\n37        \"selectedIconPath\": \"resources/icon_home.png\"\r\n38      },\r\n39      {\r\n40        \"text\": \"我的\",\r\n41        \"pagePath\": \"pages/mine/mine\",\r\n42        \"iconPath\": \"resources/icon_member.png\",\r\n43        \"selectedIconPath\": \"resources/icon_home.png\"\r\n44      }\r\n45    ]\r\n46  },\r\n47  \"sitemapLocation\": \"sitemap.json\"\r\n48}\r\n其中\"cloud\": true表示我们接下来用到云服务，pages定义我们应用所有定义的页面模块路径，tabBar定义应用的展示框架，它是一个list结构，每个列表项目由tab名称、页面路径和图标路径组成。各个tab接下来详细介绍。首页Tab首页主要功能为司机和乘客发布行程计划，一旦行程计划发布就分别跳转到对应的列表页面。具体说就是，如果是乘客，则可以查看司机发布的出行列表信息，并可以邀请司机接单；如果是司机，则可以看到乘客的出行列表信息，并可以选择主动接单。我们将这一部分核心功能放在主页面内完成，因为无论是司机还是乘客都有共同的行为：发布行程信息，且基本项目一样，故可以复用该功能。a.行程计划行程计划页面是司机和乘客发布行程的主入口，主要展示行程发布的起始位置和价格等。我们定义一个模板：publishRoute.wxml，有关模板的更多信息可以参考模板( https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000ee2c29d4f805b0086a37a254c0a ) 1<template name=\"publishRoute\">\r\n 2  <form bindsubmit=\"publishRoute\">\r\n 3      <view style=\"display: flex;flex-direction: column;\">\r\n 4          <input bindtap=\"inputStartPosition\" style='padding: 10rpx;width:300px;margin-top: 10px;' placeholder=\"当前位置?\" value=\"{{startLocation.title}}\"></input>\r\n 5          <input name=\"startLocation\" style='display:none;' value=\"{{startLocation.title}}\"></input>\r\n 6          <input name=\"startAddr\" style='display:none;' value=\"{{startLocation.title}}\"></input>\r\n 7          <input name=\"startLatitude\" style='display:none;' value=\"{{startLocation.location.lat}}\"></input>\r\n 8          <input name=\"startLongitude\" style='display:none;' value=\"{{startLocation.location.lng}}\"></input>\r\n 9          <input bindtap=\"inputEndPosition\" style='padding: 10rpx;width:300px;'placeholder=\"想要去哪儿?\" value=\"{{endLocation.title}}\"></input>\r\n10          <input name=\"endLocation\" style='display:none;' value=\"{{endLocation.title}}\"></input>\r\n11          <input name=\"endAddr\" style='display:none;' value=\"{{endLocation.title}}\"></input>\r\n12          <input name=\"endLatitude\" style='display:none;' value=\"{{endLocation.location.lat}}\"></input>\r\n13          <input name=\"endLongitude\" style='display:none;' value=\"{{endLocation.location.lng}}\"></input>\r\n14          <input name=\"price\" type=\"number\"style='padding: 10rpx;width:300px;'placeholder=\"出价（单位:元）\"></input>\r\n15          <view class=\"btn-area\">\r\n16            <button type=\"primary\" formType=\"submit\">发布行程</button>\r\n17          </view>\r\n18      </view>\r\n19  </form>\r\n20</template>\r\n其中style='display:none;'的input组件是隐藏域，在表单提交时用到，它们的值在搜索定位完成后回显。输入起始位置的input组件分别绑定到事件回调函数inputStartPosition和inputEndPosition，当输入焦点落到输入框时候，调用对应函数进入搜索定位页面。我们将模版导入到首页home.wxml中: 1view class=\"nav\">\r\n 2  <view class='{{isDriver?\"default\":\"red\"}}'bindtap=\"passengerTabed\">我是乘客</view>\r\n 3  <view class='{{isDriver?\"red\":\"default\"}}' bindtap=\"driverTabed\">我是司机</view>\r\n 4</view>\r\n 5<view class='{{isDriver?\"show\":\"hidden\"}}'>\r\n 6  <import src=\"../home/publishRoute.wxml\"/>\r\n 7  <template is=\"publishRoute\" data=\"{{isDriver:isDriver,startLocation:startLocation,endLocation:endLocation,dateTimeArray:dateTimeArray,dateTime:dateTime}}\"/>\r\n 8</view>\r\n 9<view class=\"{{isDriver?'hidden':'show'}}\">\r\n10 <import src=\"../home/publishRoute.wxml\"/>\r\n11 <template is=\"publishRoute\" data=\"{{isDriver:isDriver,startLocation:startLocation,endLocation:endLocation,dateTimeArray:dateTimeArray,dateTime:dateTime}}\"/>\r\n12</view>\r\n13因为publishRoute.wxml作为home.wxml内容的一部分而存在，故我们将回调函数inputStartPosition和inputEndPosition定义在home.js文件中：\r\n14  inputStartPosition: function (e) {\r\n15    wx.navigateTo({\r\n16      url: '../position/position?isStartPos=true&isDriver=' + this.data.isDriver\r\n17    })\r\n18  },\r\n19  inputEndPosition: function (e) {\r\n20    wx.navigateTo({\r\n21      url: '../position/position?isStartPos=false&isDriver=' + this.data.isDriver\r\n22    })\r\n23  }\r\n在上面回调函数中导航到位置搜索页面。通过下面我们详细介绍搜索定位的实现。当发布行程的必要信息填写完毕后提交发布，发布事件回调函数绑定在form表单上：，函数定义接下来我们再做介绍。有关小程序事件的更多信息可以参考文档：小程序事件( https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000846df9a03909b0086a50025180a&highline=wx.navigateTo )b.位置搜索搜索页面提供位置模糊搜索功能，示意图如下：我们创建页面模块position，提供搜索关键词的查询、搜索历史记录查询等高级功能，为此我们把这部分功能封装为一个模块。为了简化开发，这里引入了一个第三方开源组件，可以参考: https://github.com/icindy/wxSearch 。 这里我们不需要这么复杂的功能，只是将我们根据关键词搜索到的候选位置信息展现在下拉列表即可。 wxSearch的展现部分核心代码wxSearch.wxml模板内容为： 1<template name=\"wxSearch\">\r\n 2  <view class=\"wxSearch\" bindtap=\"wxSearchTap\"  style=\"display:{{wxSearchData.view.isShow ? 'block':'none'}};height:{{wxSearchData.view.seachHeight}}px;top:{{wxSearchData.view.barHeight}}px;\">\r\n 3    <view  class=\"wxSearchInner\">\r\n 4        <view class=\"wxSearchMindKey\">\r\n 5            <view class=\"wxSearchMindKeyList\">\r\n 6                <block wx:for=\"{{wxSearchData.mindKeys}}\">\r\n 7                    <view class=\"wxSearchMindKeyItem\" bindtap=\"wxSearchKeyTap\" data-key=\"{{item}}\">{{item}}</view>\r\n 8                </block>\r\n 9            </view>\r\n10        </view>\r\n11      </view>\r\n12    </view>\r\n13</template>\r\nwxSearchData.mindKeys这里就是将位置列表遍历显示出来。在position.wxml中引入上述代码： 1<import src=\"wxSearch/wxSearch.wxml\"/>\r\n 2<form bindsubmit=\"confirm\">\r\n 3  <view class=\"wxSearch-section\">\r\n 4    <view class=\"wxSearch-pancel\">\r\n 5      <input name=\"position\" bindinput=\"wxSearchInput\" bindfocus=\"wxSerchFocus\" value=\"{{wxSearchData.value}}\" bindblur=\"wxSearchBlur\" class=\"wxSearch-input\" placeholder=\"搜索\"/>\r\n 6      <button class=\"wxSearch-button\" size=\"mini\" formType=\"submit\" plain=\"true\">确定</button>\r\n 7    </view>\r\n 8  </view>\r\n 9</form>\r\n10<template is=\"wxSearch\" data=\"{{wxSearchData}}\"/>\r\n11<view class=\"container\">\r\n12</view>\r\n然后在postion.js中定义函数wxSearchInput： 1 wxSearchInput: function (e) {\r\n 2    var that = this\r\n 3    this.data.queryLocations=[]\r\n 4    console.log(\"Searching \" + e.detail.value)\r\n 5    getApp().globalData.qqmapsdk.getSuggestion({\r\n 6      keyword: e.detail.value,\r\n 7      region: getApp().globalData.city,\r\n 8      success: function (res) {\r\n 9        var targets=new Array()\r\n10        for (let i = 0; i < res.data.length; i++) {\r\n11            targets.push(res.data[i].title)\r\n12            that.data.queryLocations[res.data[i].title] = res.data[i]\r\n13        }\r\n14        WxSearch.initMindKeys(targets)\r\n15      }\r\n16    })\r\n17    WxSearch.wxSearchInput(e, that); \r\n18  }\r\n其中WxSearch.initMindKeys(targets)将搜索到的候选位置名称放入wxSearch组件展示。当提交确认表单，将返回上一页面即home页面，将查询到的位置详细信息回显到上层页面，表单提交处理逻辑为： 1  confirm: function (event) {\r\n 2    console.log(event)\r\n 3    //WxSearch.wxSearchAddHisKey(this);\r\n 4    let pages = getCurrentPages();//当前页面\r\n 5    let prevPage = pages[pages.length - 2];//上一页面\r\n 6    var data={}\r\n 7    if (this.data.isStartPos=='true'){\r\n 8      data = { isStartPos: this.data.isStartPos, startLocation: this.data.selectedLocation}\r\n 9    }else{\r\n10      data = { isStartPos: this.data.isStartPos, endLocation: this.data.selectedLocation}\r\n11    }\r\n12    //直接给上一页面赋值\r\n13    prevPage.setData(data);\r\n14    wx.navigateBack({\r\n15      delta: 1\r\n16    })\r\n17  }\r\n有关页面导航接口的详细信息可以参考：页面导航( https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html )qqmapsdk.getSuggestion就是接下来要介绍的定位服务。c.定位服务上面调用的api接口：qqmapsdk.getSuggestion用的是腾讯位置服务：提供了地点搜索、关键词提示、（逆）地址解析、路径规划、距离计算、获取城市等功能。接口getSuggestion(options:Object) 中有两个比较重要的参数：关键词：keyword和当前区域：region。其中region参数可选，可以设置城市名，用于限定搜索范围，默认是全国。调用该接口需要申请密钥和下载JavaScriptSDK。有关该接口如何使用的更多信息可以参考官方文档：申请密钥( https://lbs.qq.com/qqmap_wx_jssdk/index.html )。在本小程序中，我们使用到根据输入关键词获取位置列表接口的详细指导可以参考：获取位置列表接口( https://lbs.qq.com/qqmap_wx_jssdk/method-getsuggestion.html )。这里详细介绍下如何获取当前region，因为当前region使用贯穿于打开小程序的整个请求生命周期，所以把获取的region作为全局变量，在小程序启动时候调用。我们在app.js中加载sdk组件：1var QQMapWX = require('utils/qqmap-wx-jssdk1.0/qqmap-wx-jssdk.js');\r\n2App({\r\n3  onLaunch: function () {\r\n4    var that = this;\r\n5    that.globalData.qqmapsdk = new QQMapWX({\r\n6      key: conf.getQqMapKey()\r\n7    });\r\n8}\r\n9})\r\n为了能够获取到当前region，首先需要获取到当前位置的经纬度坐标，然后根据经纬度坐标解析出文字表示的region，具体步骤如下：1. 获取当前经纬度坐标这里我们使用微信小程序提供的api接口，接口的详细说明可以参考文档：经纬度坐标( https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getLocation.html ) 1   wx.getLocation({\r\n 2      type: \"gcj02\",\r\n 3      success: function (res) {\r\n 4        console.log(res)\r\n 5        var latitude = res.latitude\r\n 6        var longitude = res.longitude\r\n 7        that.globalData.location = {\r\n 8          latitude: latitude,\r\n 9          longitude: longitude\r\n10        }\r\n11      }\r\n12    })\r\n2. 逆地址解析这里我们用到腾信位置服务的另一个接口：reverseGeocoder(options:Object)，该接口提供由坐标到坐标所在位置的文字描述的转换，输入坐标返回地理位置信息和附近poi列表。有关该接口的详细信息可以参考这里：逆地址解析]( https://lbs.qq.com/qqmap_wx_jssdk/method-reverseGeocoder.html )我们在home.js首页加载时候调用获取当前城市位置的文字描述。 1onLoad: function (option) {\r\n 2getApp().globalData.qqmapsdk.reverseGeocoder({\r\n 3      location: {\r\n 4        latitude: getApp().globalData.location.latitude,\r\n 5        longitude: getApp().globalData.location.longitude\r\n 6      },\r\n 7      success: function (res) {\r\n 8        console.log(res);\r\n 9        const { city } = res.result.address_component\r\n10        getApp().globalData.city = city\r\n11      }\r\n12  }）\r\n13}\r\n这里将上面获取的经纬度参数传进去，返回城市city名称。d.行程发布回到发布行程的函数定义，因为我们需要持久化用户的行程信息，这里我们使用了腾讯的云开发能力。所谓云开发能力就是微信为开发者提供了全套的云原生支持和微信服务支持，弱化后端开发和运维概念，用户无须搭建自己的服务器即可调用云端API实现自己的业务逻辑，目前微信提供的云开发能力包括云函数、云数据库、存储以及云调用。我们这里使用到云数据库。云数据库是一个 JSON 数据库，数据库中的每条记录都是一个 JSON 格式的对象。一个数据库可以有多个集合（相当于关系型数据中的表），集合可看做一个 JSON 数组，数组中的每个对象就是一条记录，记录的格式是 JSON 对象。使用云数据库需要先初始化，获取数据库实例的引用，我们在app.js中应用启动时候调用：1App({\r\n2  onLaunch: function () {\r\n3    wx.cloud.init({\r\n4      env: conf.getCloudEnv()\r\n5    })\r\n6  }\r\n7})\r\n其中env参数指定获取的数据库实例所在环境，比如开发环境和生产环境，用于数据库实例的区分。获取数据库实例之后，我们还需要通过文章开头提到的云开发入口，登录控制台创建集合：通过控制台我们可以手动创建集合，对集合进行增删改查，数据导入导出等功能。除此之外，集合还提供了丰富的常用api调用接口。有关云数据库的更多信息可以参考这里：云数据库( https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database.html ) 。。回到我们发布行程记录，虽然司机和乘客行程信息可以共享一个集合，但是为了方便后续的数据检索和分析，我们将其分开存储，分别命名为driver_route和passenger_route。行程记录包含的基本信息如下：基本字段包括用户的openid、起始位置（包含经纬度坐标和经过转换后的文字表示的地址）、价格、发布时间、出发时间以及用户信息（包含用户的图像、注册地）等。以下是司机发布行程核心逻辑，这里省略有关认证状态的验证逻辑: 1publishRoute: function (event) {\r\n 2    var userInfo = getApp().globalData.userInfo\r\n 3    var openId = getApp().globalData.openId\r\n 4    var that=this\r\n 5    userInfo.openId = openId\r\n 6    var route_collection = that.data.isDriver ? 'driver_route': 'passenger_route';\r\n 7    console.log(\"publish \" + route_collection)\r\n 8    publishRoute.addRoute(db, route_collection, event, userInfo)\r\n 9     wx.navigateTo({\r\n10     url: '../drivers/drivers?isDriver=' + that.data.isDriver\r\n11      })\r\n12}\r\npublishRoute.addRoute根据当前用户角色是司机还是乘客将记录存到不同的集合里面，定义如下： 1var utils = require('util.js');\r\n 2function addRoute(db,collect,event,userInfo){\r\n 3  db.collection(collect).add({\r\n 4    // data 字段表示需新增的 JSON 数据\r\n 5    data: {\r\n 6      // _id: 'todo-identifiant-aleatoire', \r\n 7      // 可选自定义 _id，在此处场景下用数据库自动分配的就可以了\r\n 8      publishDate: utils.formatTime(new Date()),\r\n 9      userInfo: userInfo,\r\n10      // endPoint: new db.Geo.Point(113, 23),\r\n11      startLocation: {\r\n12        address:event.detail.value.startLocation,\r\n13        addr: event.detail.value.startAddr,\r\n14        longitude: event.detail.value.startLongitude,                          \r\n15        latitude:event.detail.value.startLatitude\r\n16      },\r\n17      endLocation: {\r\n18        address:event.detail.value.endLocation,\r\n19        addr: event.detail.value.endAddr,\r\n20        longitude: event.detail.value.endLongitude, \r\n21        latitude:event.detail.value.endLatitude\r\n22      },\r\n23      price: event.detail.value.price,\r\n24      routeTime: event.detail.value.routeTime,\r\n25      routeTimeMills: new Date(event.detail.value.routeTimeMills).getTime()\r\n26    }\r\n27  })\r\n28}\r\ne.出行列表在出行列表里面，我们主要披露行程的创建人昵称、价格、起始位置和出发时间。我们新建driver页面模块。driver.wxml实现页面展示内容： 1{{isDriver?\"寻找的乘客列表\":\"寻找的司机列表\"}}\r\n 2<block wx:for=\"{{routes}}\" wx:for-item=\"route\">\r\n 3  <view class=\"list-item\" data-routeId=\"{{route._id}}\" bindtap=\"detail\">\r\n 4    <view style=\"width: 60px; height: 60px;margin:10px\">\r\n 5        <image style=\"width: 60px; height: 60px; background-color: #eeeeee;\" mode=\"{{driver}}\" src=\"{{route.userInfo.avatarUrl}}\"></image>\r\n 6    </view>\r\n 7    <view class='right'>\r\n 8      <view style=\"display: flex;flex-direction: column;height:40px;border-block-start: 10px;\">\r\n 9          <label class='title'>{{route.userInfo.gender}}</label>\r\n10          <label class='title'>{{route.userInfo.nickName}}</label>\r\n11      </view>\r\n12      <label class='price'>¥{{route.price}}</label>\r\n13    </view>\r\n14  </view>\r\n15  <view style=\"margin-top:30px;\">\r\n16    <view style=\"display: flex;flex-direction: column;margin:10px\">\r\n17        <label class='position'>{{route.startLocation.addr}}</label>\r\n18        <label class='position'>{{route.endLocation.addr}}</label>\r\n19        <label class='position'>{{route.routeTime}}</label>\r\n20      </view>\r\n21  </view>\r\n22</block>\r\n其中routes就是我们获取到的出行记录列表，注意到 每条记录绑定了一个到达详情页的回调函数和当前行程记录id，接下来再介绍。获取记录列表的函数定义如下： 1//pages/drivers/drivers.js\r\n 2const db = wx.cloud.database()\r\n 3 onLoad: function (options) {\r\n 4    this.setData({ isDriver: options.isDriver=='true'?true:false })\r\n 5    if (this.data.isDriver)\r\n 6      publishRoute.get_passenger_route(db, this,null)\r\n 7    else\r\n 8      publishRoute.get_driver_route(db, this, null)\r\n 9  }\r\n10这里我们同样是根据当前用户角色加载不同的出行记录：\r\n11function get_driver_route(db, that, condition){\r\n12  var coll=db.collection('driver_route')\r\n13  if (condition != null)\r\n14    coll = coll.where(condition)\r\n15   coll.get({\r\n16      success: function (res) {\r\n17        // res.data 是一个包含集合中有权限访问的所有记录的数据，不超过 20 条\r\n18        that.setData({ routes: res.data})\r\n19      }\r\n20    })\r\n21}\r\nf. 出行记录详情我们创建新的页面模块：detail，用用于展示记录详情，在详情页可以根据不同的角色进行不同的操作，比如如果是司机的出行记录，那么乘客可以邀请司机接单，如果是乘客记录，那么司机可以主动接单。原型图如下所示：detail.wxml页面展示内容为： 1  <view wx:for=\"{{routes}}\" wx:for-item=\"route\">\r\n 2   <view class=\"list-item\">\r\n 3    <view style=\"width: 60px; height: 60px;margin:10px\">\r\n 4        <image style=\"width: 60px; height: 60px; background-color: #eeeeee;\" mode=\"{{driver}}\" src=\"{{route.userInfo.avatarUrl}}\"></image>\r\n 5    </view>\r\n 6    <view class='right'>\r\n 7      <view style=\"display: flex;flex-direction: column;height:40px;border-block-start: 10px;\">\r\n 8          <label class='title'>{{route.userInfo.gender}}</label>\r\n 9          <label class='title'>{{route.userInfo.nickName}}</label>\r\n10      </view>\r\n11      <label class='price'>¥{{route.price}}</label>\r\n12    </view>\r\n13  </view>\r\n14  <view>\r\n15    <view style=\"display: flex;flex-direction: column;\">\r\n16        <label class='position'>{{route.startLocation.addr}}</label>\r\n17        <label class='position'>{{route.endLocation.addr}}</label>\r\n18        <label class='position'>{{route.routeTime}}</label>         \r\n19    </view>\r\n20  </view>\r\n21  <map class=\"map\" longitude=\"{{route.startLocation.longitude}}\" latitude=\"{{route.startLocation.latitude}}\"></map>\r\n22</view>\r\n23\r\n24<form bindsubmit=\"formSubmit\" report-submit=\"true\">\r\n25   <view>\r\n26    <input name=\"receiver_openid\" style='display:none;' value=\"{{route.publish_openid}}\"></input>\r\n27    <button formType=\"submit\" lang=\"zh_CN\" type=\"primary\">{{isDriver=='true'?'接单':'请他来接我'}}</button>\r\n28  </view>\r\n29</form>\r\n其中详情页面的内容跟列表中每个出行记录内容差不多，唯一差别就是样式而且多了个map地图组件，用户可视化展示出行记录的地点。map组件只需要告诉需要展示的经纬度既可。有关地图组件的详细信息可以参考文档：地图组件( https://developers.weixin.qq.com/miniprogram/dev/component/map.html )。记录详情页面根据行程id从集合读取一条记录： 1// pages/drivers/drivers.js\r\n 2const db = wx.cloud.database()\r\n 3 onLoad: function (options) {\r\n 4    var isDriver=(options.isDriver == 'true' ? true : false);\r\n 5    var routeId=options.routeId\r\n 6    console.log(options)\r\n 7    if (isDriver)\r\n 8      publishRoute.get_driver_route(db, this, { _id: routeId})\r\n 9    else\r\n10      publishRoute.get_passenger_route(db, this, { _id: routeId })\r\n11    this.setData({\r\n12      isDriver: isDriver,\r\n13    })\r\n14  }\r\n15})\r\n集合读取记录跟读取记录列表一样，唯一的区别就是可以根据出行id筛选一条记录。当乘客邀请接单时候，触发表单提交： 1formSubmit: function (event) {\r\n 2    console.log(event.detail.formId)\r\n 3    wx.navigateTo({\r\n 4      url: '../chat/chat?id=' + event.detail.value.receiver_openid,\r\n 5      success: function (res) {\r\n 6        console.log(res)\r\n 7      }, fail: function (res) {\r\n 8        console.log(res)\r\n 9      }\r\n10    })\r\n11  }\r\n实现逻辑是跳转到聊天页面，参数是司机的openid。有关聊天会话页面的实现逻辑，下文详细介绍。（本篇文章为付费文章，这里之前为预览部分。后续部分包括完整的开发流程详解和完整源代码，除了在这里付费阅读之外，如果您是gitchat会员，也可以在gitchat阅读：https://gitbook.cn/gitchat/activity/5d8ed1d5f261bd7c2b9e4ba1"}
{"title": "微信小程序装饰器模式实践", "author": "Rolan", "time": "2020-5-21 00:16", "content": "场景应用中本身存在一个商品组件，如下：显示商品的基础信息在应用开发的过程中，为商品增加了一个状态： 失效 状态。UI设计图如下：###设计思路 从需求和UI上来看，新增的失效状态，对原组件的功能做了增加而不是修改,不影响原组件的功能，适用于装饰器模式。装饰器模式装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。介绍意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。何时使用：在不想增加很多子类的情况下扩展类。如何解决：将具体功能职责划分，同时继承装饰者模式。应用实例： 1、孙悟空有 72 变，当他变成\"庙宇\"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。缺点：多层装饰比较复杂。使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。注意事项：可代替继承。原组件代码index.wxml\r\n<view style=\"border: 1rpx solid red; padding: 10rpx;\">\r\n  <image src=\"{{goods.url}}\"></image>\r\n  <view>名称：{{goods.name}}</view>\r\n  <view>规格：{{goods.sku}}</view>    \r\n  <view wx:if=\"{{type === 'member'}}\">价格:{{goods.price * 0.7}}元</view>\r\n  <view wx:elif=\"{{type === 'activity'}}\">价格:{{goods.price * 0.8}}元</view>\r\n  <view wx:else>价格:{{goods.price}}元</view>\r\n</view>\r\n复制代码装饰器代码index.wxml\r\n<view class=\"container\">\r\n\t<view class=\"wrapper\" wx:if=\"{{wrapped}}\">\r\n    <view style=\"color:{{title.color}};font-size:{{title.fontSize}};\">{{title.text}}</view>\r\n\t</view>\r\n\t<slot />\r\n</view>\r\n复制代码index.js\r\n// components/decorator/index.js\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    wrapped: {\r\n      type: Boolean,\r\n      value: true\r\n    },\r\n    title: {\r\n      type: Object,\r\n      value: {\r\n        text: '已抢光',\r\n        color: 'white',\r\n        fontSize: '26rpx'\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n\r\n  }\r\n})\r\n复制代码具体代码看demodemo地址通过动态地传入属性，来控制deractor里面的内容，没有修改原组件，但是完美地实现需求，这就是《装饰器模式》的魅力吧！"}
{"title": "为什么不在微信小程序中使用骨架屏，来提升用户体验？", "author": "Rolan", "time": "2020-5-21 00:25", "content": "历史回顾：\r\n\r\n微信小程序原生性能优化实践\r\n微信小程序自定义组件 - 表格组件来啦\r\n通过微信小程序来实现 “钉钉打卡”\r\n记一次微信小程序项目分包，以及分包预下载\r\n微信小程序实践\r\n\r\n骨架屏在前端的应用里很普及，不过大多都是在H5的应用中，今天想谈的是微信小程序中如何使用骨架屏，以及小程序骨架屏的实现原理，针对骨架屏项目还可以提个PR，封装出来一个npm包形式的第三方，为前端社区做点小贡献。\r\n如何在微信小程序中使用骨架屏？\r\n一、安装和引入\r\n1.安装组件：\r\nnpm install --save miniprogram-skeleton\r\n复制代码2.引入skeleton自定义组件\r\n{\r\n  \"usingComponents\": {\r\n    \"skeleton\": \"../miniprogram_npm/miniprogram-skeleton\"\r\n  }\r\n}\r\n复制代码小程序中npm的配置及使用：\r\n\r\n在微信开发者工具中，设置 —> 项目设置—> 勾选使用npm模块。\r\n在微信开发者工具中，工具 —> 构建npm，构建完成会生成 miniprogram_npm 文件夹，项目用到的npm包都在这里。\r\n按照页面的使用路径，从 miniprogram_npm 引入需要的包。\r\n\r\n\r\n注意下小程序中npm的配置及使用比普通的npm包的使用多了一些配置，引出了 miniprogram_npm 的概念。\r\n\r\n二、使用骨架屏组件\r\n1.在wxml页面需要用到的地方使用，如下：\r\n<!--引入骨架屏模版 -->\r\n<skeleton wx:if=\"{{showSkeleton}}\"></skeleton>\r\n\r\n<!--index.wxml-->\r\n<!--给页面根节点class添加skeleton, 用于获取当前页面尺寸，没有的话就默认使用屏幕尺寸-->\r\n<view class=\"container skeleton\">\r\n    <view class=\"userinfo\">\r\n        <block>\r\n\t        <!--skeleton-radius 绘制圆形-->\r\n            <image class=\"userinfo-avatar skeleton-radius\" src=\"{{userInfo.avatarUrl}}\"\r\n                   mode=\"cover\"></image>\r\n             <!--skeleton-rect 绘制矩形-->\r\n            <text class=\"userinfo-nickname skeleton-rect\">{{userInfo.nickName}}</text>\r\n        </block>\r\n    </view>\r\n    <view style=\"margin: 20px 0\">\r\n        <view wx:for=\"{{lists}}\" class=\"lists\">\r\n            <icon type=\"success\" size=\"20\" class=\"list skeleton-radius\"/>\r\n            <text class=\"skeleton-rect\">{{item}}</text>\r\n        </view>\r\n    </view>\r\n\r\n    <view class=\"usermotto\">\r\n        <text class=\"user-motto skeleton-rect\">{{motto}}</text>\r\n    </view>\r\n\r\n    <view style=\"margin-top: 200px;\">\r\n        aaaaaaaaaaa\r\n    </view>\r\n</view>\r\n复制代码2.在js页面需要用到的地方使用，如下：\r\n初始化默认的数据，用于撑开页面结构，让骨架屏可以获取到整体的页面结构。\r\n//index.js\r\nPage({\r\n\tdata: {\r\n\t\tmotto: 'Hello World',\r\n\t\tuserInfo: {\r\n\t\t\tavatarUrl: 'https://wx.qlogo.cn/mmopen/vi_32/SYiaiba5faeraYBoQCWdsBX4hSjFKiawzhIpnXjejDtjmiaFqMqhIlRBqR7IVdbKE51npeF6X1cXxtDQD2bzehgqMA/132',\r\n\t\t\tnickName: 'jayzou'\r\n\t\t},\r\n\t\tlists: [\r\n\t\t\t'aslkdnoakjbsnfkajbfk',\r\n\t\t\t'qwrwfhbfdvndgndghndeghsdfh',\r\n\t\t\t'qweqwtefhfhgmjfgjdfghaefdhsdfgdfh',\r\n\t\t],\r\n\t\tshowSkeleton: true   //骨架屏显示隐藏\r\n\t},\r\n\tonLoad: function () {\r\n\t\tconst that = this;\r\n\t\tsetTimeout(() => {     //3S后隐藏骨架屏\r\n\t\t\tthat.setData({\r\n\t\t\t\tshowSkeleton: false\r\n\t\t\t})\r\n\t\t}, 3000)\r\n\t}\r\n})\r\n复制代码在微信小程序中使用骨架屏比较简单的，注意骨架屏组件的基础传参，以及显示和隐藏骨架屏的控制。\r\n来看看骨架屏的实现原理\r\n源码地址：github.com/jayZOU/skel…\r\n作者是腾讯的一位大佬，是他"}
{"title": "微信小程序本地缓存二次封装", "author": "Rolan", "time": "2020-5-21 00:51", "content": "新建wxCache.js/**\r\n * 本地缓存\r\n * @工具测试 https://tool.lu/timestamp/\r\n * @param key 缓存参数\r\n * @param value 缓存值\r\n * @param time 缓存时间(小时为单位，传1，就意味缓存1个小时) 非必传\r\n* */\r\nexport default class wxCache {\r\n    constructor() {\r\n      this.now = new Date().getTime();// 获取当前时间\r\n    }\r\n    \r\n    // 获取\r\n    get(key) {\r\n        this.now = new Date().getTime();// 获取当前时间\r\n        let time = wx.getStorageSync(key).time || false;// 获取缓存时间\r\n        if(time) {\r\n            if (parseInt(time) >= this.now ) {\r\n              // console.log('还没过期')\r\n              return wx.getStorageSync(key).value\r\n            }else {\r\n              // console.log('过期啦')\r\n              this.remove(key);// 删除字段info\r\n              return false\r\n            }\r\n        }else {\r\n            // 没有设置时间处理返回\r\n            return wx.getStorageSync(key)\r\n        }\r\n    };\r\n    \r\n    // 添加\r\n    put(key,value,time) {\r\n        let data;\r\n        if(time) {\r\n          let timefrom = parseInt(Number(time)*60*60*1000); // 小时转化毫秒\r\n            data = {\r\n              value: value,\r\n              time: timefrom + this.now\r\n            }\r\n        }else {\r\n          data = value;\r\n        }\r\n        wx.setStorageSync(key, data);\r\n    };\r\n\r\n    // 移除\r\n    remove(key) {\r\n        console.log('删除')\r\n        wx.removeStorageSync(key);\r\n    };\r\n\r\n    // 清空所有\r\n    clearall() {\r\n      wx.clearStorageSync();\r\n    }\r\n\r\n}app.js 全局导入import wxCache from './common/wxCache.js'// 导入wxCache.js\r\nApp({\r\n  data:{},\r\n  wxCache:new wxCache(),// 全局导入\r\n})使用app.wxCache.put('time','123',1); // 设置key为time，value为 '123',时间缓存时间为1小时\r\n\r\napp.wxCache.get('time');// 获取key为time的value"}
{"title": "浅谈 DoraemonKit 微信小程序 sdk", "author": "Rolan", "time": "2020-5-21 00:41", "content": "DoraemonKit 是什么\r\n一款移动端工具包，可以查看移动端的运行环境和 mock 接口，具体可以查看官网， 这次主要谈谈微信小程序端 sdk 的实现。\r\n小程序端主要支持了下面几个功能， 下面会逐一讲到。\r\n\r\nApp 信息\r\nApp 信息分为系统信息、账户信息、用户信息、授权信息\r\n这里面只要用到了微信的几个api， 包括getSystemInfo、getAccountInfoSync、getUserInfo 以及 getSetting，这个具体去看微信小程序api\r\n位置模拟\r\n这个有点 hack 意味，首先选择地理位置 wx.chooseLocation ， 在成功的回调里面用 defineProperty 去 mock getLocation 的返回值\r\nwx.chooseLocation({\r\n    success: res => {\r\n    this.setData({currentLatitude: res.latitude});\r\n    this.setData({currentLongitude: res.longitude})\r\n    Object.defineProperty(wx, 'getLocation', {\r\n        get(val) {\r\n            return function (obj) {\r\n                obj.success({latitude: res.latitude, longitude: res.longitude})\r\n            }\r\n        }\r\n    })\r\n    }\r\n})\r\n复制代码这样在后续我们调用 wx.getLocation 函数的时候，返回的都是我们之前选择地理位置的值，\r\nwx.getLocation({\r\n    type: 'gcj02',\r\n    success:res=> {\r\n        console.log(res.latitude, res.longitude)\r\n        \r\n    }\r\n})\r\n复制代码至于要恢复原来的数据，直接拿app上面的数据\r\n Object.defineProperty(wx, 'getLocation',{\r\n    get(val) {\r\n        return app.globalData.getLocation\r\n    }\r\n});\r\n复制代码缓存管理\r\n主要还是利用 wx.getStorageInfoSync 的api, 只不过把缓存中的 key 全部列举出来，提供可视化界面给开发人员去操作\r\nlet storageInfo = wx.getStorageInfoSync()\r\nthis.setData({limitSize:storageInfo.limitSize})\r\nthis.setData({currentSize:storageInfo.currentSize})\r\nstorageInfo.keys.forEach(key => {\r\n    let result = wx.getStorageSync(key)\r\n    let info = {\r\n        key,\r\n        value:result,\r\n        isModify:false,\r\n        ischecked:false\r\n    }\r\n    storageArr.push(info)\r\n});\r\n复制代码h5 任意门\r\n主要是提供我们内嵌 h5 快速输入 url 进行 h5 展示的入口，这个其实没什么好讲的，就是把 提供了扫码和 url 输入两个途径， 还有一个列表历史 url 展示\r\n请求注射\r\n这个主要是提供 http 返回数据的拦截，对于符合我们需要拦截的 key， 返回我们设置的 value，拦截的数据存储在全局的 app 里面\r\ngetApp().globalData['__HTTP_INJECTOR']\r\n复制代码至于怎么去拦截的, 还是去 hack wx.request方法，首先把 wx.request 缓存起来，app.globalData.originRequest = wx.request ，然后在hooksRequestSuccessCallback 中去决定是否去拦截\r\nhooksRequest() {\r\n    Object.defineProperty(wx,  \"request\" , { writable:  true });\r\n    const hooksRequestSuccessCallback = this.hooksRequestSuccessCallback\r\n    wx.request = function(options){\r\n        const originSuccessCallback = options.success\r\n        options.success = res => {\r\n            originSuccessCallback(hooksRequestSuccessCallback(res))\r\n        }\r\n        app.globalData.originRequest(options)\r\n    }\r\n},\r\n复制代码其中hooksRequestSuccessCallback 如下所示，遍历 this.data.interceptors.forEach 中的数据，查看 key 是否符合我们拦截的数据 key ，如果符合就替换数据\r\nhooksRequestSuccessCallback(res) {\r\n    let { data } = res\r\n    this.data.interceptors.forEach(interceptor => {\r\n        const { isRegex, key, value } = interceptor\r\n        const replaceKey = isRegex ? new RegExp(key, 'g') : key\r\n        const isNotStringData =  typeof data !== 'string'\r\n        if (isNotStringData) {\r\n            data = JSON.stringify(data)\r\n        }\r\n        data = data.replace(replaceKey,value)\r\n        if (isNotStringData) {\r\n            data = JSON.parse(data)\r\n        }\r\n    })\r\n    res.data = data\r\n    return res\r\n},\r\n复制代码更新版本\r\n其实有点像 app 里面的 检查更新，只不过对于的小程序的检查更新\r\nconst updateManager = wx.getUpdateManager();\r\n\r\nupdateManager.onCheckForUpdate(function (res) {\r\n    if(!res) {\r\n        // 请求完新版本信息的回调\r\n        wx.showModal({\r\n            title: '更新提示',\r\n            content: '当前已经是最新版本'\r\n        })\r\n    }\r\n});\r\n\r\nupdateManager.onUpdateReady(function () {\r\n    wx.showModal({\r\n        title: '更新提示',\r\n        content: '新版本已经准备好，是否重启应用？',\r\n        success(res) {\r\n            if (res.confirm) {\r\n                // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启\r\n                updateManager.applyUpdate()\r\n            }\r\n        }\r\n    })\r\n});\r\n\r\nupdateManager.onUpdateFailed(function () {\r\n    // 新版本下载失败\r\n})\r\n\r\n复制代码小结\r\n总的来说这款小程序工具 sdk 实现不算难，只要是看看怎么去运用微信给的 api 结合我们的需求去进行 hack 以及 怎么给微信小程序做工具库方便开发去诊断信息。"}
{"title": "微信小程序性能优化技巧", "author": "Rolan", "time": "2020-5-22 00:10", "content": "微信小程序如果想要优化性能，有关键性的两点：提高加载性能和提高渲染性能。一、提高加载性能　　当用户点击小程序后发生了什么？　　资源准备（代码包下载） ——  业务代码注入和渲染  ——  异步请求数据　　上面的三个状态，我们经常遇到，它们分别对应小程序的下面三个状态：有三个点的白屏阶段： 下载代码包的阶段没有三个点的白屏： 业务代码注入和渲染的阶段加载中： 业务代码中异步请求数据　　总的来说，小程序呈现到用户面前，实际上经历了下面两个阶段：运行环境的加载，下载代码包启动小程序。　　运行环境预加载：这步是微信做的。微信会在用户打开小程序之前就已经准备好环境，用户点击小程序入口后，直接下载小程序的代码包即可。　　下载代码包启动小程序，小程序代码包里面的代码，不是小程序的源代码，而是编译、压缩、打包之后的代码包。　　下图中，左侧的“预加载”对应的是运行环境的预加载，右侧的“小程序启动” 对应的是下载代码包启动小程序。　     小程序提供的运行环境，分为逻辑层（AppService）和 视图层（webView），逻辑层是执行javascript的地方，视图层是渲染页面的地方。当小程序的代码包下载完毕后，业务代码分别注入逻辑层和渲染层。　　提升加载性能的最最最关键性一点是，控制包的大小，这个也是微信官方的说法。　　提升体验最直接的方法是控制小程序包的大小，基本上可以说，1M的代码包，下载耗时1秒左右。　　控制包大小的措施：压缩代码，清理无用的代码wxss 覆盖率较高，较少或没有引入未被使用的样式。按需引入 wxss 资源，如果小程序中存在大量未使用的样式，会增加小程序包体积大小，从而在一定程度上影响加载速度图片放在cdn避免将不会被使用的文件打包进去采用分包策略分包预加载独立分包（版本要求有点高）　　除了上面讲的控制包的大小，对异步请求的优化也很重要。　　对异步请求的优化onLoad 阶段就可以发起请求，不用等ready请求结果放在缓存中, 下次接着用请求中可以先展示骨架图先反馈，再请求。比如说，点赞的按钮，可以先改变按钮的样式，再发起异步请求。二、提升渲染性能　　setData 干了啥？每调用一次setData, 都是逻辑层向渲染层的一次通讯，这个通信还不是直接传给webView, 而是通过走了native层，通讯的开销很大。　　渲染层收到通讯后，还需要重新渲染出来，所以，一次setData带来两次开销：通信的开销 + webview更新的开销。　　setData工作原理：　　小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。　　而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。　　由于小程序运行逻辑线程与渲染线程之上，setData的调用会把数据从逻辑层传到渲染层，数据太大会增加通信时间。　　在数据传输时，逻辑层会执行一次JSON.stringify来去除掉setData数据中不可传输的部分，之后将数据发送给视图层。　　同时，逻辑层还会将setData所设置的数据字段与data合并，使开发者可以用this.data读取到变更后的数据。1、减少setData的数据量：如果一个数据不能会影响渲染层，则不用放在setData里面2、合并setData的请求，减少通讯的次数3、列表的局部更新　　在一个列表中，有n条数据，采用上拉加载更多的方式，假如这个时候想对其中某一个数据进行点赞操作，还能及时看到点赞的效果。此时，可以采用setData全局刷新，点赞完成之后，重新获取数据，再次进行全局重新渲染，这样做的优点是：方便，快捷！缺点是：用户体验极其不好，当用户刷量100多条数据后，重新渲染量大会出现空白期（没有渲染过来）　　如果采用局部刷新，将点赞的id传过去，知道点的是那一条数据，重新获取数据，查找相对应id的那条数据的下标（index是不会改变的），用setData进行局部刷新this.setData({\r\n    list[index] = newList[index]\r\n})3、小心后台页面的js　　小程序中可能有n个页面，所有的这些页面，虽然都拥有自己的webview(渲染层)， 但是却共享同一个js运行环境。　　也就是说，当你跳到了另外一个页面（假设是B页面），本页面（假设是A页面）的定时器等js操作仍在进行，并且不会被销毁，并且会抢占B页面的资源。　　在h5的环境中，当我们跳转到其他页面，老页面的js环境会被自动销毁，定时器什么都被销毁掉了，因此我们不需要关心老页面中，还有哪些js代码可能还会执行。但是在小程序中，我们必须手动的“清理”掉这样的代码。4、小心onPageScroll　　pageScroll 事件，也是一次通讯，是webview层向js逻辑层的通讯。这次通讯也是开销较大，如果考虑到这个事件被频繁的调用，回调函数如果有复杂的setData的话，性能就会很差了。5、尽可能使用小程序组件　　自定义组件的更新只在组件内部进行，不受页面其他部分内容的影响；比如一些运营活动的定时模块可以单独抽出来，做成一个定时组件，定时组件的更新并不会影响页面上其他元素的更新；各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用。"}
{"title": "小程序框架原理之渲染流程及通信流程", "author": "Rolan", "time": "2020-5-22 00:47", "content": "MINA 是在微信中开发小程序的框架。其目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。MINA 提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，核心是一个响应的数据绑定系统。整个系统分为视图层(View)和逻辑层(App Service)，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。MINA 让数据与视图保持同步非常简单。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。MINA 是腾讯给微信小程序命名的框架，实际上应用的是目前业界最著名的 MVVM 模式。wxml的真实面目#我们都知道小程序提供了很多方便快捷的自定义组件（标签），但你知道小程序的这些组件编译过后会渲染成什么吗？先说答案，其实 wxml 经过编译后会渲染成 html 。很简单的一点，你发现在小程序内编写 html 标签，最终也可以运行。探寻#光说可能体会不到，下面开始探寻小程序真实渲染的样子。先看下开发者工具内 wxml 的内容，待会和真实渲染的内容做对比。接下来一步步找到小程序 wxml 渲染完成的真实样子，工具菜单栏点击微信开发者工具，选择调试微信开发者工具。打开的控制台可以调试整个微信开发者工具，用调试箭头指向小程序内容区域，这时可以看到小程序视图层是被嵌套在 webview 的 iframe 内。但是当我们点开 iframe 是无法查看到里面内容的。如果想要查看调试 webview，只需选中 webview 打开它的调试工具即可，在控制台输入以下代码：Copy$$('webview')[0].showDevTools(true)可以看到又打开了一个调试窗口，这里面就是小程序视图层渲染的真实样子：可以看到结构和 wxml 里的内容几乎一模一样，只是 topbar 变成了 wx-topbar，view 变成了 wx-view等。这些都是内部实现的一套对应小程序标签的 webComponent 组件，而 webComponent 实际渲染出来还是 html 标签。转换过程#转换过程是微信开发者工具内部通过一个可执行编译工具实现对小程序文件转换。在微信开发者工具控制台输入 openVendor() 会打开一个文件夹，里面存放着微信的基础库及工具，在里面可以找到 wcc.exe、wcsc.exe 执行文件，分别对应 wxml 和 wxss 的文件转换。该工具可以单独对小程序文件进行转换，使用方法 ./wcc -d wxml文件路径 >> 输出路径。例如，将工具复制到一个文件夹内，再将一个 wxml 放入该文件夹内，命令行输入 :Copy./wcc -d index.wxml >> index.js\r\n可能有人很好奇为什么是生成 js 文件，而不是 html 文件。原因很简单，因为需要处理 wxml 的动态绑定数据。看看这个 js 文件生成的是什么：因为这些都是混淆压缩过的代码，基本没有可读性。这里只需要注意一个函数就好，那就是 $gwx。这是个很关键的函数，它的作用是生成虚拟dom树，用于渲染真实节点。接下来回到 webview 调试窗口，在 head 内找到这段插入的 script 标签代码:有没有很熟悉，没错，就是和上面转换后的代码是同一个东西。也就是说，我们的 wxml 文件通过编译，最终在视图层中执行的就是这段 js 代码（这里只是可以大概这么理解，实际需要向逻辑层获取数据才能渲染页面）。控制台输入 $gwx 发现这个函数存在，那么这个函数如何生成虚拟dom呢？$gwx 函数的第一个参数接收一个路径参数，这个路径就是 wxml 文件路径，此时在控制台输入：Copylet generateFunc = $gwx('./pages/index/index.wxml')generateFunc()这时页面虚拟dom就生成出来了：单纯调用 generateFunc 生成出来的虚拟dom是没有动态绑定数据的，如果想要动态的绑定数据，在调用 generateFunc 时传入一个数据对象。但是数据全在逻辑层里，这时就需要进行通信了。数据通信#首先要知道小程序时运行在基础库之上的，但它们都是压缩打包好的，后面找到反编译出来的基础库代码，其中最重要的就是 WAService.js 和 WAWebview.js，它们分别是视图层和逻辑层的核心实现。它们之间需要一个桥梁来进行通信，那就是 JS Bridge。JS Bridge 提供调用原生功能的接口（摄像头，定位等），它的核心是构建原生和非原生间消息通信的通道，而且这个通信的通道是双向的。通过 JS Bridge 的发布订阅方法，视图层和逻辑层进行数据通信。通信流程#接下来看看视图层和逻辑层的交互流程：wxml 转换成对应的 js 文件，等待生成虚拟dom函数 $gwx 准备完成，使用 dispatchEvent 通知 WAWebview。WAWebview 监听到 generateFuncReady 事件触发，使用 WeixinJSBridge.publish 向逻辑层通信。逻辑层处理逻辑，也就是我们平常写的小程序 js 文件里的东西，然后通过 JS Bridge 通知并返回数据给视图层。视图层接收到数据，将数据传入生成虚拟dom的函数内，渲染页面，当然小程序也有相应的diff算法。例如在 wxml 中绑定一个动态数据 title，视图层接收到数据后，重新生成虚拟domCopygenerateFunc({  title: '标题'})初始化完成后，就会走对应的其他生命周期，或者用户触发事件，数据都会在逻辑层处理完成后通过 JS Bridge 通知到视图层，视图层再次调用生成虚拟dom的函数，更新页面。wxss如何工作#wxss 工作原理和 wxml 差不多，都是通过工具转换为 js。为什么又是转换成 js，因为有 rpx 单位，需要根据手机尺寸进行设置 px。wcsc.exe 转换命令如下：Copy./wcsc -js index.wxss >> index.js可以看到文件开头就是对 rpx 的转换之后创建 style 标签，动态添加到视图层中最后#附上 WAService.js 和 WAWebview.js 的代码作为学习参考。"}
{"title": "微信小程序实现地图marker点聚合功能", "author": "Rolan", "time": "2020-5-22 00:51", "content": "写在前面的话\r\n公司项目需求要在微信小程序上实现地图marker点聚合的功能，百度苦寻无果，故自己实现。\r\n最终效果\r\n功能演示\r\n\r\n核心思路\r\n\r\nmarker标签中的callout属性用来显示聚合点的数量\r\n点击聚合点时，以聚合点为中心放大地图，不需要再次请求后台接口\r\n根据map组件scale缩放级别将地图分成一个一个的小格子，计算小格子中marker点的数量\r\n由于小程序无法像网页端那样处理庞大的数据量，为了提高用户体验，地图状态为缩放或者范围缩小时缓存上次marker数据，无需请求后台接口\r\n\r\n关键js文件\r\n\r\nMapUtil.js （判断是否为缩放状态，根据后台接口数据格式化成地图聚合类型marker数据等）\r\nZjMarker.js（maker点基类，根据简单的参数构建单个marker及聚合marker）\r\n\r\n具体实现\r\nMapUtil.js\r\nimport {\r\n  zjMarker\r\n} from '../../utils/mapUtil/ZjMarker';\r\nimport {\r\n  transformFromWGSToGCJ\r\n} from '../WSCoordinate';\r\nexport class MapUtil {\r\n  constructor(northeast, southwest, scale) {\r\n    this.northeast = northeast;\r\n    this.southwest = southwest;\r\n    this.scale = scale;\r\n    console.log('初始化mapUtil成功');\r\n    console.log(this.northeast, 'northeast');\r\n  }\r\n  //设置初始化范围\r\n  setInitData(northeast, southwest, scale) {\r\n    this.northeast = northeast;\r\n    this.southwest = southwest;\r\n    this.scale = scale;\r\n    console.log('刷新mapUtil成功');\r\n  }\r\n  //判断是否为缩放，\r\n  checkRefresh(northeast, southwest) {\r\n    console.log('检测是否可以刷新接口');\r\n    console.log(this.northeast, 'northeast');\r\n    console.log(northeast, 'currentNortheast');\r\n    let result = true;\r\n    if (this.northeast.latitude > northeast.latitude) {\r\n      console.log('东北纬度缩小');\r\n    }\r\n    if (this.southwest.latitude < southwest.latitude) {\r\n      console.log('西南纬度增高');\r\n    }\r\n    if (this.northeast.longitude > northeast.longitude) {\r\n      console.log('东北经度增大');\r\n    }\r\n    if (this.southwest.longitude < southwest.longitude) {\r\n      console.log('西南经度缩小');\r\n    }\r\n    if (this.northeast.latitude > northeast.latitude && this.southwest.latitude < southwest.latitude &&\r\n      this.northeast.longitude > northeast.longitude && this.southwest.longitude < southwest.longitude) {\r\n      console.log('地图缩放，不请求接口');\r\n      result = false\r\n    }\r\n    return result;\r\n  }\r\n  //根据东北 西南经纬度 以及后台返回标记点 格式化成小程序marker点\r\n  getFortMatMarkerList(northeast, southwest, scale, backendMarkerList) {\r\n    //屏幕中显示的经度的长度和纬度的长度\r\n    let mapWidth = southwest.longitude - northeast.longitude;\r\n    let mapHeight = northeast.latitude - southwest.latitude;\r\n    //将屏幕中地图分割的横向 格子数和 纵向格子数\r\n    let widthSize = scale;\r\n    let heightSize = widthSize + parseInt(scale / 2);\r\n    //计算每个格子的经纬度的长度\r\n    let unitWidth = mapWidth / widthSize;\r\n    let unitHeight = mapHeight / heightSize;\r\n    let pointData = {};\r\n    backendMarkerList.forEach(latLng => {\r\n      //如果点在显示范围内\r\n      if (latLng.latitude < northeast.latitude && latLng.latitude > southwest.latitude &&\r\n        latLng.longitude < northeast.longitude && latLng.longitude > southwest.longitude) {\r\n        let relativeX = latLng.longitude - northeast.longitude;\r\n        let relativeY = latLng.latitude - southwest.latitude;\r\n        //计算出这个点，处于哪个格子\r\n        let x = parseInt(Math.floor(relativeX / unitWidth));\r\n        let y = parseInt(Math.floor(relativeY / unitHeight));\r\n        if (x < 0 || y < 0) {\r\n          console.log('点位不在格子内', '失败');\r\n        }\r\n        //生成单元格点位数据\r\n        let pointKey = x + ',' + y;\r\n        if (pointData[pointKey] == undefined) {\r\n          pointData[pointKey] = [];\r\n        }\r\n        pointData[pointKey].push(latLng);\r\n      }\r\n    });\r\n    let resultMapArray = [];\r\n    for (let y = 0; y < heightSize; y++) {\r\n      for (let x = 0; x < widthSize; x++) {\r\n        let pointKey = x + ',' + y;\r\n        //筛选没有充电站点位的格子\r\n        if (pointData[pointKey] != undefined) {\r\n          let markerItem = {};\r\n          //聚合点与单点共存 , 长度等于一 不聚合点\r\n          if (pointData[pointKey].length == 1) {\r\n            let iconPath = pointData[pointKey][0].ScanAndCharge == 1 ? '/img/scanMarkerIcon.png' : '/img/markerIcon.png';\r\n            markerItem = new zjMarker(pointData[pointKey][0].longitude, pointData[pointKey][0].latitude, pointData[pointKey][0].StationID, {\r\n              iconPath: iconPath\r\n            })\r\n            //长度大于一 聚合点\r\n          } else if (pointData[pointKey].length > 1) {\r\n            let iconPath = pointData[pointKey][0].ScanAndCharge == 1 ? '/img/cluScanMarkerIcon.png' : '/img/cluMarkerIcon.png';\r\n            markerItem = new zjMarker(pointData[pointKey][0].longitude, pointData[pointKey][0].latitude, pointData[pointKey][0].StationID, {\r\n              type: 'cluster',\r\n              iconPath: iconPath,\r\n              num: pointData[pointKey].length\r\n            })\r\n          }\r\n          resultMapArray.push(markerItem);\r\n        }\r\n      }\r\n    }\r\n    console.log(resultMapArray, 'resultMapArray');\r\n    return resultMapArray;\r\n  }\r\n  //获取中心纬度\r\n  getCenterLocation(northeast, southwest) {\r\n    let mapWidth = southwest.longitude - northeast.longitude;\r\n    let mapHeight = northeast.latitude - southwest.latitude;\r\n    let longitude = northeast.longitude + mapWidth;\r\n    let latitude = southwest.latitude + mapHeight;\r\n    return {\r\n      latitude: latitude,\r\n      longitude: longitude\r\n    }\r\n  }\r\n}\r\n\r\nZjMarker.js\r\n//地图marker标记点基类 （单点`聚合）\r\nexport class zjMarker {\r\n  constructor(longitude, latitude, id, options = {}) {\r\n    this.longitude = longitude;\r\n    this.latitude = latitude;\r\n    this.id = id;\r\n    this.width = options.width ? options.width : 30;\r\n    this.height = options.height != undefined ? options.height : 36;\r\n    let type = options.type == undefined ? 'single' : options.type;\r\n    this.iconPath = options.iconPath == undefined ? '/img/markerIcon.png' : options.iconPath;\r\n    if (type != 'single') {\r\n      this.callout = {\r\n        content: options.num, //文本\r\n        color: '#000', //文本颜色\r\n        borderRadius: 3, //边框圆角\r\n        borderWidth: 0, //边框宽度\r\n        bgColor: 'transparent', //背景色\r\n        padding: 0, //文本边缘留白,\r\n        display: 'ALWAYS',\r\n        textAlign: 'center', //文本对齐方式。有效值: left, right, center,\r\n        anchorY: 62 //可能需要根据各个手机做出相应的适配\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n最后，在map组件中实现bindregionchange方法获取东北以及西南经纬度，根据经纬度范围判断是否需要请求后台接口重新获取点位信息\r\n if (mapUtil.checkRefresh(res.northeast, res.southwest)) {\r\n                console.log('开始刷新接口');\r\n                let location = mapUtil.getCenterLocation(res.northeast, res.southwest);\r\n                that.loadMapData(location.latitude, location.longitude, markerList => {\r\n                  markerList.forEach(item => {\r\n                    item.longitude = item.StationLng;\r\n                    item.latitude = item.StationLat;\r\n                  });\r\n                  oriMarkerList = markerList;\r\n                  that.setData({\r\n                    markerList: mapUtil.getFortMatMarkerList(res.northeast, res.southwest, scale, markerList)\r\n                  });\r\n                });\r\n                mapUtil.setInitData(res.northeast, res.southwest, scale);\r\n              } else {\r\n                that.setData({\r\n                  markerList: mapUtil.getFortMatMarkerList(res.northeast, res.southwest, scale, oriMarkerList)\r\n                });\r\n              }\r\n\r\n详情请咨询我 vx:a21544182123"}
{"title": "小程序页面间传递数据", "author": "Rolan", "time": "2020-5-22 00:28", "content": "最近在做小程序项目，发现小程序的页面间经常需要传递一些数据。根据自己的了解和熟悉，针对不同的数据要求，总结到有几种不同的传数据方式，下面做一下简单的介绍归纳。\r\n第一种：页面跳转时通过url传递\r\n使用wx.navigateTo 与 wx.redirectTo 的时候，可以将部分数据放在 url 里面，并在新页面 onLoad 的时候获取且初始化。\r\n//pageA.js\r\n\r\n// Navigate\r\nwx.navigateTo({\r\n  url: '../pageB/pageB?name=lin&gender=male',\r\n})\r\n\r\n// Redirect\r\nwx.redirectTo({\r\n  url: '../pageB/pageB?name=lin&gender=male',\r\n})\r\n\r\n// pageB.js\r\n...\r\nPage({\r\n  onLoad: function(option){\r\n    console.log(option.name + 'is' + option.gender);\r\n    this.setData({\r\n      option: option\r\n    });\r\n  }\r\n})\r\n\r\n需要注意的问题：\r\n\r\n使用wx.navigateTo 与 wx.redirectTo时，不允许跳转到 tab 所包含的页面；\r\n\r\nonLoad只执行一次；\r\n\r\n适用：\r\n这种方式一般适用于少数页面之间需要少量数据传递，如B页面需要A页面中的1-2个数据等等。\r\n第二种：使用全局变量来传递\r\n在 app.js 文件中定义全局变量 globalData，旧页面将要传递的数据赋值存放在里面，新页面调用全局变量获取传递数据值。\r\n// app.js\r\n\r\nApp({\r\n     // 全局变量\r\n  globalData: {\r\n    name: null\r\n  }\r\n})\r\n\r\n//pageA.js\r\n···\r\ngetApp().globalData.name = \"lin\";\r\n\r\n\r\n//pageB.js\r\n···\r\nthis.setData({\r\n  userName: getApp().globalData.name\r\n});\r\n\r\n要注意的问题：\r\n\r\n使用的时候，直接使用 getApp() 拿到存储的信息。\r\n\r\n适用：\r\n这种方式一般适用于多个页面或者全部页面都需要获取使用同一个数据，比如一开始进入首页就获取到的用户信息等；\r\n第三种：使用本地缓存\r\n使用小程序中的本地缓存Storage，旧页面将传递数据存入缓存中，新页面通过调用获取缓存的API得到数据。\r\n//pageA.js\r\n···\r\nwx.setStorageSync('sessionId', res.sessionId);\r\n\r\n\r\n//pageB.js\r\n···\r\nvar sessionId = wx.getStorageSync('sessionId');\r\n\r\n要注意的问题：\r\n\r\nStorage每次存入会覆盖掉原来该 key 对应的内容。\r\n如果用户主动删除小程序或因存储空间原因被系统清理，Storage中数据将被清除。\r\n单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。\r\n\r\n适用：\r\n这种方式一般适用于即使小程序退出然后再重新进入，也要保留的数据，类似于登录状态的保留等。"}
{"title": "微信小程序组件间通信", "author": "Rolan", "time": "2020-5-25 00:51", "content": "前言Anjular的路由出口真是方便的很,组件共用轻轻松松,但是小程序却没有这样的概念,至今也没有找到类似的功能的实现方法,项目中的左侧导航栏就是共用的,位置固定,页面变化只改变导航栏右侧界面,目前只得使用wx:if判断显示哪个界面,如果我们把导航栏组件引入别的界面,要想点击后调用方法,就要用到组件间通信,否则无论如何界面也不会发生改变.实现组件应用首先对导航栏组件进行封装:在leftNav组件json文件夹里添加代码:\"component\": true用以表明是自定义组件.然后在index.json里面声明引入该组件:{\r\n\"component\" : true,\r\n\"usingComponents\": {\r\n\"van-row\": \"@vant/weapp/row/index\",\r\n\"van-col\": \"@vant/weapp/col/index\",\r\n\"leftNav\":\"../leftNav/leftNav\",\r\n\"orderList\": \"../orderList/orderList\",\r\n\"listDetails\": \"../listDetails/listDetails\"\r\n      }\r\n}这样就可以在index.wxml里面应用该组件了:<van-col span=\"6\"\\>\r\n<leftNav>\r\n</leftNav>\r\n</van-col>组件通信要想实现对界面的控制,还要连通组件间的通信,在控制跳转的位置添加事件 orderList(leftNav.wxml):<van-sidebar-item class=\"menu\" bindtap=\"orderList\" title=\"订单列表\" \\>具体方法如下(leftNav.ts):orderList(){\r\nthis.triggerEvent('leftNavEvent', {menu: \"orderList\"})\r\n}triggerEvent 应用于自定义组件触发事件,表示向leftNavEvent 节点对象传入: {menu: \"orderList\"}通过自定义事件的方式通知父组件,那么信息的发送就实现了,接下来就是要让父组件接收信息(index.wxml):<van-col span=\"6\">\r\n<leftNav bind:leftNavEvent=\"onGetMenu\">\r\n</leftNav>\r\n</van-col>首先要连接到leftNavEvent,当监听到子组件触发事件时,调用方法onGetMenu(index.ts):Page({\r\ndata: {\r\nmenu: \"\"\r\n},\r\nonGetMenu(e: any) {\r\nconst menuValue = e.detail.menu\r\nthis.setData({ menu: menuValue })\r\n}\r\n});打印一下参数e的值:{type: \"leftNavEvent\", timeStamp: 8233, target: {…}, currentTarget: {…}, mark: {…}, …}\r\nchangedTouches: undefined\r\ncurrentTarget: {id: \"\", dataset: {…}}\r\ndetail: {menu: \"orderList\"}\r\nmark: {}\r\nmut: false\r\ntarget: {id: \"\", dataset: {…}}\r\ntimeStamp: 8233\r\ntouches: undefined\r\ntype: \"leftNavEvent\"\r\n_requireActive: undefined\r\n__proto__: Object我们发现之前传出的值{menu: \"orderList\"} 在detail属性里,这样就获取到传出的值了,然后用传过来的值对menu进行赋值,通过判断menu在V层的值控制界面的显示:<view>\r\n<van-row>\r\n<van-col span=\"6\">\r\n<leftNav bind:leftNavEvent=\"onGetMenu\">\r\n</leftNav>\r\n</van-col>\r\n<van-col span=\"18\">\r\n<block wx:if = \"{{menu == 'orderList'}}\">\r\n<orderList bind:orderListEvent=\"onGetMenu\"></orderList>\r\n</block>\r\n<block wx:elif=\"{{menu == 'listDetails'}}\">\r\n<listDetails></listDetails>\r\n</block>\r\n</van-col>\r\n</van-row>\r\n</view>这样一来就达到了组件共用的类似Anjular路由出口的效果:缺点就是在点击返回时总是返回初始界面,而非上一级界面,后期会改进的.具体的过程缩略如下:总结感觉微信小程序的一些功能挺繁琐的,官方给的代码也不是很完美,好在官方给的有示例,一些用法还不是很熟悉,有时候用到一些方法都不知道是官方给的,看官方文档还是很有必要的.本文作者：河北工业大学梦云智开发团队 张文达"}
{"title": "微信小程序图片保存到本地一次问题解决", "author": "Rolan", "time": "2020-5-25 00:33", "content": "最近接到一个小程序保存二维码到本地的需求，以保证用户分享进行推广。看看似简单的一个小需求，其实还是挺麻烦的，为大家分享下（这里项目使用了 Taro 小程序是一样的）。步骤查看 文档 发现是现成的，很简单。代码如下// 图片下载\r\nasync downloadImage() {\r\n  try {\r\n    /**\r\n    * @param {String} src  网络图片地址\r\n    */\r\n    const { path } = Taro.getImageInfo({ src })\r\n\r\n    // 保存到相册\r\n    const saveRet = await Taro.saveImageToPhotosAlbum({ filePath: path })\r\n\r\n    if(saveRet.errMsg == 'saveImageToPhotosAlbum:ok') {\r\n      Taro.showToast({\r\n        title: '图片保存成功'\r\n      })\r\n    }\r\n    \r\n  } catch (error) {\r\n    console.log(error)\r\n  }\r\n}\r\n复制代码感觉好像是完事了，但其实还早，这才刚刚开始，刺激的在后面。授权调用相册是需要用户授权的，用户授权了还好，要是没有授权（用户选择了拒绝），就不能再进行图片下载，且没有什么提示，用户体验极差，怎么办呢。最好的办法还是对用户进行引导。如果用户选择了拒绝，当用户再次打开此页面的时候，那么我们将下载的按钮进行替换成授权相册。引导用户手动打开相册权限进行图片的下载。贴上代码供各位看官参考async openSetting() {\r\n  // 打开设置（手动授权）\r\n  const ret = await Taro.openSetting()\r\n  if(ret.authSetting['scope.writePhotosAlbum']) {\r\n    this.setState({\r\n      writePhotosAlbum: true // 权限开启状态\r\n    })\r\n  }\r\n}\r\n复制代码兼容性本以为这样就结束了，奈何QA同学又过来找，在个别安卓手机上下载不了，表现为点击 保存 没有任何反应（文件类型识别失败）。发现其实是 getImageInfo 这个方法获取不到图片信息报错导致的，惊慌失措中寻找是否有替代方案。 downloadFile 是用来保存文件到本地的缓存中，存储临时地址。想到图片其实也是属于文件，尝试是否可以借助这个方法实现。// 获取临时文件路径\r\n  const filePath = `${wx.env.USER_DATA_PATH}/${Date.now()}.jpg`\r\n  // 通过获取本地临时文件路径进行图片的保存，此文件路径是我们自己指定了文件类型，所以不会出现文件类型识别失败的情况。\r\n  const { path } = await Taro.downloadFile({\r\n    url,\r\n    filePath // 强行指定文件类型（.jpg）\r\n  })\r\n  // 图片保存\r\n  const saveRet = await Taro.saveImageToPhotosAlbum({\r\n    filePath: path\r\n  })\r\n\r\n  if(saveRet.errMsg == 'saveImageToPhotosAlbum:ok') {\r\n    Taro.showToast({\r\n      title: '图片保存成功'\r\n    })\r\n\r\n    // 保存成功之后移除缓存释放机身空间\r\n    let fileMgr = Taro.getFileSystemManager()\r\n\r\n    fileMgr.unlink({ filePath })\r\n  }\r\n复制代码这样实现之后是可以的，正好避过了 getImageInfo 获取图片类型（.png|.jpg）不成功的情况，如果各位小伙伴也遇到类似的场景，可以尝试将保存的代码修改成上面这种，能避免一些不必要的问题，如果有更好的办法，也请告知，欢迎一起学习讨论。祝工作顺利！"}
{"title": "小程序-云开发-如何对敏感词进行过滤即内容安全的检测(上)", "author": "Rolan", "time": "2020-5-25 00:26", "content": "前言内容安全检测，是每一个小程序主都面临的“头疼”问题，轻则短暂性不可访问，重则永久封号，甚至关小黑屋。本文将为您详细说明，如何在小程序中对一段文本进行合法内容检测，以判断是否含有违法违规内容。本文重点为你讲述：内容安全检测常见应用场景及解决办法学会使用小程序· 云开发的云函数+结合request-promise第三方库实现内容请求校验掌握如何在小程序端请求云函数（有别于传统的wx.request的方式(类似AJax)）在云开发的云函数端, 利用第三方https请求库(request,request-promise),获取Access_token,以及向微信官方提供的内容检测接口发请求进行校验云函数端与小程序端错误码的处理背景无论是小程序还是自行开发的一些类似社交,带有用户自行产生内容的软件应用,例如:即时通讯,社群,论坛,音视频直播等,对于接入内容安全的检测是非常有必要的。对于小程序而言,这一点在审核上是非常严格的,净化言行,做一个知法守法的人很重要...接入内容安全检测,规避输入一些违法违规低俗等内容,避免辛辛苦苦开发出来的应用。被恶意上传反动言论或上传一些违规内容(文字/图片/视频等),导致小程序或应用被下架,或遭永久禁封,或个人及公司被公安机关打电话,约喝茶等,这样的话,就得不偿失了的。应用场景检测小程序用户个人文字资料是否违规针对特点词汇（如过于商业以及营销之类的词）可以进行过滤或禁止输入在内容发布之前自动检测用户发表的信息（包括评论、留言等）是否违规解决办法围绕如何处理内容安全检测问题，一般有3种方法：方案1:引入第三方接口对内容进行校验(例如:百度AI内容审核平台,网易云盾等) 方案2: 公司后台小伙伴自行开发文本,图片,音视频等内容审核接口 方案3: 小程序服务端提供的API进行校验每一种方法各有优劣势，具体如下图。解决方案优势劣势1. 引入第三方接口对内容进行校验前端同学只需按照官方提供的第三方接口文档,进行校验即可,无需后台介入,功能强大,覆盖范围广接口调用的频次有限制,收费2. 公司后台小伙伴自行开发文本,图片,音视频等内容审核接口后台小伙伴自己造轮子,根据自己的业务需求以及用户属性,自定义内容审核机制开发周期长,成本大,难以覆盖全面3. 调用小程序服务端提供的内容安全API进行校验简单,高效想不出来,因为相比前两种方案,对于不依赖后端接口的开发者来说,简直是雪中送炭在微信小程序生态下，官方提供了2种路径帮助用户解决内容检测问题，即使用服务器开发模式，通过HTTPS调用使用小程序·云开发，通过云函数或云调用来实现。服务器开发模式，相信大家都相对比较熟悉，在此就不再赘述。接下来为大家重点介绍，如何通过小程序·云开发的云函数实现内容安全检测通过云开发的云函数+request-promise第三方库实现内容请求校验Step 1: 在小程序端先布局：完成静态页面。(pages文件夹下的文件都是属于小程序前端代码,每个文件夹目录代表的就是一个模块,一个页面) 小程序前端wxml代码示例<view class=\"container\">\r\n  <textarea class=\"content\" placeholder=\"写点文字...\" bindinput=\"onInput\" auto-focus bindfocus=\"onFocus\" bindblur=\"onBlur\">\r\n  </textarea>\r\n</view>\r\n\r\n<view class=\"footer\">\r\n  <button class=\"send-btn\" size=\"default\" bind:tap=\"send\">发布</button>\r\n</view>\r\n复制代码小程序前端wxss代码示例/* pages/msgSecCheck/msgSecCheck.wxss */\r\n.container {\r\n  padding: 20rpx;\r\n}\r\n\r\n.content {\r\n  width: 100%;\r\n  height: 360rpx;\r\n  box-sizing: border-box;\r\n  font-size: 32rpx;\r\n  border: 1px solid #ccc;\r\n}\r\n\r\n.footer {\r\n  width: 100%;\r\n  height: 80rpx;\r\n  line-height: 80rpx;\r\n  position: fixed;\r\n  bottom: 0;\r\n  box-sizing: border-box;\r\n  background: #34bfa3;\r\n}\r\n\r\n.send-btn {\r\n  width: 100% !important;\r\n  color: #fff;\r\n  font-size: 32rpx;\r\n}\r\n\r\nbutton {\r\n  width: 100%;\r\n  background: #34bfa3;\r\n  border-radius: 0rpx;\r\n}\r\n\r\nbutton::after {\r\n  border-radius: 0rpx !important;\r\n}\r\n复制代码经过wxml与wxss的编写后,UI最终长成这样Step 2: 完成小程序端业务逻辑的处理小程序端逻辑JS代码示例// pages/msgSecCheck/msgSecCheck.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    textareaVal: ''   // 页面中需要显示的数据,初始化定义在data下面\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n\r\n  },\r\n  // 监听表单时,数据有变化时\r\n  onInput(event) {\r\n    let textVal = event.detail.value;\r\n    this.setData({\r\n      textareaVal: textVal\r\n    })\r\n    \r\n  },\r\n\r\n  // 聚焦焦点时\r\n  onFocus() {\r\n    console.log('聚焦焦点时');\r\n  },\r\n\r\n  // 失去焦点时\r\n  onBlur(event) {\r\n    console.log(\"失去焦点时\");\r\n    // 前端可进行手动的弱校验,也可以在失去焦点时发送请求进行文本的校验,但是每次失去焦点就请求一次,这样是消耗云资源的,其实在发布时候与失去焦点做校验两者都可以\r\n\r\n\r\n  },\r\n\r\n  // 发布\r\n  send() {\r\n    console.log(\"触发发布按钮\")\r\n    wx.cloud.callFunction({ // 请求msgSecCheck1云函数\r\n      name: 'msgSecCheck1',\r\n      data: {\r\n        content: this.data.textareaVal // 需要向云函数msgSecCheck1传入的值\r\n      }\r\n\r\n    }).then(res => { // 成功时的响应返回结果\r\n      console.log(res);\r\n    }).catch(err => { // 失败时,返回的结果\r\n      console.error(err);\r\n    })\r\n    \r\n  }\r\n\r\n})\r\n复制代码Step 3 ：服务端逻辑处理。在小程序云函数端创建云函数 msgSecCheck1 ,这个名字你可以自定义,与小程序前端请求的名字保持一致就可以了的选中云函数,右键并打开命令行终端安装request,request-promise，因为request-promise依赖于request,两个都要安装,最后一键上传部署就可以了的npm install request\r\nnpm install request-promise\r\n复制代码如果遇到在小程序端请求云函数时,遇到类似下面的错误,找不到什么xxx模块之类的 先看错误码,然后在官方文档中找到该错误码代表的含义一看错误,没有找到模块,在云函数的目录下的package.json中查看是否有安装错误中提示的包的,要是没有的话,就安装一下就可以了的,同时记得每次更改后都要上传部署一下,也可以选择云函数中文件的增量上传 接下来是将是本文的重点内容！Step 4 :通过云函数+request-promise实现内容安全检测对于小程序开发,其实与web端开发也是类似,给元素绑定事件,然后获取元素,只是小程序端没有DOM,BOM的那一套东西,它是数据驱动视图的,吸收了Angular,Vue,React的各个框架的优点,形成了自己的一套规范。如果有这方面开发经验的小伙伴来说,平缓过度到小程序开发当中来,你会发现总会有惊人的相似,用的语言都是JavaScript,但是与web开发还是多少有很多差异的,这里就不拓展了。废话不多说,直接上代码小程序前端逻辑代码// 点击发送按钮,对输入的文本内容进行校验\r\n send() {\r\n    wx.cloud.callFunction({\r\n      name: 'msgSecCheck1', // 云函数的名称\r\n      data: { // 需要向云函数传递过去的数据\r\n        content: this.data.textareaVal // 具体要检测的内容\r\n      }\r\n    }).then(res => { // 成功时,做什么事情\r\n      console.log(res);\r\n      // 检测到文本成功时,做一些业务\r\n\r\n    }).catch(err => { // 失败时,做什么事情\r\n      // 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作\r\n\r\n      console.error(err);\r\n    })\r\n  }\r\n复制代码上面的代码还可以在优化一下,就是将请求云函数的代码封装成一个函数。如下所示,不封装也是没事的,只是我习惯性封装一下,如果其他地方也用到该云函数,那么直接调用，避免写重复的代码。下面是将请求云函数的部分核心代码：// 发布\r\n  send() {\r\n    // 请求msgSecCheck1云函数,对文本内容进行校验\r\n    this._requestCloudMsgCheck();\r\n  },\r\n\r\n  _requestCloudMsgCheck() {\r\n    let textareaVal = this.data.textareaVal;\r\n    wx.cloud.callFunction({\r\n      name: 'msgSecCheck1',\r\n      data: {\r\n        content: textareaVal // 这里可以使用官方文档测试用例,特3456书yuuo莞6543李zxcz蒜7782法fgnv级\r\n      }\r\n    }).then(res => {\r\n      console.log(res);\r\n      // 检测到文本成功时,做一些业务\r\n    }).catch(err => {\r\n      // 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作\r\n      console.error(err);\r\n    })\r\n  }\r\n复制代码至于是在失去焦点事件时发送请求还是在点击发送按钮时发送请求,两种方式都可以。 您也可以自定义文本校验,而我个人觉得在小程序端,失去焦点时,可以自定义做一些常规敏感词的弱校验,而在点击发送按钮时,做强校验。如果是放在失去焦点时就立马请求,这样请求次数会增多,而放在点击发送按钮时进行校验,一定程度上可以减少小程序端频繁请求。接下来就是处理云函数端,使用request-promise请求请求微信内容安全接口的示例代码。/*\r\n *  Description: 利用第三方库request-promise请求微信内容安全接口\r\n *\r\n * 相关文档链接:\r\n * 微信文本内容安全接口文档https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/sec-check/security.msgSecCheck.html\r\n * access_token获取调用凭证文档\r\nhttps://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\r\n *\r\n * request-promise使用文档: https://github.com/request/request-promise\r\n *\r\n */\r\n\r\nconst APPID = \"wx21baa58c6180c2eb\"; // 注意是你自己小程序的appid\r\nconst APPSECRET = \"\"; // 你自己小程序的appsecret\r\n// 安全校验接口\r\nconst msgCheckURL = `https://api.weixin.qq.com/wxa/msg_sec_check?access_token=`;\r\n// 向下面的这个地止发送请求,携带appid和appsecret参数,获取token认证\r\nconst tokenURL = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${APPID}&secret=${APPSECRET}`\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 引入request-promise\r\nconst rp = require('request-promise');\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  try {\r\n    let tokenResponse = await rp(tokenURL);\r\n    // 获取token值,因为返回的结果是字符串,需要用JSON.parse转化为json对象\r\n    let getAccessToken = JSON.parse(tokenResponse).access_token;\r\n    // 请求微信内容安全接口,post请求,返回最终的校验结果\r\n    let checkResponse = await rp({\r\n      method: 'POST',\r\n      url: `${msgCheckURL}${getAccessToken}`,\r\n      body: {\r\n        content: event.content // 这里的event.content是小程序端传过来的值,content是要向内容接口校验的内容\r\n      },\r\n      json: true\r\n    })\r\n    return checkResponse;\r\n  } catch (err) {\r\n      console.error(err);\r\n  }\r\n}\r\n复制代码当你在小程序端输入文本,发送请求时,查看控制台下的结果时,功能是没有问题的。特3456书yuuo莞6543李zxcz蒜7782法fgnv级\r\n完2347全dfji试3726测asad感3847知qwez到\r\n\r\n复制代码您可以根据官方文档中提供的测试用例,进行测试,看具体的返回结果的。云函数请求成功,看看错误信息的反馈,对于熟悉该错误码的人清楚该文本违规了,但是反馈不是很明显,即使当下自己很清楚,然而,在过几个月在回来看代码,你或许都不知道是啥意思。 Step 5 ：错误码的正确处理方式对于处理错误码,返回具体的合适信息,对于调试代码,排查问题,也是非常重要 。 这些错误码具体的含义,在官方文档里都有对应的解释,不用去记,去查文档就行。在面试中,有很多面试官喜欢问http相关状态码的问题,状态码有很多,也真的记不住,但是常见的错误http状态码还是要知道的,我觉得,具体知道怎么处理,怎么查文档就可以了。真正考验背后目的是,对于根据后端返回的状态码,判断接口哪里出了问题,定位是前端问题还是后端问题,这是一个非常常见的问题。如果你说你不知道,没有处理过,对于候选人,那肯定是没有信服力的,无论是成功状态还是失败状态,都是应该有对应的用户提示。完整文本安全校验示例代码如下是完整的云函数端代码/*\r\n *\r\n * 相关文档链接:\r\n * 微信文本内容安全接口文档https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/sec-check/security.msgSecCheck.html\r\n * access_token获取调用凭证文档\r\nhttps://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\r\n *\r\n * request-promise使用文档: https://github.com/request/request-promise\r\n *\r\n */\r\n\r\nconst APPID = \"wx21baa58c6180c2eb\";\r\nconst APPSECRET = \"\";\r\n\r\nconst msgCheckURL = `https://api.weixin.qq.com/wxa/msg_sec_check?access_token=`;\r\n// 向下面的这个地止发送请求,携带appid和appsecret参数,获取token认证\r\nconst tokenURL = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${APPID}&secret=${APPSECRET}`\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 引入request-promise\r\nconst rp = require('request-promise');\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  try {\r\n    let tokenResponse = await rp(tokenURL);\r\n    // 获取token值,因为返回的结果是字符串,需要用JSON.parse转化为json对象\r\n    let getAccessToken = JSON.parse(tokenResponse).access_token;\r\n    // 请求微信内容安全接口,post请求,返回最终的校验结果\r\n    let checkResponse = await rp({\r\n      method: 'POST',\r\n      url: `${msgCheckURL}${getAccessToken}`,\r\n      body: {\r\n        content: event.content // 这里的event.content是小程序端传过来的值,content是要向内容接口校验的内容\r\n      },\r\n      json: true\r\n    })\r\n\r\n    // 有必要根据错误码,确定内容是否违规\r\n    if (checkResponse.errcode == 87014) {\r\n      return {\r\n        code: 500,\r\n        msg: \"内容含有违法违规内容\",\r\n        data: checkResponse\r\n      }\r\n    } else {\r\n      return {\r\n        code: 200,\r\n        msg: \"内容OK\",\r\n        data: checkResponse\r\n      }\r\n    }\r\n  } catch (err) {\r\n    if (err.errcode == 87014) {\r\n      return {\r\n        code: 500,\r\n        msg: '内容含有违法违规内容',\r\n        data: err\r\n      }\r\n    } else {\r\n      return {\r\n        code: 502,\r\n        msg: '调用msgCheckURL接口异常',\r\n        data: err\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n复制代码在云函数端,经过添加错误码的判断之后,在来看看小程序端发送的请求,返回的结果至此,我们在小程序端可以根据这个返回的错误码或成功码,进行一些业务逻辑处理的,比如给一些用户提示,在数据插入数据库之前就做一些判断操作,只有内容合规时,才插入数据库,进入下一步的业务逻辑处理。_requestCloudMsgCheck() {\r\n    let textareaVal = this.data.textareaVal;\r\n    wx.cloud.callFunction({\r\n      name: 'msgSecCheck1',\r\n      data: {\r\n        content: textareaVal\r\n      }\r\n    }).then(res => {\r\n      console.log(res);\r\n      const errcode = res.result.data.errcode;\r\n      // 检测到文本错误时,做一些业务\r\n      if (87014 === errcode) {\r\n         wx.showToast({ // 当内容违规时,做一些用户提示\r\n           title: '您输入的文本内容含有敏感内容,请重新输入',\r\n         })\r\n      }else {\r\n         // 成功时做其他业务操作\r\n      }\r\n    }).catch(err => {\r\n      // 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作\r\n      console.error(err);\r\n    })\r\n  }\r\n\r\n\r\n复制代码当输入的文本有敏感词汇时,做相对应的用户提示的注意在云函数(后)端处理错误码与小程序端都是要进行处理的,两者不要混淆了的,小程序端最终的一些业务逻辑判断,是根据后端接口返回的状态,最终决定要做什么操作的。 至此,通过request-promise库就完成了文本内容校验的问题。这个request,request-promise库非常实用,功能也非常强大,类似这种库,常见什么got,axios等之类的,都是支持promise风格的 处理方式大同小异,大家可以去npm或github上阅读相关使用文档的结语在小程序中有多种解决方案,推荐使用小程序端请求云开发云函数的方式,无论是不使用云函数方式,自己有后端服务,获取 access_token 都应该是从后端返回给前端的。而小程序的秘钥 AppSecret是不应该放在小程序端的,那样不安全的,无论是服务器开发模式还是小程序·云开发模式,都绕不过后台请求微信提供的内容安全接口,然后在返回给小程序端其实在小程序·云开发中,还提供了一种更简便的方法,那就是云调用,它是小程序·云开发提供的在云函数中调用微信开放接口的能力,只需简单的进行配置一下就可以了。限于篇幅所致,放在下一节介绍。更多内容,您可关注微信itclanCoder公众号,一个只传递和分享给你带来启发智慧有用的号"}
{"title": "Taro UI开发小程序实现 左滑喜欢 右滑不喜欢效果", "author": "Rolan", "time": "2020-5-18 00:47", "content": "摘要：      年后入职了一家新公司，与前同事交接完之后，发现公司有一个四端的项目（iOS，Android，H5，小程序），iOS和安卓都实现了左滑右滑的效果，而h5和小程序端没实现，询问得知前同事因网上没找到对应的插件，相关博客也特别少，所以没做就搁置下来了。      趁这段时间相对来说比较富裕，于是乎在网上也搜索了一下，发现确实很少，但是有人提到可以用小程序可拖动组件movable-view来实现，自己尝试来一下发现可行，于是来写这篇博客记录一下，希望能帮助到后面需要用到这个功能的人！ 先上效果图： 主要技术：Taro+Taro UI+React（如果你是小程序原生或者uniapp+vue写法都差不多，可以通用）可拖动组件文档地址：Taro: https://taro-docs.jd.com/taro/docs/components/viewContainer/movable-view.html微信小程序：https://developers.weixin.qq.com/miniprogram/dev/component/movable-view.html 思路：一，我们首先把movable-area和movable-view标签写出来；<movable-area>\r\n    <movable-view>\r\n       ......\r\n    </movable-view>\r\n</movable-area>二，我们可以看到文档里面有一个onChange方法，即拖动过程中触发的事件；<movable-area>\r\n    <movable-view onChange ={this. onChange.bind(this)}>\r\n       ......\r\n    </movable-view>\r\n</movable-area>\r\n\r\n// 触发方法，打印参数\r\nonChange(e) {\r\n   console.log('参数',e);\r\n}我们可以看到打印出了，拖动的位置和产生移动的原因等；三，我们接着加入开始onTouchstart，移动onTouchmove，结束onTouchcancel，onTouchend三个事件方法；<MovableView  \r\n  key={item.id} \r\n  onTouchcancel={this.onCancel} \r\n  onTouchend={this.onCancel} \r\n  onTouchstart={this.onTouchStart} \r\n  onTouchmove={this.onTouchMove} \r\n  x={this.state.x}  // 横坐标位置\r\n  y={this.state.y}  // 纵坐标位置\r\n  direction='all'  // 移动方向都可以\r\n  outOfBounds  // 可超过可移动区域\r\n  className='shop-imgbox' \r\n> \r\n<--中间加入图片之类的滑动内容-->\r\n</MovableView> \r\n                    初始数据如下：state = { \r\n    x: '16', \r\n    y: '16', \r\n    like: false, \r\n    unlike: false, \r\n    shopList: [ \r\n      { \r\n        img: 'https://edgefix-image.edgecom.top/ABD846F6672997A7F76CD38E8A57F954.jpg', \r\n      }, \r\n      { \r\n        img: 'https://edgefix-image.edgecom.top/F6E5801C304CC76DA63C02C9FB38B8F4.jpg', \r\n      }, \r\n      { \r\n        img: 'https://edgefix-image.edgecom.top/D518952AD1DD61B2D32556E20CC527C4.jpg', \r\n      }, \r\n      { \r\n        img: 'https://edgefix-image.edgecom.top/1D187E28B349679908A44BBE81F3D3CA.jpg', \r\n      }, \r\n      { \r\n        img: 'https://edgefix-image.edgecom.top/1129A411AC9CF5F81187CBED181B6F57.jpg', \r\n      } \r\n    ] \r\n  } 三个方法我们可以取到移动后改变的位置，来改变喜欢与不喜欢的状态css，以及实现卡片滑动的效果：1.触摸触发的时候，我们获取到刚刚开始触摸卡片的x，y的位置坐标；2.在触摸滑动时，我们通过滑动后的位置-滑动前的位置，来判断距离多少来改变喜欢和不喜欢的值；3.当手离开时，触发取消事件，我们需要把状态数据改为原始值，即回到最初的状态；// 触摸触发 \r\n  onTouchStart(e) { \r\n    console.log('222',e.touches[0].pageX); \r\n    this.setState({ \r\n      x: e.touches[0].pageX, \r\n      y: e.touches[0].pageY, \r\n    }); \r\n  } \r\n  // 触摸移动 \r\n  onTouchMove(e) { \r\n    console.log('333',e.touches[0].pageX); \r\n    let dx = e.touches[0].pageX - this.state.x; \r\n    if (dx > 50) { \r\n      this.setState({ \r\n        like: true, \r\n        unlike: false, \r\n      }); \r\n    } else if (dx < -50) { \r\n      this.setState({ \r\n        like: false, \r\n        unlike: true, \r\n      }); \r\n    } else { \r\n      this.setState({ \r\n        like: false, \r\n        unlike: false, \r\n      }); \r\n    } \r\n  } \r\n  // 取消 \r\n  onCancel(e) { \r\n    console.log('444',e.changedTouches[0].pageX); \r\n    this.setState({ \r\n      x: '16', \r\n      y: '16', \r\n      like: false, \r\n      unlike: false, \r\n    }); \r\n  } 当我们写到这里，我们去拖动我们的卡片时，你会发现确实可以拖动，并且取消的时候会回到原点，但是同样你也会发现一个问题，就是你拖动的时候，五张卡片都被触发来移动的效果，出现了触点混乱的问题，查找问题发现卡片共用了x，y，因此我们可以给每张卡片设置独立的参数；四，给每张卡片独立的参数并且设置卡片倾斜度效果；1.设置倾斜度效果style={{transform:'rotate('+this.state.tiltAngle[index]+'deg)'}}然后我们通过卡片移动位置计算出一个你决定合适的倾斜角度；// 拖动后相差距离进行换算角度\r\nlet dxangle = (e.touches[0].pageX - this.state.startX) * 45 / 500;2.设置独立的参数方法携带索引，我们取到对应的卡片index，来改变对应卡片的数据；<MovableView \r\n  key={item.id}\r\n  onTouchcancel={this.onCancel.bind(this,index)}\r\n  onTouchend={this.onCancel.bind(this,index)}\r\n  onTouchstart={this.onTouchStart.bind(this,index)}\r\n  onTouchmove={this.onTouchMove.bind(this,index)}\r\n  x={this.state.x[index]} \r\n  y={this.state.y[index]} \r\n  direction='all' \r\n  outOfBounds \r\n  className='shop-imgbox'\r\n>\r\n</MovableView>同时，我们需要改变初始参数的形式为数组，我们通过索引改变对应卡片的值；state = {\r\n    // 开始位置\r\n    startX: '',\r\n    // 开始位置-最终位置距离\r\n    placeX: '',\r\n    // 倾斜角度\r\n    tiltAngle: ['0','0','0','0','0'],\r\n    // 坐标\r\n    x: ['16','16','16','16','16'],\r\n    y: ['16','16','16','16','16'],\r\n    // 是否喜欢状态\r\n    like: [false,false,false,false,false],\r\n    unlike: [false,false,false,false,false],\r\n    // 推荐商品数组\r\n    shopList: [\r\n      {\r\n        id: 1,\r\n        img: 'https://edgefix-image.edgecom.top/ABD846F6672997A7F76CD38E8A57F954.jpg',\r\n      },\r\n      {\r\n        id: 2,\r\n        img: 'https://edgefix-image.edgecom.top/F6E5801C304CC76DA63C02C9FB38B8F4.jpg',\r\n      },\r\n      {\r\n        id: 3,\r\n        img: 'https://edgefix-image.edgecom.top/D518952AD1DD61B2D32556E20CC527C4.jpg',\r\n      },\r\n      {\r\n        id: 4,\r\n        img: 'https://edgefix-image.edgecom.top/1D187E28B349679908A44BBE81F3D3CA.jpg',\r\n      },\r\n      {\r\n        id: 5,\r\n        img: 'https://edgefix-image.edgecom.top/1129A411AC9CF5F81187CBED181B6F57.jpg',\r\n      }\r\n    ]\r\n  }方法我们就举一个例子，比如onTouchStart方法，我们遍历卡片数组，通过判断索引来得到是那张卡片，从而来改变对应值// 触摸触发\r\n  onTouchStart(index,e) {\r\n    console.log('1111',index,e.touches[0].pageX,e.touches[0].pageY);\r\n    // 重定义数组\r\n    var againX = [];\r\n    var againY = [];\r\n    // 遍历，判断拖动的该数组的位置\r\n    for (var i=0; i<this.state.shopList.length; i++){\r\n      if (i == index) {\r\n        againX[i] = e.touches[0].pageX;\r\n        againY[i] = e.touches[0].pageY;\r\n      } else {\r\n        againX[i] = '16';\r\n        againY[i] = '16';\r\n      }\r\n    }\r\n    // 赋值\r\n    this.setState({\r\n      startX: e.touches[0].pageX,\r\n      x: againX,\r\n      y: againY,\r\n    });\r\n  }这样，我们运行代码，发现拖动第一张卡片不会影响到后面卡片的位置了，同时，我们现在拖动卡片删除的是数组，在实际项目中，我们在触发删除数组的地方接入接口，调用喜欢，不喜欢改变数据参数，从而也能改变数组的长度；五，完整代码；下面我将贴出完整的代码供大家参考html文件：import Taro, { Component } from '@tarojs/taro';\r\nimport { View, Image, Button, Text, MovableArea, MovableView } from '@tarojs/components';\r\nimport { observer, inject } from '@tarojs/mobx';\r\nimport { AtButton, AtFloatLayout  } from 'taro-ui';\r\nimport userStore from '../../store/user.store';\r\n\r\nimport './stroll.scss';\r\n\r\n@inject('userStore')\r\n@observer\r\nclass Stroll extends Component {\r\n  config = {\r\n    navigationBarTitleText: '逛',\r\n  }\r\n\r\n  state = {\r\n    // 开始位置\r\n    startX: '',\r\n    // 开始位置-最终位置距离\r\n    placeX: '',\r\n    // 倾斜角度\r\n    tiltAngle: ['0','0','0','0','0'],\r\n    // 坐标\r\n    x: ['16','16','16','16','16'],\r\n    y: ['16','16','16','16','16'],\r\n    // 是否喜欢状态\r\n    like: [false,false,false,false,false],\r\n    unlike: [false,false,false,false,false],\r\n    // 推荐商品数组\r\n    shopList: [\r\n      {\r\n        id: 1,\r\n        img: 'https://edgefix-image.edgecom.top/ABD846F6672997A7F76CD38E8A57F954.jpg',\r\n      },\r\n      {\r\n        id: 2,\r\n        img: 'https://edgefix-image.edgecom.top/F6E5801C304CC76DA63C02C9FB38B8F4.jpg',\r\n      },\r\n      {\r\n        id: 3,\r\n        img: 'https://edgefix-image.edgecom.top/D518952AD1DD61B2D32556E20CC527C4.jpg',\r\n      },\r\n      {\r\n        id: 4,\r\n        img: 'https://edgefix-image.edgecom.top/1D187E28B349679908A44BBE81F3D3CA.jpg',\r\n      },\r\n      {\r\n        id: 5,\r\n        img: 'https://edgefix-image.edgecom.top/1129A411AC9CF5F81187CBED181B6F57.jpg',\r\n      }\r\n    ]\r\n  }\r\n\r\n  componentWillMount () { }\r\n\r\n  componentWillReact () { }\r\n\r\n  componentDidMount () {\r\n  }\r\n\r\n  // 触摸触发\r\n  onTouchStart(index,e) {\r\n    console.log('1111',index,e.touches[0].pageX,e.touches[0].pageY);\r\n    // 重定义数组\r\n    var againX = [];\r\n    var againY = [];\r\n    // 遍历，判断拖动的该数组的位置\r\n    for (var i=0; i<this.state.shopList.length; i++){\r\n      if (i == index) {\r\n        againX[i] = e.touches[0].pageX;\r\n        againY[i] = e.touches[0].pageY;\r\n      } else {\r\n        againX[i] = '16';\r\n        againY[i] = '16';\r\n      }\r\n    }\r\n    // 赋值\r\n    this.setState({\r\n      startX: e.touches[0].pageX,\r\n      x: againX,\r\n      y: againY,\r\n    });\r\n  }\r\n  // 触摸离开\r\n  onTouchMove(index,e) {\r\n    console.log('2222',index,e.touches[0].pageX,e.touches[0].pageY);\r\n    // 重定义数组\r\n    var tiltAngleT = [];\r\n    var againX = [];\r\n    var againY = [];\r\n    // 拖动后相差距离\r\n    let dxplace = e.touches[0].pageX - this.state.startX;\r\n    // 拖动后相差距离进行换算角度\r\n    let dxangle = (e.touches[0].pageX - this.state.startX) * 45 / 500;\r\n    console.log(dxangle);\r\n    // 遍历，判断拖动的该数组的位置\r\n    for (var i=0; i<this.state.shopList.length; i++){\r\n      if (i == index && dxplace > 50) {\r\n        tiltAngleT[i] = dxangle,\r\n        againX[i] = true;\r\n        againY[i] = false;\r\n      } else if (i == index && dxplace <= -50) {\r\n        tiltAngleT[i] = dxangle,\r\n        againX[i] = false;\r\n        againY[i] = true;\r\n      } else if (i == index && dxplace < 50 && dxplace > -50) {\r\n        tiltAngleT[i] = dxangle,\r\n        againX[i] = false;\r\n        againY[i] = false;\r\n      } else {\r\n        tiltAngleT[i] = '0',\r\n        againX[i] = false;\r\n        againY[i] = false;\r\n      }\r\n    }\r\n    // 赋值\r\n    this.setState({\r\n      placeX: dxplace,\r\n      tiltAngle: tiltAngleT,\r\n      like: againX,\r\n      unlike: againY,\r\n    });\r\n  }\r\n  // 取消\r\n  onCancel(index,e) {\r\n    console.log('3333',index,e.changedTouches[0].pageX,e.changedTouches[0].pageY);\r\n    // 赋值\r\n    this.setState({\r\n      tiltAngle: ['0','0','0','0','0'],\r\n      x: ['16','16','16','16','16'],\r\n      y: ['16','16','16','16','16'],\r\n      like: [false,false,false,false,false],\r\n      unlike: [false,false,false,false,false],\r\n    });\r\n    // 如果偏移已经达到则清除第一张图片\r\n    if (this.state.placeX > 50 || this.state.placeX < -50) {\r\n      this.setState({\r\n        shopList: this.state.shopList.splice(1,4),\r\n      });\r\n    }\r\n  }\r\n  // 不喜欢按钮点击\r\n  dislikebtn() {\r\n    // 改变按钮的状态以及图片位置及显示\r\n    this.setState({\r\n      tiltAngle: ['-18','0','0','0','0'],\r\n      x: ['-30','16','16','16','16'],\r\n      y: ['267','16','16','16','16'],\r\n      unlike: [true,false,false,false,false],\r\n    }, () => {\r\n      setTimeout( () => {\r\n        this.setState({\r\n          tiltAngle: ['0','0','0','0','0'],\r\n          x: ['16','16','16','16','16'],\r\n          y: ['16','16','16','16','16'],\r\n          unlike: [false,false,false,false,false],\r\n          shopList: this.state.shopList.splice(1,4),\r\n        });\r\n      },100);\r\n    });\r\n  }\r\n  // 喜欢按钮点击\r\n  likebtn() {\r\n    // 改变按钮的状态以及图片位置及显示\r\n    this.setState({\r\n      tiltAngle: ['18','0','0','0','0'],\r\n      x: ['284','16','16','16','16'],\r\n      y: ['267','16','16','16','16'],\r\n      like: [true,false,false,false,false],\r\n    }, () => {\r\n      setTimeout( () => {\r\n        this.setState({\r\n          tiltAngle: ['0','0','0','0','0'],\r\n          x: ['16','16','16','16','16'],\r\n          y: ['16','16','16','16','16'],\r\n          like: [false,false,false,false,false],\r\n          shopList: this.state.shopList.splice(1,4),\r\n        });\r\n      },100);\r\n    });\r\n  }\r\n\r\n  componentWillUnmount () { }\r\n\r\n  componentDidShow () {\r\n  }\r\n\r\n  componentDidHide () { }\r\n\r\n  render() {\r\n    return (\r\n      <View className='stroll-tab'>\r\n        <View className='stroll-text'>\r\n          <Text className='text-tip1'>搭配师每天为你推荐5件单品</Text>\r\n          <View className='text-tip2'>\r\n            <Text className='t1'>右滑喜欢</Text>\r\n            <Image src={require('./img/ic_like.png')} className='icon-image'></Image>\r\n            <Text className='t1'>，左滑不喜欢</Text>\r\n            <Image src={require('./img/ic_dislike.png')} className='icon-image'></Image>\r\n          </View>\r\n        </View>\r\n        {\r\n          this.state.shopList.length != 0&&\r\n          <MovableArea className='stroll-shop'>\r\n            {\r\n            this.state.shopList&&this.state.shopList.map((item,index) => {\r\n              return(\r\n                <MovableView \r\n                  key={item.id}\r\n                  onTouchcancel={this.onCancel.bind(this,index)}\r\n                  onTouchend={this.onCancel.bind(this,index)}\r\n                  onTouchstart={this.onTouchStart.bind(this,index)}\r\n                  onTouchmove={this.onTouchMove.bind(this,index)}\r\n                  x={this.state.x[index]} \r\n                  y={this.state.y[index]} \r\n                  direction='all' \r\n                  outOfBounds \r\n                  className='shop-imgbox'\r\n                >\r\n                  <View className='images-box' style={{transform:'rotate('+this.state.tiltAngle[index]+'deg)'}}>\r\n                    <Image src={item.img} className='images'></Image>\r\n                    {\r\n                      this.state.like[index]==true&&\r\n                      <Image src={require('./img/text_like.png')} className='imagelike'></Image>\r\n                    }\r\n                    {\r\n                      this.state.unlike[index]==true&&\r\n                      <Image src={require('./img/text_dislike.png')} className='imageunlike'></Image>\r\n                    }\r\n                  </View>\r\n                </MovableView>\r\n            );})\r\n            }\r\n          </MovableArea>\r\n        }\r\n        {\r\n          this.state.shopList.length === 0&&\r\n          <View className='noshop-card'>\r\n            <Image src={require('./img/noshop.png')} className='noshop-image'></Image>\r\n          </View>\r\n        }\r\n        <View className='stroll-fotter'>\r\n          {\r\n            this.state.shopList.length != 0&&\r\n            <View className='fot-twoimg'>\r\n              {\r\n                this.state.unlike[0]==false&&\r\n                <Image src={require('./img/dislike_default.png')} className='dislike-image' onClick={this.dislikebtn.bind(this)}></Image>\r\n              }\r\n              {\r\n                this.state.unlike[0]==true&&\r\n                <Image src={require('./img/dislike_click.png')} className='dislike-image'></Image>\r\n              }\r\n              {\r\n                this.state.like[0]==false&&\r\n                <Image src={require('./img/like_default.png')} className='like-image' onClick={this.likebtn.bind(this)}></Image>\r\n              }\r\n              {\r\n                this.state.like[0]==true&&\r\n                <Image src={require('./img/like_click.png')} className='like-image'></Image>\r\n              }\r\n            </View>\r\n          }\r\n          <Text className='fot-text'>查看我喜欢的</Text>\r\n        </View>\r\n      </View>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Stroll;css文件：page {\r\n  height: 100%;\r\n  background: #F6F6F6;\r\n}\r\n\r\n.stroll-tab {\r\n  width: 100%;\r\n  min-height: 100vh;\r\n  background: #F6F6F6;\r\n  .stroll-text {\r\n    width: 100%;\r\n    margin-top: 40px;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    .text-tip1 {\r\n      font-size: 28px;\r\n      color: #333333;\r\n    }\r\n    .text-tip2 {\r\n      display: flex;\r\n      flex-direction: row;\r\n      align-items: center;\r\n      .t1 {\r\n        font-size: 28px;\r\n        color: #333333;\r\n      }\r\n      .icon-image {\r\n        width:20px;\r\n        height:20px;\r\n      }\r\n    }\r\n  }\r\n  .stroll-shop {\r\n    width: 100%;\r\n    height: 700px;\r\n    margin-top: 40px;\r\n    .shop-imgbox {\r\n      height: 600px;\r\n      border-radius: 24px;\r\n      .images-box {\r\n        width: 100%;\r\n        height: 520px;\r\n        border-radius: 24px;\r\n        box-shadow: 0px 2px 5px 0px rgba(0,0,0,0.1);\r\n        background-color: #fff;\r\n        position: relative;\r\n        .images {\r\n          width: 606px;\r\n          height: 480px;\r\n          position: absolute;\r\n          left: 40px;\r\n          top: 20px;\r\n        }\r\n        .imagelike {\r\n          width: 96px;\r\n          height: 48px;\r\n          position: absolute;\r\n          right: 40px;\r\n          top: 20px;\r\n        }\r\n        .imageunlike {\r\n          width: 148px;\r\n          height: 48px;\r\n          position: absolute;\r\n          left: 40px;\r\n          top: 20px;\r\n        }\r\n      }\r\n    }\r\n    .shop-imgbox:nth-child(1) {\r\n      width: 686px;\r\n      z-index: 50;\r\n    }\r\n    .shop-imgbox:nth-child(2) {\r\n      width: 676px;\r\n      z-index: 40;\r\n      margin: 15px 0px 0px 5px;\r\n    }\r\n    .shop-imgbox:nth-child(3) {\r\n      width: 666px;\r\n      z-index: 30;\r\n      margin: 30px 0px 0px 10px;\r\n    }\r\n    .shop-imgbox:nth-child(4) {\r\n      width: 656px;\r\n      z-index: 20;\r\n      margin: 0px 0px 0px 15px;\r\n    }\r\n    .shop-imgbox:nth-child(5) {\r\n      width: 646px;\r\n      z-index: 10;\r\n      margin: 0px 0px 0px 20px;\r\n    }\r\n  }\r\n  .noshop-card {\r\n    width: 100%;\r\n    margin-top: 40px;\r\n    padding: 0px 16px;\r\n    .noshop-image {\r\n      width: 100%;\r\n      height: 806px;\r\n    }\r\n  }\r\n  .stroll-fotter {\r\n    width: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    margin-top: 20px;\r\n    .fot-twoimg {\r\n      display: flex;\r\n      flex-direction: row;\r\n      align-items: center;\r\n      .dislike-image {\r\n        width: 120px;\r\n        height: 120px;\r\n      }\r\n      .like-image {\r\n        width: 120px;\r\n        height: 120px;\r\n        margin-left: 48px;\r\n      }\r\n    }\r\n    .fot-text {\r\n      color: #368BE5;\r\n      font-size: 28px;\r\n      margin-top: 40px;\r\n      margin-bottom: 50px;\r\n    }\r\n  }\r\n}好了，小程序左滑右滑效果就说到这里了，如果大家有更好的办法请在下方留言，上述的方法可能一下拖动效果之类的还需要加以完善，有什么好的建议和改善欢迎提出，谢谢了。"}
{"title": "小程序request 支持content-type为form-data 的两种使用方式", "author": "Rolan", "time": "2020-5-18 00:22", "content": "最近做了一个小程序上传文件的需求，在这个需求中，需要联调的接口要求请求头的content-type值需要设置为application/form-data，然而小程序提供的wx.request到目前为止（2020.05.14）暂不支持该设置，也许使用者会说能设置，但是发送请求时依旧会存在问题。。。因此，就需要去寻找各种解决方法，最终找到了两种处理方式，整理如下；当然，不排除还有其他实现思路。方式一其实小程序是有单独为上传文件做了一个定制的api去支持 application/form-data 的请求啦，所以莫慌。UploadTask wx.uploadFile(Object object)将本地资源上传到服务器。客户端发起一个 HTTPS POST 请求，其中 content-type 为 multipart/form-data。使用前请注意阅读相关说明。示例使用代码wx.chooseImage({\r\n  success (res) {\r\n    const tempFilePaths = res.tempFilePaths\r\n    wx.uploadFile({\r\n      url: 'https://example.weixin.qq.com/upload', //仅为示例，非真实的接口地址\r\n      filePath: tempFilePaths[0],\r\n      name: 'file',\r\n      formData: {\r\n        'user': 'test'\r\n      },\r\n      success (res){\r\n        const data = res.data\r\n        //do something\r\n      }\r\n    })\r\n  }\r\n})\r\n复制代码想了解更多，请点 详细文档方式二当然，我们也可以发现，微信提供的这个 uploadFile 只是比较使用上传的场景，如果是其他场景，使用起来可能就不是很舒适，所以就该进行一下form-data 的相应封装。封住方法如下：// 小程序直接设置content-type为''multipart/form-data;'无效，故需要手动封装form-data；XXX为边界值\r\nfunction formdata (obj = {}) {\r\n  let result = ''\r\n  for (let name of Object.keys(obj)) {\r\n    let value = obj[name];\r\n    result += \r\n    '\\r\\n--XXX' +\r\n    '\\r\\nContent-Disposition: form-data; name=\\\"'+ name +'\\\"'+ \r\n    '\\r\\n' +\r\n    '\\r\\n' + value\r\n  }\r\n  return result + '\\r\\n--XXX--'\r\n}\r\n复制代码注意，除了需要对传入的数据（对象）进行格式化为 form-data，之外，还需要设置header 的 content-type 为 'multipart/form-data; boundary=XXX';参考文章微信开发者文档微信开发讨论相关文章"}
{"title": "微信小程序添加卡券跳坑", "author": "Rolan", "time": "2020-5-18 00:31", "content": "引言应公司业务需求，用户可以在我方小程序里面领取合作方卡券到卡包。开发过程中发现，微信对于卡券的文档说明过于简单凌乱，以至于中间遇到了很多坑，这里做一个整理记录一下。需求这次需求主要是，合作方创建卡券，在我方小程序进行领取。这篇文章是基于卡券已经成功创建的基础上进行开发的。如何创建卡券，请参考 微信文档-创建卡券正文刚接到这个需求的时候，查看了一下微信文档，发现微信提供了一个添加卡券的APIwx.addCard({\r\n  cardList: [\r\n    {\r\n      cardId: '',\r\n      cardExt: '{\"code\": \"\", \"openid\": \"\", \"timestamp\": \"\", \"signature\":\"\"}'\r\n    }, {\r\n      cardId: '',\r\n      cardExt: '{\"code\": \"\", \"openid\": \"\", \"timestamp\": \"\", \"signature\":\"\"}'\r\n    }\r\n  ],\r\n  success (res) {\r\n    console.log(res.cardList) // 卡券添加结果\r\n  }\r\n})\r\n复制代码乍一看，感觉很简单，只要传cardId和cardExt就好了。但是cardExt是什么呢？文档只是提了一句cardExt 是卡券的扩展参数，其值是一个 JSON 字符串。看得我一脸懵逼，于是去找了公众号的官方文档，在 附录4 找到了cardExt的说明。其他字段都比较好理解，但是signature怎么获取呢？别急，文档也做了说明# 签名说明\r\n\r\n1.将 api_ticket、timestamp、card_id、code、openid、nonce_str的value值进行字符串的字典序排序。\r\n\r\n2.将所有参数字符串拼接成一个字符串进行sha1加密，得到signature。\r\n\r\n3.signature中的timestamp，nonce字段和card_ext中的timestamp，nonce_str字段必须保持一致。\r\n复制代码好不容易知道签名怎么生成，结果又出现了 api_ticket 这个不知道从哪里冒出来的参数。好在文档也进行了说明卡券 api_ticket 是用于调用卡券相关接口的临时票据，有效期为 7200 秒，通过 access_token 来获取。这里要注意与 jsapi_ticket 区分开来。由于获取卡券 api_ticket 的 api 调用次数非常有限，频繁刷新卡券 api_ticket 会导致 api 调用受限，影响自身业务，开发者必须在自己的服务全局缓存卡券 api_ticket 。\r\n\r\n1.参考以下文档获取access_token（有效期7200秒，开发者必须在自己的服务全局缓存access_token）：../15/54ce45d8d30b6bf6758f68d2e95bc627.html\r\n\r\n2.用第一步拿到的access_token 采用http GET方式请求获得卡券 api_ticket（有效期7200秒，开发者必须在自己的服务全局缓存卡券 api_ticket）：https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&type=wx_card\r\n复制代码简单来说就是get请求这个地址获取api_tickethttps://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=创建卡券公众号的ACCESSTOKEN&type=wx_card ,ok,api_ticket已经拿到了,下面就是生成签名了。这里微信提供了一个 官方校验工具 做调试，把参数 （这里注意，timestamp的单位是秒，不是毫秒） 都填进去就可以生成签名了拿到签名之后，再把它套进 cardExt 对象进行序列化，然后再放入 wx.addCard 里面就可以了到这里基本添加卡券所需要的参数就都能获取到了，顺利的话，应该可以在小程序顺利调用添加卡券的API，得到以下页面常见错误如果按照以上步骤进行依旧不能成功调用的话，别急，微信还出了一个文档总结了常见错误： 卡券签名错误排查方法 大家跟着文章说到的问题慢慢排查，基本都能成功的。"}
{"title": "微信小程序自定义navigationBar顶部导航栏，兼容适配所有机型（附完整案例） ...", "author": "Rolan", "time": "2020-3-27 00:37", "content": "本文首发自个人自有博客： 【FaxMiao个人博客】 ，一个关注Web前端开发技术、关注用户体验、记录前端点滴，坚持更多原创，为大家提供高质量技术博文！前言navigationBar相信大家都不陌生把？今天我们就来说说自定义navigationBar，把它改变成我们想要的样子（搜索框+胶囊、搜索框+返回按钮+胶囊等）。思路隐藏原生样式获取胶囊按钮、状态栏相关数据以供后续计算根据不同机型计算出该机型的导航栏高度，进行适配编写新的导航栏引用到页面正文一、隐藏原生的navigationBarwindow全局配置里有个参数：navigationStyle（导航栏样式），default=默认样式，custom=自定义样式。\"window\": {\r\n\t\"navigationStyle\": \"custom\"\r\n}\r\n复制代码让我们看看隐藏后的效果：可以看到原生的navigationBar已经消失了，剩下孤零零的胶囊按钮，胶囊按钮是无法隐藏的。二、准备工作1.获取胶囊按钮的布局位置信息我们用wx.getMenuButtonBoundingClientRect() 【官方文档】 获取胶囊按钮的布局位置信息，坐标信息以屏幕左上角为原点：const menuButtonInfo = wx.getMenuButtonBoundingClientRect();\r\n复制代码widthheighttoprightbottomleft宽度高度上边界坐标右边界坐标下边界坐标左边界坐标下面是官方给的示意图，方便大家理解几个坐标。2.获取系统信息用wx.getSystemInfoSync() 【官方文档】 获取系统信息，里面有个参数：statusBarHeight（状态栏高度），是我们后面计算整个导航栏的高度需要用到的。const systemInfo = wx.getSystemInfoSync();\r\n复制代码三、计算公式我们先要知道导航栏高度是怎么组成的， 计算公式： 导航栏高度 = 状态栏到胶囊的间距（胶囊距上距离-状态栏高度） * 2 + 胶囊高度 + 状态栏高度 。实例 【源码下载】自定义导航栏会应用到多个、甚至全部页面，所以封装成组件，方便调用；下面是我写的一个简单例子：app.jsApp({\r\n    onLaunch: function(options) {\r\n        const that = this;\r\n        // 获取系统信息\r\n        const systemInfo = wx.getSystemInfoSync();\r\n        // 胶囊按钮位置信息\r\n        const menuButtonInfo = wx.getMenuButtonBoundingClientRect();\r\n        // 导航栏高度 = 状态栏到胶囊的间距（胶囊距上距离-状态栏高度） * 2 + 胶囊高度 + 状态栏高度\r\n        that.globalData.navBarHeight = (menuButtonInfo.top - systemInfo.statusBarHeight) * 2 + menuButtonInfo.height + systemInfo.statusBarHeight;\r\n        that.globalData.menuRight = systemInfo.screenWidth - menuButtonInfo.right;\r\n        that.globalData.menuBotton = menuButtonInfo.top - systemInfo.statusBarHeight;\r\n        that.globalData.menuHeight = menuButtonInfo.height;\r\n    },\r\n    // 数据都是根据当前机型进行计算，这样的方式兼容大部分机器\r\n    globalData: {\r\n        navBarHeight: 0, // 导航栏高度\r\n        menuRight: 0, // 胶囊距右方间距（方保持左、右间距一致）\r\n        menuBotton: 0, // 胶囊距底部间距（保持底部间距一致）\r\n        menuHeight: 0, // 胶囊高度（自定义内容可与胶囊高度保证一致）\r\n    }\r\n})\r\n复制代码app.json{\r\n    \"pages\": [\r\n        \"pages/index/index\"\r\n    ],\r\n    \"window\": {\r\n        \"navigationStyle\": \"custom\"\r\n    },\r\n    \"sitemapLocation\": \"sitemap.json\"\r\n}\r\n复制代码下面为组件代码： /components/navigation-bar/navigation-bar.wxml<!-- 自定义顶部栏 -->\r\n<view class=\"nav-bar\" style=\"height:{{navBarHeight}}px;\">\r\n    <input class=\"search\" placeholder=\"输入关键词！\" style=\"height:{{menuHeight}}px; min-height:{{menuHeight}}px; line-height:{menuHeight}}px; left:{{menuRight}}px; bottom:{{menuBotton}}px;\"></input>\r\n</view>\r\n\r\n<!-- \r\n    内容区域：\r\n    自定义顶部栏用的fixed定位，会遮盖到下面内容，注意设置好间距\r\n-->\r\n<view class=\"content\" style=\"margin-top:{{navBarHeight}}px;\"></view>\r\n复制代码/components/navigation-bar/navigation-bar.json{\r\n  \"component\": true\r\n}\r\n复制代码/components/navigation-bar/navigation-bar.jsconst app = getApp()\r\nComponent({\r\n    properties: {\r\n        // defaultData（父页面传递的数据-就是引用组件的页面）\r\n        defaultData: {\r\n            type: Object,\r\n            value: {\r\n                title: \"我是默认标题\"\r\n            },\r\n            observer: function(newVal, oldVal) {}\r\n        }\r\n    },\r\n    data: {\r\n        navBarHeight: app.globalData.navBarHeight,\r\n        menuRight: app.globalData.menuRight,\r\n        menuBotton: app.globalData.menuBotton,\r\n        menuHeight: app.globalData.menuHeight,\r\n    },\r\n    attached: function() {},\r\n    methods: {}\r\n})\r\n复制代码/components/navigation-bar/navigation-bar.wxss.nav-bar{ position: fixed; width: 100%; top: 0; color: #fff; background: #000;}\r\n.nav-bar .search{ width: 60%; color: #333; font-size: 14px; background: #fff; position: absolute; border-radius: 50px; background: #ddd; padding-left: 14px;}\r\n复制代码以下是调用页面的代码，也就是引用组件的页面： /pages/index/index.wxml<navigation-bar default-data=\"{{defaultData}}\"></navigation-bar>\r\n复制代码/pages/index/index.json{\r\n    \"usingComponents\": {\r\n        \"navigation-bar\": \"/components/navigation-bar/navigation-bar\"\r\n    }\r\n}\r\n复制代码/pages/index/index.jsconst app = getApp();\r\nPage({\r\n    data: {\r\n        // 组件参数设置，传递到组件\r\n        defaultData: {\r\n            title: \"我的主页\", // 导航栏标题\r\n        }\r\n    },\r\n    onLoad() {\r\n        console.log(this.data.height)\r\n    }\r\n})\r\n复制代码效果图：好了，以上就是全部代码了，大家可以文中复制代码，也可以 【下载源码】，直接到开发者工具里运行，记得appid用自己的或者测试哦！下面附几张其它小程序的效果图，大家也可以尝试照着做：总结本文写了自定义navigationBar的一些基础性东西，里面涉及组件用法、参数传递、导航栏相关。由于测试环境有限，大家在使用时如果发现有什么问题，希望及时反馈，以供及时更新帮助更多的人！大家有什么疑问，欢迎评论区留言！"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发", "author": "admin", "time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "京喜小程序的高性能打造之路", "author": "Rolan", "time": "2020-3-27 00:26", "content": "本文阅读时长约15分钟。京喜小程序开发团队核心成员倾力之作，都是干货，读完一定会收获满满，请大家耐心阅读～背景京喜小程序自去年双十一上线微信购物一级入口后，时刻迎接着亿级用户量的挑战，细微的体验细节都有可能被无限放大，为此，“极致的页面性能”、“友好的产品体验” 和 “稳定的系统服务” 成为了我们开发团队的最基本执行原则。首页作为小程序的门户，其性能表现和用户留存率息息相关。因此，我们对京喜首页进行了一次全方位的升级改造，从加载、渲染和感知体验几大维度深挖小程序的性能可塑性。除此之外，京喜首页在微信小程序、H5、APP 三端都有落地场景，为了提高研发效率，我们使用了 Taro 框架实现多端统一，因此下文中有部分内容是和 Taro 框架息息相关的。怎么定义高性能？提起互联网应用性能这个词，很多人在脑海中的词法解析就是，“是否足够快？”，似乎加载速度成为衡量系统性能的唯一指标。但这其实是不够准确的，试想一下，如果一个小程序加载速度非常快，用户花费很短时间就能看到页面的主体内容，但此时搜索框却无法输入内容，功能无法被流畅使用，用户可能就不会关心页面渲染有多快了。所以，我们不应该单纯考虑速度指标而忽略用户的感知体验，而应该全方位衡量用户在使用过程中能感知到的与应用加载相关的每个节点。谷歌为 Web 应用定义了以用户为中心的性能指标体系，每个指标都与用户体验节点息息相关：其中，“是否有用？” 这个问题是非常主观的，对于不同场景的系统可能会有完全不一样的回答，所以 FMP 是一个比较模糊的概念指标，不存在规范化的数值衡量。小程序作为一个新的内容载体，衡量指标跟 Web 应用是非常类似的。对于大多数小程序而言，上述指标对应的含义为：FCP：白屏加载结束；FMP：首屏渲染完成；TTI：所有内容加载完成；综上，我们已基本确定了高性能的概念指标，接下来就是如何利用数值指标来描绘性能表现。小程序官方性能指标小程序官方针对小程序性能表现制订了权威的数值指标，主要围绕 渲染表现 、 setData 数据量 、 元素节点数 和 网络请求延时 这几个维度来给予定义（下面只列出部分关键指标）：首屏时间不超过 5 秒；渲染时间不超过 500ms；每秒调用 setData 的次数不超过 20 次；setData 的数据在 JSON.stringify 后不超过 256kb；页面 WXML 节点少于 1000 个，节点树深度少于 30 层，子节点数不大于 60 个；所有网络请求都在 1 秒内返回结果；详见 小程序性能评分规则我们应该把这一系列的官方指标作为小程序的性能及格线，不断地打磨和提升小程序的整体体验，降低用户流失率。另外，这些指标会直接作为小程序体验评分工具的性能评分规则（体验评分工具会根据这些规则的权重和求和公式计算出体验得分）。我们团队内部在官方性能指标的基础上，进一步浓缩优化指标系数，旨在对产品体验更高要求：setData\r\n体验评分工具小程序提供了 体验评分工具（ Audits 面板） 来测量上述的指标数据，其集成在开发者工具中，在小程序运行时实时检查相关问题点，并为开发者给出优化建议。以上截图均来自小程序官方文档体验评分工具是目前检测小程序性能问题最直接有效的途径，我们团队已经把体验评分作为页面/组件是否能达到精品门槛的重要考量手段之一。小程序后台性能分析我们知道，体验评分工具是在本地运行小程序代码时进行分析，但性能数据往往需要在真实环境和大数据量下才更有说服力。恰巧， 小程序管理平台 和 小程序助手 为开发者提供了大量的真实数据统计。其中，性能分析面板从 启动性能 、 运行性能 和 网络性能 这三个维度分析数据，开发者可以根据客户端系统、机型、网络环境和访问来源等条件做精细化分析，非常具有考量价值。其中，启动总耗时 = 小程序环境初始化 + 代码包加载 + 代码执行 + 渲染耗时第三方测速系统很多时候，宏观的耗时统计对于性能瓶颈点分析往往是杯水车薪，作用甚少，我们需要更细致地针对某个页面某些关键节点作测速统计，排查出暴露性能问题的代码区块，才能更有效地针对性优化。京喜小程序使用的是内部自研的测速系统，支持对地区、运营商、网络、客户端系统等多条件筛选，同时也支持数据可视化、同比分析数据等能力。京喜首页主要围绕 页面 onLoad 、 onReady 、 数据加载完成 、 首屏渲染完成 、 各业务组件首次渲染完成 等几个关键节点统计测速上报，旨在全链路监控性能表现。另外，微信为开发者提供了 测速系统 ，也支持针对客户端系统、网络类型、用户地区等维度统计数据，有兴趣的可以尝试。了解小程序底层架构为了更好地为小程序制订性能优化措施，我们有必要先了解小程序的底层架构，以及与 web 浏览器的差异性。微信小程序是大前端跨平台技术的其中一种产物，与当下其他热门的技术 React Native、Weex、Flutter 等不同，小程序的最终渲染载体依然是浏览器内核，而不是原生客户端。而对于传统的网页来说，UI 渲染和 JS 脚本是在同一个线程中执行，所以经常会出现 “阻塞” 行为。微信小程序基于性能的考虑，启用了 双线程模型 ：视图层 ：也就是 webview 线程，负责启用不同的 webview 来渲染不同的小程序页面；逻辑层 ：一个单独的线程执行 JS 代码，可以控制视图层的逻辑；上图来自小程序官方开发指南然而， 任何线程间的数据传输都是有延时的 ，这意味着逻辑层和视图层间通信是异步行为。除此之外，微信为小程序提供了很多客户端原生能力，在调用客户端原生能力的过程中，微信主线程和小程序双线程之间也会发生通信，这也是一种异步行为。这种异步延时的特性会使运行环境复杂化，稍不注意，就会产出效率低下的编码。作为小程序开发者，我们常常会被下面几个问题所困扰：小程序启动慢；白屏时间长；页面渲染慢；运行内存不足；接下来，我们会结合小程序的底层架构分析出这些问题的根本原因，并针对性地给出解决方案。小程序启动太慢？小程序启动阶段，也就是如下图所示的展示加载界面的阶段。在这个阶段中（包括启动前后的时机），微信会默默完成下面几项工作：1. 准备运行环境：在小程序启动前，微信会先启动双线程环境，并在线程中完成小程序基础库的初始化和预执行。小程序基础库包括 WebView 基础库和 AppService 基础库，前者注入到视图层中，后者注入到逻辑层中，分别为所在层级提供其运行所需的基础框架能力。2. 下载小程序代码包：在小程序初次启动时，需要下载编译后的代码包到本地。如果启动了小程序分包，则只有主包的内容会被下载。另外，代码包会保留在缓存中，后续启动会优先读取缓存。3. 加载小程序代码包：小程序代码包下载好之后，会被加载到适当的线程中执行，基础库会完成所有页面的注册。在页面注册过程中，基础库会调用页面 JS 文件的 Page 构造器方法，来记录页面的基础信息（包括初始数据、方法等）。4. 初始化小程序首页：在小程序代码包加载完之后，基础库会根据启动路径找到首页，根据首页的基础信息初始化一个页面实例，并把信息传递给视图层，视图层会结合 WXML 结构、WXSS 样式和初始数据来渲染界面。综合考虑，为了节省小程序的“点点点”时间（小程序的启动动画是三个圆点循环跑马灯），除了给每位用户发一台高配 5G 手机并顺带提供千兆宽带网络之外，还可以尽量 控制代码包大小 ，缩小代码包的下载时间。无用文件、函数、样式剔除经过多次业务迭代，无可避免的会存在一些弃用的组件/页面，以及不被调用的函数、样式规则，这些冗余代码会白白占据宝贵的代码包空间。而且，目前小程序的打包会将工程下所有文件都打入代码包内，并没有做依赖分析。因此，我们需要及时地剔除不再使用的模块，以保证代码包空间利用率保持在较高水平。通过一些工具化手段可以有效地辅助完成这一工作。文件依赖分析在小程序中，所有页面的路径都需要在小程序代码根目录 app.json 中被声明，类似地，自定义组件也需要在页面配置文件 page.json 中被声明。另外，WXML、WXSS 和 JS 的模块化都需要特定的关键字来声明依赖引用关系。WXML 中的 import 和 include ：<!-- A.wxml -->\r\n<template name='A'>\r\n  <text>{{text}}</text>\r\n</template>\r\n\r\n<!-- B.wxml -->\r\n<import src=\"A.wxml\"/>\r\n<template is=\"A\" data=\"{{text: 'B'}}\"/><!-- A.wxml -->\r\n<text> A </text>\r\n\r\n<!-- B.wxml -->\r\n<include src=\"A.wxml\"/>\r\n<text> B </text>WXSS 中的 @import ：@import './A.wxss'JS 中的 require / import ：const A = require('./A')所以，可以说小程序里的所有依赖模块都是有迹可循的，我们只需要利用这些关键字信息递归查找，遍历出文件依赖树，然后把没用的模块剔除掉。JS、CSS Tree-ShakingJS Tree-Shaking 的原理就是借助 Babel 把代码编译成抽象语法树（AST），通过 AST 获取到函数的调用关系，从而把未被调用的函数方法剔除掉。不过这需要依赖 ES module，而小程序最开始是遵循 CommonJS 规范的，这意味着是时候来一波“痛并快乐着”的改造了。而 CSS 的 Tree-Shaking 可以利用 PurifyCSS 插件来完成。关于这两项技术，有兴趣的可以“谷歌一下”，这里就不铺开细讲了。题外，京东的小程序团队已经把这一系列工程化能力集成在一套 CLI 工具中，有兴趣的可以看看这篇分享： 小程序工程化探索 。减少代码包中的静态资源文件小程序代码包最终会经过 GZIP 压缩放在 CDN 上，但 GZIP 压缩对于图片资源来说效果非常低。如 JPG 、 PNG 等格式文件，本身已经被压缩过了，再使用 GZIP 压缩有可能体积更大，得不偿失。所以，除了部分用于容错的图片必须放在代码包（譬如网络异常提示）之外，建议开发者把图片、视频等静态资源都放在 CDN 上。需要注意， Base64 格式本质上是长字符串，和 CDN 地址比起来也会更占空间。逻辑后移，精简业务逻辑这是一个 “痛并快乐着” 的优化措施。“痛” 是因为需要给后台同学提改造需求，分分钟被打；“快乐” 则是因为享受删代码的过程，而且万一出 Bug 也不用背锅了...（开个玩笑）通过让后台承担更多的业务逻辑，可以节省小程序前端代码量，同时线上问题还支持紧急修复，不需要经历小程序的提审、发布上线等繁琐过程。总结得出， 一般不涉及前端计算的展示类逻辑，都可以适当做后移 。譬如京喜首页中的幕帘弹窗（如下图）逻辑，这里共有 10+ 种弹窗类型，以前的做法是前端从接口拉取 10+ 个不同字段，根据优先级和 “是否已展示”（该状态存储在本地缓存） 来决定展示哪一种，最后代码大概是这样的：// 检查每种弹窗类型是否已展示\r\nPromise.all([\r\n  check(popup_1),\r\n  check(popup_2),\r\n  // ...\r\n  check(popup_n)\r\n]).then(result => {\r\n  // 优先级排序\r\n  const queue = [{\r\n    show: result.popup_1\r\n    data: data.popup_1\r\n  }, {\r\n    show: result.popup_2\r\n    data: data.popup_2\r\n  }, \r\n  // ...\r\n  {\r\n    show: result.popup_n\r\n    data: data.popup_n\r\n  }]\r\n})逻辑后移之后，前端只需负责拿幕帘字段做展示就可以了，代码变成这样：this.setData({\r\n  popup: data.popup\r\n})复用模板插件京喜首页作为电商系统的门户，需要应对各类频繁的营销活动、升级改版等，同时也要满足不同用户属性的界面个性化需求（俗称 “千人千面”）。如何既能减少为应对多样化场景而产生的代码量，又可以提升研发效率，成为燃眉之急。类似于组件复用的理念，我们需要提供更丰富的可配置能力，实现更高的代码复用度。参考小时候很喜欢玩的 “乐高” 积木玩具， 我们把首页模块的模板元素作颗粒度更细的划分，根据样式和功能抽象出一块块“积木”原料（称为插件元素） 。当首页模块在处理接口数据时，会启动插件引擎逐个装载插件，最终输出个性化的模板样式，整个流程就好比堆积木。当后续产品/运营需要新增模板时，只要在插件库中挑选插件排列组合即可，不需要额外新增/修改组件内容，也更不会产生难以维护的 if / else 逻辑，so easy～当然，要完成这样的插件化改造免不了几个先决条件：用户体验设计的统一 。如果设计风格总是天差地别的，强行插件化只会成为累赘。服务端接口的统一 。同上，如果得浪费大量的精力来兼容不同模块间的接口字段差异，将会非常蛋疼。下面为大家提供部分例程来辅助理解。其中， use 方法会接受各类处理钩子最终拼接出一个 Function ，在对应模块处理数据时会被调用。// bi.helper.js\r\n\r\n/**\r\n * 插件引擎\r\n * @param {function} options.formatName 标题处理钩子\r\n * @param {function} options.validList 数据校验器钩子\r\n */ \r\nconst use = options => data => format(data)\r\n\r\n/**\r\n * 预置插件库\r\n */ \r\nnameHelpers = {\r\n  text: data => data.text,\r\n  icon: data => data.icon\r\n}\r\nlistHelpers = {\r\n  single: list => list.slice(0, 1),\r\n  double: list => list.slice(0, 2)\r\n}\r\n\r\n/**\r\n * “堆积木”\r\n */\r\nexport default {\r\n  1000: use({\r\n    formatName: nameHelpers.text,\r\n    validList: listHelpers.single\r\n  }),\r\n\r\n  1001: use({\r\n    formatName: nameHelpers.icon,\r\n    validList: listHelpers.double\r\n  })\r\n}<!-- bi.wxml -->\r\n<!-- 各模板节点实现 -->\r\n<template name=\"renderName\">\r\n  <view wx:if=\"{{type === 'text'}}\"> text </view>\r\n  <view wx:elif=\"{{type === 'icon'}}\"> icon </view>\r\n</template>\r\n\r\n<view class=\"bi__name\">\r\n  <template is=\"renderName\" data=\"{{...data.name}\"/>\r\n</view>// bi.js\r\nComponent({\r\n  ready() {\r\n    // 根据 tpl 值选择解析函数\r\n    const formatData = helper[data.tpl]\r\n    this.setData({\r\n      data: formatData(data)\r\n    })\r\n  }\r\n})分包加载小程序启动时只会下载主包/独立分包，启用分包可以有效减少下载时间。（独立）分包需要遵循一些原则，详细的可以看官方文档：使用分包独立分包部分页面 h5 化小程序提供了 web-view 组件，支持在小程序环境内访问网页。当实在无法在小程序代码包中腾出多余空间时，可以考虑降级方案 —— 把部分页面 h5 化。小程序和 h5 的通信可以通过 JSSDK 或 postMessage 通道来实现，详见 小程序开发文档 。白屏时间过长？白屏阶段，是指小程序代码包下载完（也就是启动界面结束）之后，页面完成首屏渲染的这一阶段，也就是 FMP (首次有效绘制)。FMP 没法用标准化的指标定义，但对于大部分小程序来说，页面首屏展示的内容都需要依赖服务端的接口数据，那么影响白屏加载时间的主要由这两个元素构成：网络资源加载时间 ；渲染时间 ；启用本地缓存小程序提供了读写本地缓存的接口，数据存储在设备硬盘上。由于本地 I/O 读写（毫秒级）会比网络请求（秒级）要快很多，所以在用户访问页面时，可以优先从缓存中取上一次接口调用成功的数据来渲染视图，待网络请求成功后再覆盖最新数据重新渲染。除此之外，缓存数据还可以作为兜底数据，避免出现接口请求失败时页面空窗，一石二鸟。但并非所有场景都适合缓存策略，譬如对数据即时性要求非常高的场景（如抢购入口）来说，展示老数据可能会引发一些问题。小程序默认会按照 不同小程序 、 不同微信用户 这两个维度对缓存空间进行隔离。诸如京喜小程序首页也采用了缓存策略，会进一步按照 数据版本号 、 用户属性 来对缓存进行再隔离，避免信息误展示。数据预拉取小程序官方为开发者提供了一个在小程序冷启动时提前拉取第三方接口的能力： 数据预拉取 。关于冷启动和热启动的定义可以看 这里数据预拉取的原理其实很简单，就是在小程序启动时，微信服务器代理小程序客户端发起一个 HTTP 请求到第三方服务器来获取数据，并且把响应数据存储在本地客户端供小程序前端调取。当小程序加载完成后，只需调用微信提供的 API wx.getBackgroundFetchData 从本地缓存获取数据即可。这种做法可以充分利用小程序启动和初始化阶段的等待时间，使更快地完成页面渲染。京喜小程序首页已经在生产环境实践过这个能力，从每日千万级的数据分析得出，预拉取使冷启动时获取到接口数据的时间节点从 2.5s 加速到 1s（提速了 60%）。虽然提升效果非常明显，但这个能力依然存在一些不成熟的地方：预拉取的数据会被强缓存；由于预拉取的请求最终是由微信的服务器发起的，也许是出于服务器资源限制的考虑，预拉取的数据会缓存在微信本地一段时间，缓存失效后才会重新发起请求。经过真机实测，在微信购物入口冷启动京喜小程序的场景下，预拉取缓存存活了 30 分钟以上，这对于数据实时性要求比较高的系统来说是非常致命的。请求体和响应体都无法被拦截；由于请求第三方服务器是从微信的服务器发起的，而不是从小程序客户端发起的，所以本地代理无法拦截到这一次真实请求，这会导致开发者无法通过拦截请求的方式来区分获取线上环境和开发环境的数据，给开发调试带来麻烦。小程序内部接口的响应体类型都是 application/octet-stream ，即数据格式未知，使本地代理无法正确解析。微信服务器发起的请求没有提供区分线上版和开发版的参数，且没有提供用户 IP 等信息 ；如果这几个问题点都不会影响到你的场景，那么可以尝试开启预拉取能力，这对于小程序首屏渲染速度是质的提升。跳转时预拉取为了尽快获取到服务端数据，比较常见的做法是在页面 onLoad 钩子被触发时发起网络请求，但其实这并不是最快的方式。从发起页面跳转，到下一个页面 onLoad 的过程中，小程序需要完成一些环境初始化及页面实例化的工作，耗时大概为 300 ~ 400 毫秒。实际上，我们可以在发起跳转前（如 wx.navigateTo 调用前），提前请求下一个页面的主接口并存储在全局 Promise 对象中，待下个页面加载完成后从 Promise 对象中读取数据即可。这也是双线程模型所带来的优势之一，不同于多页面 web 应用在页面跳转/刷新时就销毁掉 window 对象。分包预下载如果开启了分包加载能力，在用户访问到分包内某个页面时，小程序才会开始下载对应的分包。当处于分包下载阶段时，页面会维持在 “白屏” 的启动态，这用户体验是比较糟糕的。幸好，小程序提供了 分包预下载 能力，开发者可以配置进入某个页面时预下载可能会用到的分包，避免在页面切换时僵持在 “白屏” 态。非关键渲染数据延迟请求这是关键渲染路径优化的其中一个思路，从缩短网络请求时延的角度加快首屏渲染完成时间。关键渲染路径（Critical Rendering Path） 是指在完成首屏渲染的过程中必须发生的事件。以京喜小程序如此庞大的小程序项目为例，每个模块背后都可能有着海量的后台服务作支撑，而这些后台服务间的通信和数据交互都会存在一定的时延。我们根据京喜首页的页面结构，把所有模块划分成两类： 主体模块 （导航、商品轮播、商品豆腐块等）和 非主体模块 （幕帘弹窗、右侧挂件等）。在初始化首页时，小程序会发起一个聚合接口请求来获取主体模块的数据，而非主体模块的数据则从另一个接口获取，通过拆分的手段来降低主接口的调用时延，同时减少响应体的数据量，缩减网络传输时间。分屏渲染这也是关键渲染路径优化思路之一，通过延迟非关键元素的渲染时机，为关键渲染路径腾出资源。类似上一条措施，继续以京喜小程序首页为例，我们在 主体模块 的基础上再度划分出 首屏模块 （商品豆腐块以上部分） 和 非首屏模块 （商品豆腐块及以下部分）。当小程序获取到主体模块的数据后，会优先渲染首屏模块，在所有首屏模块都渲染完成后才会渲染非首屏模块和非主体模块，以此确保首屏内容以最快速度呈现。为了更好地呈现效果，上面 gif 做了降速处理接口聚合，请求合并在小程序中，发起网络请求是通过 wx.request 这个 API。我们知道，在 web 浏览器中，针对同一域名的 HTTP 并发请求数是有限制的；在小程序中也有类似的限制，但区别在于不是针对域名限制，而是针对 API 调用：wx.request\r\nwx.connectSocket\r\n超出并发限制数目的 HTTP 请求将会被阻塞，需要在队列中等待前面的请求完成，从而一定程度上增加了请求时延。因此， 对于职责类似的网络请求，最好采用节流的方式，先在一定时间间隔内收集数据，再合并到一个请求体中发送给服务端。图片资源优化图片资源一直是移动端系统中抢占大流量的部分，尤其是对于电商系统。优化图片资源的加载可以有效地加快页面响应时间，提升首屏渲染速度。使用 WebP 格式WebP 是 Google 推出的一种支持有损/无损压缩的图片文件格式，得益于更优的图像数据压缩算法，其与 JPG、PNG 等格式相比，在肉眼无差别的图片质量前提下具有更小的图片体积（据官方说明，WebP 无损压缩体积比 PNG 小 26%，有损压缩体积比 JPEG 小 25-34%）。小程序的 image 组件 支持 JPG、PNG、SVG、WEBP、GIF 等格式。图片裁剪&降质鉴于移动端设备的分辨率是有上限的，很多图片的尺寸常常远大于页面元素尺寸，这非常浪费网络资源（一般图片尺寸 2 倍于页面元素真实尺寸比较合适）。得益于京东内部强大的图片处理服务，我们可以通过资源的命名规则和请求参数来获取服务端优化后的图片：裁剪成 100x100 的图片： https://{host}/s100x100_jfs/{file_path} ；降质 70%： https://{href}!q70 ；图片懒加载、雪碧图（CSS Sprite）优化这两者都是比较老生常谈的图片优化技术，这里就不打算细讲了。小程序的 image 组件 自带 lazy-load 懒加载支持。雪碧图技术（CSS Sprite）可以参考 w3schools 的教程。降级加载大图资源在不得不使用大图资源的场景下，我们可以适当使用 “体验换速度” 的措施来提升渲染性能。小程序会把已加载的静态资源缓存在本地，当短时间内再次发起请求时会直接从缓存中取资源（与浏览器行为一致）。因此，对于大图资源， 我们可以先呈现高度压缩的模糊图片，同时利用一个隐藏的 <image> 节点来加载原图，待原图加载完成后再转移到真实节点上渲染 。整个流程，从视觉上会感知到图片从模糊到高清的过程，但与对首屏渲染的提升效果相比，这点体验落差是可以接受的。下面为大家提供部分例程：<!-- banner.wxml -->\r\n<image src=\"{{url}}\" />\r\n\r\n<!-- 图片加载器 -->\r\n<image\r\n  style=\"width:0;height:0;display:none\"\r\n  src=\"{{preloadUrl}}\"\r\n  bindload=\"onImgLoad\"\r\n  binderror=\"onErrorLoad\"\r\n/>// banner.js\r\nComponent({\r\n  ready() {\r\n    this.originUrl = 'https://path/to/picture'  // 图片源地址\r\n    this.setData({\r\n      url: compress(this.originUrl)             // 加载压缩降质的图片\r\n      preloadUrl: this.originUrl                // 预加载原图\r\n    })\r\n  },\r\n  methods: {\r\n    onImgLoad() {\r\n      this.setData({\r\n        url: this.originUrl                       // 加载原图\r\n      })\r\n    }\r\n  }\r\n})注意，具有 display: none 样式的 <image> 标签只会加载图片资源，但不渲染。京喜首页的商品轮播模块也采用了这种降级加载方案，在首屏渲染时只会加载第一帧降质图片。以每帧原图 20~50kb 的大小计算，这一措施可以在初始化阶段节省掉几百 kb 的网络资源请求。为了更好地呈现效果，上面 gif 做了降速处理骨架屏一方面，我们可以从降低网络请求时延、减少关键渲染的节点数这两个角度出发，缩短完成 FMP（首次有效绘制）的时间。另一方面，我们也需要从用户感知的角度优化加载体验。“白屏” 的加载体验对于首次访问的用户来说是难以接受的，我们可以使用尺寸稳定的骨架屏，来辅助实现真实模块占位和瞬间加载。骨架屏目前在业界被广泛应用，京喜首页选择使用灰色豆腐块作为骨架屏的主元素，大致勾勒出各模块主体内容的样式布局。由于微信小程序不支持 SSR（服务端渲染），使动态渲染骨架屏的方案难以实现，因此京喜首页的骨架屏是通过 WXSS 样式静态渲染的。有趣的是，京喜首页的骨架屏方案经历了 “统一管理” 和 “（组件）独立管理” 两个阶段。出于避免对组件的侵入性考虑，最初的骨架屏是由一个完整的骨架屏组件统一管理的：<!-- index.wxml -->\r\n<skeleton wx:if=\"{{isLoading}}\"></skeleton>\r\n<block wx:else>\r\n  页面主体\r\n</block>但这种做法的维护成本比较高，每次页面主体模块更新迭代，都需要在骨架屏组件中的对应节点同步更新（譬如某个模块的尺寸被调整）。除此之外，感官上从骨架屏到真实模块的切换是跳跃式的，这是因为骨架屏组件和页面主体节点之间的关系是整体条件互斥的，只有当页面主体数据 Ready（或渲染完毕）时才会把骨架屏组件销毁，渲染（或展示）主体内容。为了使用户感知体验更加丝滑，我们把骨架屏元素拆分放到各个业务组件中，骨架屏元素的显示/隐藏逻辑由业务组件内部独立管理，这就可以轻松实现 “谁跑得快，谁先出来” 的并行加载效果。除此之外，骨架屏元素与业务组件共用一套 WXML 节点，且相关样式由公共的 sass 模块集中管理，业务组件只需要在适当的节点挂上 skeleton 和 skeleton__block 样式块即可，极大地降低了维护成本。<!-- banner.wxml -->\r\n<view class=\"{{isLoading ? 'banner--skeleton' : ''}}\">\r\n  <view class=\"banner_wrapper\"></view>\r\n</view>// banner.scss\r\n.banner--skeleton {\r\n  @include skeleton;\r\n  .banner_wrapper {\r\n    @include skeleton__block;\r\n  }\r\n}上面的 gif 在压缩过程有些小问题，大家可以直接访问【京喜】小程序体验骨架屏效果。如何提升渲染性能？当调用 wx.navigateTo 打开一个新的小程序页面时，小程序框架会完成这几步工作：1. 准备新的 webview 线程环境，包括基础库的初始化；2. 从逻辑层到视图层的初始数据通信；3. 视图层根据逻辑层的数据，结合 WXML 片段构建出节点树（包括节点属性、事件绑定等信息），最终与 WXSS 结合完成页面渲染；由于微信会提前开始准备 webview 线程环境，所以小程序的渲染损耗主要在后两者 数据通信和 节点树创建/更新 的流程中。相对应的，比较有效的渲染性能优化方向就是：降低线程间通信频次；减少线程间通信的数据量；减少 WXML 节点数量；合并 setData 调用尽可能地把多次 setData 调用合并成一次。我们除了要从编码规范上践行这个原则，还可以通过一些技术手段降低 setData 的调用频次。譬如，把同一个时间片（ 事件循环 ）内的 setData 调用合并在一起，Taro 框架就使用了这个优化手段。在 Taro 框架下，调用 setState 时提供的对象会被加入到一个数组中，当下一次事件循环执行的时候再把这些对象合并一起，通过 setData 传递给原生小程序。// 小程序里的时间片 API\r\nconst nextTick = wx.nextTick ? wx.nextTick : setTimeout;只把与界面渲染相关的数据放在 data 中不难得出， setData 传输的数据量越多，线程间通信的耗时越长，渲染速度就越慢。根据微信官方测得的数据，传输时间和数据量大体上呈正相关关系：上图来自小程序官方开发指南所以，与视图层渲染无关的数据尽量不要放在 data 中，可以放在页面（组件）类的其他字段下。应用层的数据 diff每当调用 setData 更新数据时，会引起视图层的重新渲染，小程序会结合新的 data 数据和 WXML 片段构建出新的节点树，并与当前节点树进行比较得出最终需要更新的节点（属性）。即使小程序在底层框架层面已经对节点树更新进行了 diff，但我们依旧可以优化这次 diff 的性能。譬如，在调用 setData 时，提前确保传递的所有新数据都是有变化的，也就是针对 data 提前做一次 diff。Taro 框架内部做了这一层优化。在每次调用原生小程序的 setData 之前，Taro 会把最新的 state 和当前页面实例的 data 做一次 diff，筛选出有必要更新的数据再执行 setData 。附 Taro 框架的 数据 diff 规则去掉不必要的事件绑定当用户事件（如 Click 、 Touch 事件等）被触发时，视图层会把事件信息反馈给逻辑层，这也是一个线程间通信的过程。但，如果没有在逻辑层中绑定事件的回调函数，通信将不会被触发。所以，尽量减少不必要的事件绑定，尤其是像 onPageScroll 这种会被频繁触发的用户事件，会使通信过程频繁发生。去掉不必要的节点属性组件节点支持附加自定义数据 dataset （见下面例子），当用户事件被触发时，视图层会把事件 target 和 dataset 数据传输给逻辑层。那么，当自定义数据量越大，事件通信的耗时就会越长，所以应该避免在自定义数据中设置太多数据。<!-- wxml -->\r\n<view\r\n  data-a='A'\r\n  data-b='B'\r\n  bindtap='bindViewTap'\r\n>\r\n  Click Me!\r\n</view>// js\r\nPage({\r\n  bindViewTap(e) {\r\n    console.log(e.currentTarget.dataset)\r\n  }\r\n})适当的组件颗粒度小程序的组件模型与 Web Components 标准中的 ShadowDOM 非常类似，每个组件都有独立的节点树，拥有各自独立的逻辑空间（包括独立的数据、 setData 调用、 createSelectorQuery执行域等）。不难得出，如果自定义组件的颗粒度太粗，组件逻辑过重，会影响节点树构建和新/旧节点树 diff 的效率，从而影响到组件内 setData 的性能。另外，如果组件内使用了 createSelectorQuery来查找节点，过于庞大的节点树结构也会影响查找效率。我们来看一个场景，京喜首页的 “京东秒杀” 模块涉及到一个倒计时特性，是通过 setInterval每秒调用 setData 来更新表盘时间。我们通过把倒计时抽离出一个基础组件，可以有效降低频繁 setData 时的性能影响。适当的组件化，既可以减小数据更新时的影响范围，又能支持复用，何乐而不为？诚然，并非组件颗粒度越细越好，组件数量和小程序代码包大小是正相关的。尤其是对于使用编译型框架（如 Taro）的项目，每个组件编译后都会产生额外的运行时代码和环境 polyfill，so，为了代码包空间，请保持理智...事件总线，替代组件间数据绑定的通信方式WXML 数据绑定是小程序中父组件向子组件传递动态数据的较为常见的方式，如下面例程所示： Component A 组件中的变量 a 、 b 通过组件属性传递给 Component B 组件。在此过程中，不可避免地需要经历一次 Component A 组件的 setData 调用方可完成任务，这就会产生线程间的通信。“合情合理”，但，如果传递给子组件的数据只有一部分是与视图渲染有关呢？<!-- Component A -->\r\n<component-b prop-a=\"{{a}}\" prop-b=\"{{b}}\" />// Component B\r\nComponent({\r\n  properties: {\r\n    propA: String,\r\n    propB: String,\r\n  },\r\n  methods: {\r\n    onLoad: function() {\r\n      this.data.propA\r\n      this.data.propB\r\n    }\r\n  }\r\n})推荐一种特定场景下非常便捷的做法：通过事件总线（EventBus），也就是发布/订阅模式，来完成由父向子的数据传递。其构成非常简单（例程只提供关键代码...）：一个全局的事件调度中心class EventBus {\r\n  constructor() {\r\n    this.events = {}\r\n  }\r\n\r\n  on(key, cb) { this.events[key].push(cb) }\r\n\r\n  trigger(key, args) { \r\n    this.events[key].forEach(function (cb) {\r\n      cb.call(this, ...args)\r\n    })\r\n  }\r\n  \r\n  remove() {}\r\n}\r\n\r\nconst event = new EventBus()事件订阅者// 子组件\r\nComponent({\r\n  created() {\r\n    event.on('data-ready', (data) => { this.setData({ data }) })\r\n  }\r\n})事件发布者// Parent\r\nComponent({\r\n  ready() {\r\n    event.trigger('data-ready', data)\r\n  }\r\n})子组件被创建时事先监听数据下发事件，当父组件获取到数据后触发事件把数据传递给子组件，这整个过程都是在小程序的逻辑层里同步执行，比数据绑定的方式速度更快。但并非所有场景都适合这种做法。像京喜首页这种具有 “数据单向传递” 、 “展示型交互” 特性、且 一级子组件数量庞大 的场景，使用事件总线的效益将会非常高；但若是频繁 “双向数据流“ 的场景，用这种方式会导致事件交错难以维护。题外话，Taro 框架在处理父子组件间数据传递时使用的是观察者模式，通过 Object.defineProperty 绑定父子组件关系，当父组件数据发生变化时，会递归通知所有后代组件检查并更新数据。这个通知的过程会同步触发数据 diff 和一些校验逻辑，每个组件跑一遍大概需要 5 ~ 10 ms 的时间。所以，如果组件量级比较大，整个流程下来时间损耗还是不小的，我们依旧可以尝试事件总线的方案。组件层面的 diff我们可能会遇到这样的需求，多个组件之间位置不固定，支持随时随地灵活配置，京喜首页也存在类似的诉求。京喜首页主体可被划分为若干个业务组件（如搜索框、导航栏、商品轮播等），这些业务组件的顺序是不固定的，今天是搜索框在最顶部，明天有可能变成导航栏在顶部了（夸张了...）。我们不可能针对多种顺序可能性提供多套实现，这就需要用到小程序的自定义模板 <template> 。实现一个支持调度所有业务组件的模板，根据后台下发的模块数组按序循环渲染模板，如下面例程所示。<!-- index.wxml -->\r\n<template name=\"render-component\">\r\n  <search-bar wx:if=\"{{compId === 'SearchBar'}}\" floor-id=\"{{index}}\" />\r\n  <nav-bar wx:if=\"{{compId === 'NavBar'}}\" floor-id=\"{{index}}\" />\r\n  <banner wx:if=\"{{compId === 'Banner'}}\" floor-id=\"{{index}}\" />\r\n  <icon-nav wx:if=\"{{compId === 'IconNav'}}\" floor-id=\"{{index}}\" />\r\n</template>\r\n\r\n<view\r\n  class=\"component-wrapper\"\r\n  wx:for=\"{{comps}}\"\r\n  wx:for-item=\"comp\"\r\n>\r\n  <template is=\"render-component\" data=\"{{...comp}}\"/>\r\n</view>// search-bar.js\r\nComponent({\r\n  properties: {\r\n    floorId: Number,\r\n  },\r\n  created() {\r\n    event.on('data-ready', (comps) => {\r\n      const data = comps[this.data.floorId] // 根据楼层位置取数据\r\n    })\r\n  }\r\n})貌似非常轻松地完成需求，但值得思考的是： 如果组件顺序调整了，所有组件的生命周期会发生什么变化？假设，上一次渲染的组件顺序是 ['search-bar'，'nav-bar'，'banner', 'icon-nav'] ，现在需要把 nav-bar 组件去掉，调整为 ['search-bar'，'banner', 'icon-nav'] 。经实验得出， 当某个组件节点发生变化时，其前面的组件不受影响，其后面的组件都会被销毁重新挂载。原理很简单，每个组件都有各自隔离的节点树（ ShadowTree ），页面 body 也是一个节点树。在调整组件顺序时，小程序框架会遍历比较新/旧节点树的差异，于是发现新节点树的 nav-bar 组件节点不见了，就认为该（树）分支下从 nav-bar 节点起发生了变化，往后节点都需要重渲染。但实际上，这里的组件顺序是没有变化的，丢失的组件按道理不应该影响到其他组件的正常渲染。所以，我们在 setData 前先进行了新旧组件列表 diff： 如果 newList 里面的组件是 oldList 的子集，且相对顺序没有发生变化，则所有组件不重新挂载 。除此之外，我们还要在接口数据的相应位置填充上空数据，把该组件隐藏掉，done。通过组件 diff 的手段，可以有效降低视图层的渲染压力，如果有类似场景的朋友，也可以参考这种方案。内存占用过高？想必没有什么会比小程序 Crash 更影响用户体验了。当小程序占用系统资源过高，就有可能会被系统销毁或被微信客户端主动回收。应对这种尴尬场景，除了提示用户提升硬件性能之外（譬如来京东商城买新手机），还可以通过一系列的优化手段降低小程序的内存损耗。内存预警小程序提供了监听内存不足告警事件的 API： wx.onMemoryWarning ，旨在让开发者收到告警时及时释放内存资源避免小程序 Crash。然而对于小程序开发者来说，内存资源目前是无法直接触碰的，最多就是调用 wx.reLaunch 清理所有页面栈，重载当前页面，来降低内存负荷（此方案过于粗暴，别冲动，想想就好...）。不过内存告警的信息收集倒是有意义的，我们可以把内存告警信息（包括页面路径、客户端版本、终端手机型号等）上报到日志系统，分析出哪些页面 Crash 率比较高，从而针对性地做优化，降低页面复杂度等等。回收后台页面计时器根据双线程模型，小程序每一个页面都会独立一个 webview 线程，但逻辑层是单线程的，也就是所有的 webview 线程共享一个 JS 线程。以至于当页面切换到后台态时，仍然有可能抢占到逻辑层的资源，譬如没有销毁的 setInterval 、 setTimeout 定时器：// Page A\r\nPage({\r\n  onLoad() {\r\n    let i = 0\r\n    setInterval(() => { i++ }, 100)\r\n  }\r\n})即使如小程序的 <swiper> 组件，在页面进入后台态时依然是会持续轮播的。正确的做法是， 在页面 onHide 的时候手动把定时器清理掉，有必要时再在 onShow 阶段恢复定时器 。坦白讲，区区一个定时器回调函数的执行，对于系统的影响应该是微不足道的，但不容忽视的是回调函数里的代码逻辑，譬如在定时器回调里持续 setData 大量数据，这就非常难受了...避免频发事件中的重度内存操作我们经常会遇到这样的需求：广告曝光、图片懒加载、导航栏吸顶等等，这些都需要我们在页面滚动事件触发时实时监听元素位置或更新视图。在了解小程序的双线程模型之后不难发现，页面滚动时 onPageScroll 被频发触发，会使逻辑层和视图层发生持续通信，若这时候再 “火上浇油” 调用 setData 传输大量数据，会导致内存使用率快速上升，使页面卡顿甚至 “假死”。所以，针对频发事件的监听，我们最好遵循以下原则：onPageScroll 事件回调使用节流；避免 CPU 密集型操作，譬如复杂的计算；避免调用 setData ，或减小 setData 的数据量；尽量使用 IntersectionObserver 来替代 SelectorQuery ，前者对性能影响更小；大图、长列表优化据 小程序官方文档 描述，大图片和长列表图片在 iOS 中会引起 WKWebView 的回收，导致小程序 Crash。对于大图片资源（譬如满屏的 gif 图）来说，我们只能尽可能对图片进行降质或裁剪，当然不使用是最好的。对于长列表，譬如瀑布流，这里提供一种思路：我们可以利用 IntersectionObserver 监听长列表内组件与视窗之间的相交状态，当组件距离视窗大于某个临界点时，销毁该组件释放内存空间，并用等尺寸的骨架图占坑；当距离小于临界点时，再取缓存数据重新加载该组件。然而无可避免地，当用户快速滚动长列表时，被销毁的组件可能来不及加载完，视觉上就会出现短暂的白屏。我们可以适当地调整销毁阈值，或者优化骨架图的样式来尽可能提升体验感。小程序官方提供了一个 长列表组件 ，可以通过 npm 包的方式引入，有兴趣的可以尝试。总结结合上述的种种方法论，京喜小程序首页进行全方位升级改造之后给出了答卷：1. Audits 审计工具的性能得分 86 ；2. 优化后的首屏渲染完成时间（FMP）：3. 优化前后的测速数据对比：然而，业务迭代在持续推进，多样化的用户场景徒增不减，性能优化将成为我们日常开发中挥之不去的原则和主题。本文以微信小程序开发中与性能相关的问题为出发点，基于小程序的底层框架原理，探究小程序性能体验提升的各种可能性，希望能为各位小程序开发者带来参考价值。参考User-centric Performance MetricsReduce JavaScript Payloads with Tree Shaking小程序开发指南小程序官方文档Taro 官方文档探究WebP一些事儿京喜首页（微信购物入口）跨端开发与优化实践欢迎关注凹凸实验室博客： aotu.io或者关注凹凸实验室公众号（AOTULabs），不定时推送文章："}
{"title": "使用flex弹性布局代替传统浮动布局来为微信小程序写自适应页面 ...", "author": "Rolan", "time": "2020-5-1 00:22", "content": "原文转载自「刘悦的技术博客」 v3u.cn/a_id_109我们知道，写习惯了前端的人，一般切图后布局页面的话，上手最习惯的是基于盒子模型的浮动布局，依赖 display 属性 + position属性 + float属性，但是浮动布局有一些致命的小问题，比如垂直居中比较费劲，比如著名的 float坍塌问题 ，另外有些极端情况下，还得使用模型+clear:both来手动清除浮动，比较麻烦。于是，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能，本人在微信小程序页面中尝试了一下弹性布局，个人感觉是：简直太好用了。Flex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。.box{\r\n  display: flex;\r\n}\r\n复制代码不过需要注意一点，就是设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。也就是说浮动布局和弹性布局不可共存，二者必居其一。其实flex布局原理很简单，采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。弹性布局的容器可以设置下面这些属性：flex-direction\r\nflex-direction属性决定主轴的方向（即项目的排列方向）。\r\n.box {\r\n  flex-direction: row | row-reverse | column | column-reverse;\r\n}\r\n\r\nflex-wrap\r\n默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\r\n.box{\r\n  flex-wrap: nowrap | wrap | wrap-reverse;\r\n}\r\n\r\nflex-flow\r\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\r\n.box {\r\n  flex-flow: <flex-direction> || <flex-wrap>;\r\n}\r\n\r\n\r\njustify-content\r\njustify-content属性定义了项目在主轴上的对齐方式。\r\n.box {\r\n  justify-content: flex-start | flex-end | center | space-between | space-around;\r\n}\r\n\r\n\r\nalign-items\r\nalign-items属性定义项目在交叉轴上如何对齐。\r\n.box {\r\n  align-items: flex-start | flex-end | center | baseline | stretch;\r\n}\r\n\r\nalign-content\r\nalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\r\n.box {\r\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\r\n}\r\n复制代码说了这么多，都是理论，我们来用弹性布局实战一下，比如我们要模仿瑞辛咖啡小程序中的，首行单列，换行双列，并且自适应整个手机页面的布局页面部分:<template>\r\n   \r\n\r\n        <div class=\"container1\">\r\n \r\n            <div class=\"item11\">\r\n            1\r\n            </div>\r\n            \r\n           <div class=\"item12\">\r\n            \r\n              <div class=\"item1\">\r\n                  3\r\n                  </div>\r\n\r\n\r\n                  <div class=\"item1\">\r\n                      3\r\n                      </div>\r\n            \r\n          </div>\r\n            \r\n            <div class=\"item12\">\r\n              \r\n                <div class=\"item1\">\r\n                    3\r\n                    </div>\r\n  \r\n  \r\n                    <div class=\"item1\">\r\n                        3\r\n                        </div>\r\n\r\n\r\n            </div>\r\n            \r\n         \r\n            \r\n  \r\n\r\n\r\n      \r\n\r\n    </div>\r\n    </template>\r\n复制代码css部分:.container1{\r\n  height: 100%;\r\n  width:100%;\r\n  background-color:beige;\r\n  display:flex;\r\n  flex-flow:column;\r\n}\r\n\r\n\r\n.item11{\r\n  height:300rpx;\r\n  background-color:cyan;\r\n  border: 1px solid #fff\r\n}\r\n\r\n.item12{\r\n  height:300rpx;\r\n  background-color:cyan;\r\n  border: 1px solid #fff;\r\n  display:flex;\r\n}\r\n \r\n.item1{\r\n  height:300rpx;\r\n  width: 50%;\r\n  background-color:cyan;\r\n  border: 1px solid #fff\r\n}\r\n复制代码轻松搞定，代码量比浮动布局少了很多，简直完美。原文转载自「刘悦的技术博客」 v3u.cn/a_id_109"}
{"title": "微信小程序无法保存图片提示saveImageToPhotosAlbum:fail file not found ...", "author": "Rolan", "time": "2020-5-4 00:47", "content": "最近项目中遇到一个需求，就是要保存商品的图片到手机相册，一开始我还以为挺简单的，毕竟文档在哪里，小程序一般都是拿来就用的，可是这个就是不行，遇到提示saveImageToPhotosAlbum:fail file not found问题，最后发现是用户没有授权。解决这个问题又发现小程序又无法保存图片，这明明是同意了为什么还不行，经过研究发现，我没要先获取图片信息在进行保存就可以了。我使用的是uni-app来开发的，如果你用原生小程序开发的话就把uni改成wx吧！在这里我强烈推荐大家使用uni-app来开发小程序。具体什么好处，大伙可以去看看uni-app的文档，好了不多说看代码。/* 如果是这么写的，可以不使用button设置open-type属性*/\r\n/* 判断是否授权 */\r\nuni.authorize({\r\n    /* 这个就是保存相册的 */\r\n    scope: 'scope.writePhotosAlbum',\r\n    success() {\r\n        /* 保存图片方法 */\r\n        img();\r\n    },\r\n    complete(res) {\r\n        console.log(res);\r\n        /* 这里判断一下如果没有授权重新打开设置选项 */\r\n        uni.getSetting({\r\n            success(res) {\r\n                if (!res.authSetting['scope.writePhotosAlbum']) {\r\n                    /* 打开设置的方法 */\r\n                    opensit();\r\n                }\r\n            }\r\n        });\r\n    }\r\n});\r\n/* 授权提示 ，这里就是重复提示用户去授权*/\r\nfunction opensit() {\r\n    uni.showModal({\r\n        content: '由于您还没有允许保存图片到您相册里,这无法进行分享操作点击确定去允许授权',\r\n        success: function(res) {\r\n            if (res.confirm) {\r\n                /* 这个就是打开设置的API*/\r\n                uni.openSetting({\r\n                    success(res) {\r\n                        console.log(res.authSetting);\r\n                    }\r\n                });\r\n            } else if (res.cancel) {\r\n                uni.showModal({\r\n                    cancelText: '依然取消',\r\n                    confirmText: '重新授权',\r\n                    content: '很遗憾你点击了取消，这将无法进行分享操作，请慎重考虑',\r\n                    success: function(res) {\r\n                        if (res.confirm) {\r\n                            uni.openSetting({\r\n                                success(res) {\r\n                                    console.log(res.authSetting);\r\n                                }\r\n                            });\r\n                        } else if (res.cancel) {\r\n                            console.log('用户不授权');\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n}\r\n/* 特别注意要先获取图片信息在进行保存，不让保存不了 */\r\nfunction img() {\r\n/* 我这里要保存多张图片，一张的话就可以取消这些，具体看你的需求 */\r\n    if (num > len) {\r\n        return false;\r\n    }\r\n    /* 获取图片信息 */\r\n    uni.getImageInfo({\r\n        src: obj[num],\r\n        success: function(image) {\r\n            console.log(image);\r\n            /* 保存图片到相册 */\r\n            uni.saveImageToPhotosAlbum({\r\n                filePath: image.path,\r\n                success: function() {\r\n                    console.log('save success');\r\n                    if (num == len) {\r\n                        uni.showModal({\r\n                            title: '保存成功',\r\n                            content: '图片已成功保存到相册，快去分享到您的圈子吧',\r\n                            showCancel: false\r\n                        });\r\n                    }\r\n                },\r\n                complete(res) {\r\n                    console.log(res);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    num++;\r\n    img();\r\n}"}
{"title": "微信小程序实现拍照界面自定义实现", "author": "Rolan", "time": "2020-5-1 00:10", "content": "最近有一个项目需要对拍照界面进行自定义，之前使用的是html写的项目界面，但是在html中想要自定义拍照界面十分的困难,于是想到了使用微信小程序来实现拍照界面的自定义在微信小程序中实现自定义拍照功能主要使用到如下的组件和API1：camera组件常见的属性有:(1)：mode应用模式，只在初始化时有效，不能动态变更，参数有：normal(相机模式),scanCode(扫码模式) ，默认为normal(2)：device-position摄像头朝向，参数有front(前置),back(后置)，默认为back(3)：flash闪关灯，参数有：auto(自动,手机相机目前的闪光灯状态), on(打开闪光灯), off(关闭闪光灯)，默认为auto(4)：binderror用户不允许使用摄像头时触发事件例如:<camera device-position=\"back\" flash=\"off\" >  \r\n</camera>  2：拍摄照片API(CameraContext.takePhoto)参数说明：(1)quality成像质量,参数有：high(高质量),normal(普通质量),low(低质量)，默认为normal(2)success接口调用成功的回调函数(3)fail接口调用失败的回调函数例如：//拍摄照片  \r\nwx.createCameraContext().takePhoto({  \r\n  quality: 'high',//拍摄质量(high:高质量 normal:普通质量 low:高质量)  \r\n  success: (res) => {  \r\n    //拍摄成功  \r\n    //照片文件的临时文件  \r\n    var file = res.tempImagePath;  \r\n  },  \r\n  fail: (res) => {  \r\n    //拍摄失败  \r\n  },  \r\n})  3:上传拍照文件API(uploadFile)参数说明：url:上传文件的服务器地址filePath:要上传文件资源的路径 (本地路径)name:文件对应的 key，开发者在服务端可以通过这个 key 获取文件的二进制内容formData:HTTP 请求中其他额外的参数success：接口调用成功的回调函数fail：接口调用失败的回调函数例如：wx.chooseImage({  \r\n  success (res) {  \r\n    const tempFilePaths = res.tempFilePaths  \r\n    wx.uploadFile({  \r\n      url: 'https://example.weixin.qq.com/upload', //仅为示例，非真实的接口地址  \r\n      filePath: tempFilePaths\\[0\\],  \r\n      name: 'file',  \r\n      formData: {  \r\n        'user': 'test'  \r\n      },  \r\n      success: (res) => {  \r\n        //上传成功  \r\n      },  \r\n      fail: function(t) {  \r\n        //上传失败  \r\n    },  \r\n    })  \r\n  }  \r\n})  4：根据如上我们就可以实现在微信小程序中自定义拍照页面来实现上传(1)：wxml端：<!--pages/web/index.wxml-->  \r\n<camera binderror=\"handleCameraError\" device-position=\"{{devicePosition}}\" flash=\"off\"  wx:if=\"{{authCamera}}\">  \r\n<cover-view>  \r\n    <cover-image class=\"line\" src=\"/images/outline.png\"></cover-image>  \r\n</cover-view>  \r\n</camera>  \r\n<button type=\"primary\" bindtap=\"takePhoto\">拍照</button>  \r\n<button type=\"primary\" bindtap=\"reverseCamera\">摄像头切换</button>  \r\n<view class=\"error-handler\" wx:if=\"{{!authCamera}}\">  \r\n    <button class=\"nobtn\" openType=\"openSetting\">打开相机授权</button>  \r\n</view>  (2)：js端// pages/web/index.js  \r\nPage({  \r\n  /\\*\\*  \r\n   \\* 页面的初始数据  \r\n   \\*/  \r\n  data: {  \r\n    devicePosition:'back',  \r\n    authCamera: false,//用户是否运行授权拍照  \r\n  },  \r\n  handleCameraError:function() {  \r\n    wx.showToast({  \r\n      title:'用户拒绝使用摄像头',  \r\n      icon: 'none'  \r\n    })  \r\n  },  \r\n  reverseCamera:function(){  \r\n    this.setData({  \r\n      devicePosition: \"back\" === this.data.devicePosition ? \"front\" : \"back\"  \r\n  });  \r\n  },  \r\n  takePhoto:function() {  \r\n    //拍摄照片  \r\n    wx.createCameraContext().takePhoto({  \r\n      quality: 'high',//拍摄质量(high:高质量 normal:普通质量 low:高质量)  \r\n      success: (res) => {  \r\n        //拍摄成功  \r\n        //照片文件的临时文件  \r\n        var file = res.tempImagePath;  \r\n        console.log(file)  \r\n        //上传图片到服务器  \r\n        wx.uploadFile({  \r\n          url: 'XXXX', //上传服务器地址  \r\n          filePath: file,  \r\n          name: 'file',  \r\n          formData: {  \r\n            'test': 'test'  \r\n          },  \r\n          success: (res) => {  \r\n            //上传成功  \r\n          },  \r\n          fail: function(t) {  \r\n            //上传失败  \r\n          },  \r\n        })  \r\n      },  \r\n      fail: (res) => {  \r\n        //拍摄失败  \r\n      },  \r\n    })  \r\n  },  \r\n  /\\*\\*  \r\n   \\* 生命周期函数--监听页面显示  \r\n   \\*/  \r\n  onShow: function () {  \r\n    wx.getSetting({  \r\n      success: (res) => {  \r\n          if (res.authSetting\\[\"scope.camera\"\\]) {  \r\n              this.setData({  \r\n                authCamera:true,  \r\n              })  \r\n          } else {  \r\n            this.setData({  \r\n              authCamera:false,  \r\n            })  \r\n          }  \r\n      }  \r\n    });  \r\n  },  \r\n})  具体相信如下：在接口处理上传文件的流程和正常的表单上传文件流程相同，这里就不多叙述了"}
{"title": "实现微信小程序最新运行环境系列 (初始篇)", "author": "Rolan", "time": "2020-5-1 00:59", "content": "实现微信小程序编译和运行环境系列 (初始篇)前言最近一段时间在研究实现微信小程序和小游戏编译打包和运行环境平台开发。目前基本可以支持微信基础库 2.8.2 功能迭代了。所以想通过记录分享一下自己的认知过程中遇到的一些问题和解决方案来更好的理解小程序设计上的优点和一些不足的地方。在此之前网上有存在开源的一些基于微信基础库版本 1.0 的一些参考。核心作者是由开源大牛 启明兄 的 wept 项目基础上构建的 (目前有幸和启明兄成为同事对这个小程序整体的架构理解帮助了我很多)。由于 wept 的运行环境是基于微信基础库 1.0 的版本上实现之后也不维护了，时间上是 2016 的在后续的更新的版本中新加的一些特性如自定义组件 npm 包很多 api 等开发实现都不支持，最主要是的微信在后续架构中更换底层的通信方式采用了 webstock 的方式等一些其他变化。正文后面我会通过几篇文章来整体描述一下从工具到破解到源码解析和原理到实现的处理流程最开始的时候也在网上找了很多的资料，看了有一些人写的解析微信小程序架构的文章，从中学习了解了很多，但如果想模拟实现出来这么个东西还是有蛮迷糊的，所以我想通过我们所实现的过程来一点点 从现象 看本质 来解析下微信小程序编译和运行原理。凡事对自己多点信心，多坚持下，多学习下，想想我们遇到的问题，当时感觉我，搞不定了，弄不了，最后随着时间的推移和认知的迭代问题总会慢慢消灭掉。本文将先通过全面解析微信开发者工具来知道那些基本的文件和内容组成一一讲述 (从现象 看本质)。在此之前我们通过官方文档可以了解一些内容整个小程序框架系统分为两部分：逻辑层（App Service）和 视图层（View）；小程序提供了自己的视图层描述语言 WXML 和 WXSS；基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统他们两个线程里运行；视图层使用 WebView 渲染，逻辑层使用 JSCore 运行， 视图层和逻辑层通过系统层的 JSBridage 进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。从上述说明中我们可以得知一些重要信息逻辑层（App Service）和 视图层（View） 以及两者之间的通信协调。下面通过微信开发工具来展示说明，小程序逻辑层的 javascript 代码是运行在 NW.js 中，视图层是由 Chromium 60 Webview 来渲染的他们之间是通过 webstock 协议来通信的。以下我们主要是以 mac 环境为主我们先打开 微信开发工具官方 demo 如图：从上图和我们的一些理解我们知道微信小程序的文件格式主要组成：.js 主要页面逻辑；.wxml 页面结构，框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构；.wxss 是一套样式语言，用于描述 WXML 的组件样式；.json 页面配置按照『约定优于配置』的原则。接下来我们先找到本机微信开发者工具应用包里面如图我们后面分析的主要代码都在 package.nw 里面和 core.wxvpkg。这些文件在后面实现过程中都会使用说明用途的。js 文件里面的内容主要是在页面和逻辑层的渲染用，后面将会看到；core.wxvpkg 是这个里面的核心文件破解这个包可以知道很多逻辑可以先给大家看下解压后包的结构：core.wxvpkg 解压代码上传在 unwxvpkg 大家有兴趣可以自己先试试。接下来我们回到开发者工具中打开：微信开发者工具–》调试–》调试微信开发者工具打开调试后我们可以看到的界面如下：从上面的现象我们可以看出他的两层渲染层和逻辑层结构是包含在两个 webview 里面第一个对应的 webview 是渲染层的每个页面都对应一个地址但逻辑层 appservice 只有一个不变的下来我们可以看看这个 webview 里面是个什么东如果我们直接把 view 层的 webview 标签改成 iframe 的话可以看到微信就直接不在里面展示给你页面白屏了如果你更改 appservice 的 webview 的话微信还会给你各种 alert 弹框，反正应该就是不想让你分析他的代码点击确定消都消不了只能重新重启编译了 有点小恶心啊居然不让我们正大光明的看，那我们只能搞一些旁门左道来破坏了我们第一步还是打开：微信开发者工具–》调试–》调试微信开发者工具在控制台输入 复制代码document.getElementsByTagName('webview')\r\n可以看到对应的有 4 个 webview, 我们先要关注的是第一个 webview 因为你点开可以发现第一个对应的就是渲染层的 webview后面的几个可以先不关注，后续我们会详解然后我们执行命令打开第一个 webview: 复制代码document.getElementsByTagName('webview')[0].showDevTools(true,null)\r\n可以看到如图现在我们就可以看到微信页面渲染层的页面结构了(这里说明下本篇文章中文件里面的内容每一个文件的来源和用途，我都会在后续章节中讲解出来 因为里面涉及的内容过多 我怕放在一篇文章里会太长大家看了会厌烦，所以我会分为几篇来说明，后面的 appservice 和 一些基础包和 WAWebview.js WAService.js 以及使用的同步 api 和请求在页面的 appservice.js 等等，在本篇中只会简单描述出来 不做过多讲解，后续会逐步更新)上面的 webview 可以找到对应的页面层的结构，那么 appservice 要怎么找到呢？其实最简单的我们直接在首页里面的控制台打 document 就可以直接看到展示的逻辑层代码(我的做法是从写了微信的 alert 和基础库的一些文件都可以看到这个结构)注意点在微信小游戏里面微信重写了 window 和 document 对象 所以不能直接按照我们平常操作页面那样使用接下面我们看下微信小程序的基础库库文件方法是我们在首页控制台里面输入 openVendor()我们可以看到弹出的文件系统，这里面对应的就是你选择本地的详情 ==》调试基础库 ==》选择基础库版本.wxvpkg 文件就是每个基础库版本的包我们，解压这个包我们可以看到他的组成；wcc 可执行程序，用于将 wxml 转为 view 模块使用的 js；wcsc 可执行程序，用于将 wxss 转为 view 模块使用的 css。.wxvpkg 包里面这个基础库文件的 WAWebview.js 和 WAService.js，对应这两个 webview 里面的 js 引用你可以仔细观察下.wxvpkg 文件解包后的格式：解压.wxvpkg 格式包的代码地址 github对于 wcc 和 wcsc 源码现在没必要去研究他，但我们可以通过脚本劫持方法可以看到他运行了什么命令操作这里告诉大家一个方法劫持他的运行命令找到微信开发者工具 wcc 和 wcsc 的地方然后新建两个同名的脚本，然后把原文件从命名，然后重启微信开发者工具 一定要重启不然不生效wcc wcsca 劫持脚本代码地址 github然后我们到首页控制台还是输入 openVendor() 可以看到输出的文件从上面这个图就可以看出下面这个图里面我们可以认知到一些信息首次加载的时候 wcc 执行了 -ds -d - xc…和 -ds -d - cc…结构的命令可以看到微信首次把所有.wxml 都执行了可以看到参数里面有个数字其实他对应的有几种.wxml 文件形式向只存在.wxml 和自定义组件等一些格式他是没计算在内的-xc -cc 其实对应就是下面图两个逻辑层和渲染层里面的 js 方式我发现当我们修改一个.wxml 里面一点改动的时候，微信又会全部从新编译执行这些命令很耗时这点其实可以改进的。另一个微信开发者工具感觉做的不友好的地方是大于 500KB 的 javascript 文件不做给你做 es6 转换和压缩，就算你设置了微信也不会给你转，可以在 source 里面的资源可以看出。wcc 执行的命令最终生成的就是逻辑层和渲染层的 $gwxc() 方法里面的 js 代码，大家可以自己手动测试下就会发现。wxss 生成的主要是渲染层 eval() 这一坨代码本篇只是简单描述了一些关键文件的描述。后面我会对关键文件进行一一分析描述下他具体做了什么，为什么用到它。下一篇会给大家带来渲染层和逻辑层的具体页面文件内容结构解析，以及 webstock 通信架构在微信开发者工具里面的运用，可以先给大家看下。其实他们之间的协调工作以及公开对外的 wx. 对象上面的 api 都是通过 websocket 协议消息实现的。"}
{"title": "微信小程序|动态时钟", "author": "Rolan", "time": "2020-5-2 00:02", "content": "问题描述近期，网络上流行了一个“时间管理”的梗，想要做好时间管理，清楚把握时间才是关键点，那么借着这个“时间管理”，来介绍一个小程序实现动态时钟的案例吧。效果图：图2.1 动态时钟解决方案1、wxmlwxml代码十分简单，只需要一个canvas组件便能实现一个时钟外圆形状。<canvas  canvas-id='myCanvas'></canvas>2、jsjs部分主要针对于Math相关属性的应用。（1）指针的配置：指针都要对运动路径进行适当的设置，需要利用Math.PI属性来对不同指针转动角度进行配置。比如，秒针转动角度Math.PI/30表示将整个圆(360°)平分为60份，即一秒转过6°；分针、时针的计算同理。指针转动到某个点，存在一个坐标，坐标的计算需要利用Math.sin、Math.cos属。（2）方法为：假设圆心坐标为(a,b)，则x=a + Math.sin(angle * (Math.PI / 180)) * r ；y=b -Math.cos(angle * (Math.PI / 180)) * r 。（3）表盘、数字点：arc(x,y,半径,起始位置，结束位置)3、代码示例：（1）先定义将要直接执行的几个函数  onShow:  function (e) {     setInterval(show, 1000); //每秒执行1次     function show() {       secshow() //秒针       minshow() //分针       houshow() //时针       backshow() //表盘       numbershow() //数字       ctx.draw()     }   },（2）秒针function secshow() {   var now = new Date()   var sec = now.getSeconds()   //角度弧度   var angle = sec * Math.PI / 30   var x = 100 * Math.sin(angle) + 150   var y = 150 - 100 * Math.cos(angle)   ctx.beginPath() #开始路径  ctx.setLineWidth(5)  //线条粗细   ctx.setStrokeStyle('black')   ctx.moveTo(150, 150)   ctx.lineTo(x, y) //指针指向   ctx.closePath() //返回初始状态   ctx.stroke() //描出点的路径}（3）分针function minshow() {   var now = new Date()   var min = now.getMinutes()   var sec = now.getSeconds()   var angle = (min + sec / 60) * Math.PI / 30   var x = 80 * Math.sin(angle) + 150   var y = 150 - 80 * Math.cos(angle)   ctx.beginPath()   ctx.setLineWidth(5)   ctx.setStrokeStyle('black')   ctx.moveTo(150, 150)   ctx.lineTo(x, y)  ctx.closePath()   ctx.stroke()}（4）时针function houshow() {   var now = new Date()   var hou = now.getHours()   hou = hou % 12  //24小时制，取余数   var min = now.getMinutes()   var sec = now.getSeconds()   var angle = (hou + min / 60 + sec / 3600) * Math.PI / 6   var x = 50 * Math.sin(angle) + 150   var y = 150 - 50 * Math.cos(angle)   ctx.beginPath()   ctx.setLineWidth(8)   ctx.moveTo(150, 150)   ctx.lineTo(x, y)   ctx.closePath()   ctx.stroke()}(5)表盘及数字点function backshow() {   ctx.beginPath()  ctx.setLineWidth(3)   ctx.arc(150, 150, 110, 0, 2 * Math.PI)   ctx.closePath()   ctx.stroke()} function numbershow() {   ctx.beginPath()   ctx.setFontSize(20)   for (var i = 1; i < 13; i++) {     var angle = i * Math.PI / 6     var x = 100 * Math.sin(angle) + 145     var y = 158 - 100 * Math.cos(angle)     ctx.fillText(i, x, y)  }}"}
{"title": "钉钉小程序 之 自定义组件的使用，以及父组件与子组件(自定义组件)传值 ...", "author": "Rolan", "time": "2020-5-5 00:09", "content": "本机环境自定义组件（子组件）页面中引入（父组件引入子组件）父组件（使用自定义组件的页面）传值给子组件子组件（自定义组件）传值给父组件备注一、本机环境本机系统： Mac\r\n小程序开发者工具:  1.5.7\r\n复制代码二、自定义组件（子组件）子组件中：项目的根目录下！！创建自定义组件在对应 json 文件中定义 component 属性如图在根目录 的 `components` 目录（目录名自定义）下存放自定义组件\r\n复制代码三、页面中引入（父组件引入子组件）父组件中：路径引入在对应页面下添加 json 文件中定义 usingComponentsaxml 文件中直接使用如图 \r\n复制代码（图 3.1）（图 3.2）四、父组件（使用自定义组件的页面）传值给子组件子组件中：通过属性 props 传递值 numIndex在 data 中定义对应的值 itemIndex在生命周期 didMount 中修改对应的值如图 \r\n复制代码（图 4.1）五、子组件（自定义组件）传值给父组件子组件通过函数参数，传递值给父组件子组件通过 props 属性传递函数，但是注意:warning:，函数名必须以 on 开头父组件中给对应函数属性，传递对应的方法如图 子组件\r\n复制代码（图 5.1）如图 父组件\r\n复制代码（图 5.2）备注第 五 步尴尬了很久，因为函数名 不是以 on 开头的！！！ ，过分，开发文档的提示，可不可以加个其他颜色呐！！！微笑:blush:，参考 这里 ：写给自己的随笔，有问题欢迎指出"}
{"title": "小程序解析excel表格并存储到云数据库", "author": "Rolan", "time": "2019-12-4 00:52", "content": "最近一直比较忙，答应大家的小程序解析excel一直没有写出来，今天终于忙里偷闲，有机会把这篇文章写出来给大家了。老规矩先看效果图效果其实很简单，就是把excel里的数据解析出来，然后存到云数据库里。说起来很简单。但是真的做起来的时候，发现其中要用到的东西还是很多的。不信。。。。 那来看下流程图流程图通过流程图，我看看到我们这里使用了云函数，云存储，云数据库。 流程图主要实现下面几个步骤1，使用wx.chooseMessageFile选择要解析的excel表格 2，通过wx.cloud.uploadFile上传excel文件到云存储 3，云存储返回一个fileid 给我们 4，定义一个excel云函数 5，把第3步返回的fileid传递给excel云函数 6，在excel云函数里解析excel，并把数据添加到云数据库。 可以看到最神秘，最重要的就是我们的excel云函数。 所以我们先把前5步实现了，后面重点讲解下我们的excel云函数。一，选择并上传excel表格文件到云存储这里我们使用到了云开发，使用云开发必须要先注册一个小程序，并给自己的小程序开通云开发功能。这个知识点我讲过很多遍了，还不知道怎么开通并使用云开发的同学，去翻下我前面的文章，或者看下我录的讲解视频《5小时入门小程序云开发》1，先定义我们的页面 页面很简单，就是一个按钮如下图，点击按钮时调用chooseExcel方法，选择excel对应的wxml代码如下2，编写文件选择和文件上传方法上图的chooseExcel就是我们的excel文件选择方法。 uploadExcel就是我们的文件上传方法，上传成功以后会返回一个fildID。我们把fildID传递给我们的jiexi方法，jiexi方法如下3 把fildID传递给云函数二，解下来就是定义我们的云函数了。1，首先我们要新建云函数如果你还不知道如何新建云函数，可以翻看下我之前写的文章，也可以看我录的视频《5小时入门小程序云开发》 如下图所示的excel就是我们创建的云函数2，安装node-xlsx依赖库如上图所示，右键excel，然后点击在终端中打开。 打开终端后， 输入 npm install node-xlsx 安装依赖。可以看到下图安装中的进度条这一步需要你电脑上安装过node.js并配置npm命令。 3，安装node-xlsx依赖库完成三，编写云函数我把完整的代码贴出来给大家const cloud = require('wx-server-sdk')cloud.init()var xlsx = require('node-xlsx');const db = cloud.database()exports.main = async(event, context) => {  let {    fileID  } = event  //1,通过fileID下载云存储里的excel文件  const res = await cloud.downloadFile({    fileID: fileID,  })  const buffer = res.fileContent  const tasks = [] //用来存储所有的添加数据操作  //2,解析excel文件里的数据  var sheets = xlsx.parse(buffer); //获取到所有sheets  sheets.forEach(function(sheet) {    console.log(sheet['name']);    for (var rowId in sheet['data']) {      console.log(rowId);      var row = sheet['data'][rowId]; //第几行数据      if (rowId > 0 && row) { //第一行是表格标题，所有我们要从第2行开始读        //3，把解析到的数据存到excelList数据表里        const promise = db.collection('users')          .add({            data: {              name: row[0], //姓名              age: row[1], //年龄              address: row[2], //地址              wechat: row[3] //wechat            }          })        tasks.push(promise)      }    }  });  // 等待所有数据添加完成  let result = await Promise.all(tasks).then(res => {    return res  }).catch(function(err) {    return err  })  return result}上面代码里注释的很清楚了，我这里就不在啰嗦了。 有几点注意的给大家说下1，要先创建数据表2，有时候如果老是解析失败，可能是有的电脑需要在云函数里也要初始化云开发环境四，解析并上传成功 如我的表格里有下面三条数据点击上传按钮，并选择我们的表格文件上传成功的返回如下，可以看出我们添加了3条数据到数据库添加成功效果图如下到这里我们就完整的实现了小程序上传excel数据到数据库的功能了。再来带大家看下流程图如果你有遇到问题，可以在底部留言，我看到后会及时解答。后面我会写更多小程序云开发实战的文章出来。也会录制本节的视频出来，敬请关注。"}
{"title": "当小程序的flex布局遇到button时，justify-content不起作用的原因及解决方案 ...", "author": "Rolan", "time": "2019-12-5 00:31", "content": "当小程序的flex布局遇到button时，justify-content不起作用的原因及解决方案 在做小程序的时候，要实现下面的搜索历史界面下面的搜索很明显的想到是用flex布局，然后把justify-content设置为justify-content: flex-start; 代码如下：<view class=\"flex\"><button class=\"item\">1</button><button class=\"item\">2</button><button class=\"item\">3</button><button class=\"item\">4</button><button class=\"item\">5</button><button class=\"item\">6</button><button class=\"item\">7</button></view>.flex{  display: flex;  flex-wrap: wrap;   justify-content: flex-start;}.flex .item{  width: 216rpx;  background-color: red;  margin-bottom: 34rpx;}可效果却不尽人意，发现justify-content不起作用，无论怎么设置都是space-around的效果。 经过排查，发现原因是小程序button中的默认样式中的margin-left: auto;margin-right: auto;所引起的。flex 格式化上下文中，在通过 justify-content 和 align-self 进行对齐之前，任何正处于空闲的空间都会分配到该方向的自动 margin 中去。参考自探秘 flex 上下文中神奇的自动 margin原因找到了，具体修改就容易多了，我们可以覆盖button的margin-left和margin-right的默认值，或者在button外面包裹一层view。在遇到这个问题之前，我也没想到过flex和margin之间还能这么用，涨姿势了"}
{"title": "小程序不同页面的异步回调，callback和promise的使用讲解", "author": "Rolan", "time": "2019-12-5 00:23", "content": "发个扫盲贴，大神请绕道。最近好多同学问我如何再请求数据成功后直接使用数据。我们通常的做法就是在请求成功后，再调用我们定义的方法，进而使用数据。如下代码  onLoad() {    let that=this    wx.cloud.database().collection(\"users\").get({      success(res) {        that.setData(res.data)      },      fail(res) {      }    })  },  showData(dataList) {    //.........做数据处理  },我们这样写其实也没什么不对，但是如果数据请求和使用是在两个不同的页面呢。 比如我们在app.js里请求位置，获取用户信息。然后在首页index.js里要使用这些数据，那么我们这么写就有问题了。下面就来教大家两种方式来很好的解决这个问题。一，通过callback回调。先看下代码，然后我再具体给大家讲解下原理。app.js里定义如下方法然后再index.js 里这么使用这时候，其实就可以看到了，我们在首页index.js里调用了app.js里的请求数据的方法，并且可以在index.js里直接使用数据。原理讲解 原理其实很简单，就是我们在app.js里的获取数据的方法里定义一个参数。而这个参数和普通参数唯一不同的地方，就是这个参数是个function方法我们上图的callback参数，其实就是下图 function(result){}把function方法作为一个参数传递进去的目的，就是为了下面的回调。我们这个callBack参数，可以在请求数据成功或者失败的时候作为一个方法调用。这样就可以把请求到的数据，回传回去了。 讲的有点绕，不知道大家有没有被绕晕。这在java开发中，其实就相当于监听者模式。说白了就是在一个页面里监听另外一个页面的动作，如获取数据成功，当监听到数据获取成功这个动作以后，就可以直接把数据回传回来了。 如果觉得这种方法有点绕，不好使用，我们就用下面的这个第二种方式。二，promisepromise的好处就是可以不用那个层层传递，不用那么绕。 还是先看代码，后面结合代码给大家讲下原理 app.js里定义如下方法index.js里这么调用用句通俗的话说，就是通过promise让我们的数据请求和使用看上去是在同一个页面完成。怎么实现的呢 1，在app.js里把数据请求封装到promise里，然后把promise返回到我们的首页index.js里 2，在首页里使用这个promise 实现数据的获取和使用。 在具体些就是下面这几步 promise基础用法1、new 一个Promise对象 2、请求数据的异步代码写在promise的函数中 3、promise接受两个参数，一个resolve(已成功success)，一个reject(已失败fail) 4、promise有三种状态pendding(进行中，当new了promise就是pendding的状态)、fulfilled(已成功)、rejected(已失败)，当成功的时候调用resolve将状态改为已成功，当失败的时候调用reject将状态改为已失败，一旦状态发生改变之后，状态就凝固了，后面就无法改变状态了，成功会将成功的数据返回，失败会将失败的信息返回。 5、在需要获取数据的地方通过promise.then()的方式获取，这里面接受两个参数，都是匿名函数，第一个是接受成功的函数，第二个是失败时候的函数好了，到这里我们两种不同页面的异步回调就给大家将完了。代码就完整的给大家贴出来吧，方便大家日后使用app.js//app.jsApp({  //第二种，通过promise  promiseGetData() {    let promise = new Promise(function(success, fail) {      wx.cloud.database().collection(\"users\").get({        success(res) {          success(res)        },        fail(res) {          fail(res)        }      })    })    return promise;  },  //第一种，通过callback的方式来实现回调  callBackGetData(callBack) {    wx.cloud.database().collection(\"users\").get({      success(res) {        callBack(res)      },      fail(res) {        callBack(res)      }    })  },})index.js// 异步调用，callbackconst app = getApp()Page({  clickBtn() { //按钮点击    //callback方式    // app.callBackGetData(function(result) {    //   console.log(\"dataList\", result)    // })    //promise方法    let promise = app.promiseGetData()    promise.then((res) => { //获取成功的结果，res中存着获取成功时的数据      console.log(\"成功\", res)    }, (error) => { // 获取数据失败时      console.log(\"失败\", error)    })  },})"}
{"title": "微信小程序|CSS的内边距和圆框", "author": "Rolan", "time": "2019-12-9 00:02", "content": "本文首发于微信公众号： \"算法与编程之美\"，欢迎关注，及时了解更多此系列文章。问题描述在制作小程序的时候会经常用到浮动来设计各种组件的排版，微信小程序对排版的要求很高。 光有浮动是远远不够的，如果一个板块内的组件过多就会变得混乱。 所以就需要用设置内边框来调整位置。 微信小程序中会有很多的头像设置，所以就会用到圆框。 那么如何来设置css盒子的内边框和头像的圆框呢？解决方案跟网页一样小程序也是用很多标签来定义的。 需要用css盒子来设置解决问题，并调用来实现问题。（1）内边距我们需要用到margin这个标签代表内边距，用rpx来设置距离单位。 在.wxss中设置，然后在wxml中调用就可以了。margin-left： 离左边的距离margin-right： 离右边的距离margin-top： 离上边的距离margin-bottom： 离下边的距离margin-top: 100rpx;margin-left: 10rpx（2）框 用border来定义框线的宽度，用width和heigth来设置框的长宽。solid来定义颜色。 跟内边距一样在.wxss中设置，然后在wxml中调用。.view4{margin-top: 0rpx;margin-left: 0rpx;width: 800rpx;height: 115rpx;border: 5rpx solid whitesmoke}（3）圆框border-radius： rpx定义圆框。.view3{margin-top: 350rpx;margin-left: -190rpx;height: 60rpx;width: 220rpx;float: left;background-color: rgb(131, 178, 240);border-radius: r5px}（4）圆框头像跟上面的圆框一样也是用border-radius来定义，但不同的是后面的设置： %。 就是一个圆的弧度不同，rpx是将框的四角成为圆弧而%是成为一个圆。.view1{float: left;margin-left: 290rpx;margin-top: 120rpx;border-radius: 50%}结语对标签的正确使用和调用， 最麻烦的是对标签后面的单位设置，必须充满耐心，你需要不断地调才能调到你需要的位置，才能使界面美观。END实习编辑 | 王文星责 编 | 江汪霖where2go 团队微信号： 算法与编程之美"}
{"title": "解决小程序渲染复杂长列表，内存不足问题", "author": "Rolan", "time": "2019-12-9 00:12", "content": "问题回顾：我们有一个列表展示页，是无限瀑布流式的，展示的元素我们封装成了单个组件，暂且叫它Item组件。这个瀑布流包含若干个Item组件，并且这个Item组件也比较复杂，包含各种展示样式（根据不同类型，大概有9种吧，反正渲染节点很多），在进行滑动的过程中，item大概加载30-40个以后，就会造成小程序内存不足而退出，蓝瘦香菇......【干货在最后，小程序代码片段奉上】\r\n\r\n解决思路：\r\n将超出屏幕一定部分的列表内的组件进行不渲染的处理（也就是用wx:if卸载掉组件），当到达渲染临界点时再开始渲染；保证每次少量的数据展示。\r\n\r\n我们的项目中是保持15条Item，我们是每次分页请求5条，按照前5条，中间5条和后5条来划分，如果不在这个范围，则用一个等高度的骨架代替，并且卸载这些组件\r\n\r\n初期实现方式（后面有更优化的方式）\r\n使用曝光监听，当一个Item曝光时，记录Item高度，并放到数组里面，作为骨架的填充高度，如果已经记录了高度，则不再重复记录；曝光时向外传递一个当前渲染范围的中心值（比如当前Item所属页码，或者当前Item索引），以此进行处理；\r\n\r\n这里有一点要注意，如果你的列表item组件比较复杂，需要在ready的时候将记录的高度设置为item最小高度，不然组件重新装载时会有一定的渲染时间，在临界点会造成跳屏【此处已经通过骨架组件解决，可以忽略，只是作为踩坑记录】\r\n\r\n此时优化点\r\n\r\n为避免频繁setData和渲染，做了防抖函数，时间是600ms\r\n\r\n此时缺点\r\n\r\n滑动特别快时，会出现白屏，是因为曝光监听是在组件里面，而超快速滚动时，组件没有装载进来，也无法进行曝光监听，所以无法触发，这里考虑用骨架组件进行二次监听曝光\r\n\r\n优化迭代\r\n\r\n将骨架组件作为外壳套在Item外面（用slot），并对骨架进行监听曝光，可以解决上面缺点\r\n给骨架组件做一个常规骨架屏样式，而不是纯白色，看起来更优雅\r\n\r\n继续发现问题\r\n经过一系列的实践，上面的方案有些问题，其中最麻烦的就是，需要对外传递一个当前index，然后控制前后数据展示；这里对于每个用到skeleton组件的页面来说，都要重复的写一个方法来承接这个index，然后渲染页面对应的数据。\r\n优化\r\n依然是监听skeleton曝光，这里监听的方案变为出现在屏幕上下n屏的内容块进行展示，此范围外的内容块就卸载掉。\r\n如图所示\r\n\r\n核心代码\r\n     // 修改了监听是否显示内容的方法，改为前后showNum屏高度渲染\r\n     // 监听进入屏幕的范围relativeToViewport({top: xxx, bottom: xxx})\r\n      let info = SystemInfo.getInfo() //获取系统信息\r\n      let { windowHeight = 667 } = info.source.system\r\n      let showNum = 2 //超过屏幕的数量，目前这个设置是上下2屏\r\n      let listItemContainer = this.createIntersectionObserver()\r\n      listItemContainer.relativeToViewport({ top: showNum * windowHeight, bottom: showNum * windowHeight })\r\n        .observe(`#list-item-${this.data.skeletonId}`, (res) => {\r\n        \t// 此处来控制slot展示，详见代码片段\r\n        })\r\n       \r\n复制代码干货\r\n话不多说，干货放后面，点击获取代码片段\r\n最后，还是尽量减少节点数，优化代码"}
{"title": "实战：在小程序中获取用户所在城市信息", "author": "Rolan", "time": "2019-12-19 00:18", "content": "最近在做自己的小程序《看啥好呢》，这个小程序是使用云开发的方式开发的，功能特别简单，就是获取豆瓣、大麦网的数据展示，虽然功能简单，但还是记录下开发过程和一些技术点，大约会有两篇博文产出，这是第二篇。 GitHub地址背景在《看啥好呢》中有个本地好看 Tab，进去后会获取用户当前所在城市，然后显示该城市的数据，并且显示在导航栏和 Tab上。微信小程序中，我们可以通过调用 wx.getLocation() 获取到设备当前的地理位置信息，这个信息是当前位置的经纬度。如果我们想获取当前位置是处于哪个国家，哪个城市等信息，该如何实现呢？微信小程序中并没有提供这样的API，但是没关系，有 wx.getLocation() 得到的经纬度作为基础就够了，其他的，我们可以使用其他第三方地图服务可以来实现，比如腾讯地图或百度地图的API。所以整个步骤就是：wx.getLocation\r\nreverseGeocoder(options:Object)\r\n在小程序中获取当前的地理位置在小程序中，调用 wx.getLocation ，使用前需要用户授权 scope.userLocation ，代码如下checkAuth(callback) {\r\n  wx.getSetting({\r\n    success(res) {\r\n      if (!res.authSetting\\['scope.userLocation'\\]) {\r\n        wx.authorize({\r\n          scope: 'scope.userLocation',\r\n          success() {\r\n            wx.getLocation({\r\n              type: 'wgs84', \r\n              success(res) {\r\n                callback(res.latitude, res.longitude)\r\n              }\r\n            })\r\n          }\r\n        })\r\n      }\r\n    }\r\n  })\r\n}其中 type 的取值可以为：wgs84 意思返回 gps 坐标gcj02 返回可用于 wx.openLocation 的坐标。运行后会提示如下信息，还需要在 app.json 中配置 permission 字段查询 文档 后得知，得知需要如下配置\"permission\": {\r\n    \"scope.userLocation\": {\r\n      \"desc\": \"你的位置信息将用于小程序位置接口的效果展示\"\r\n    }\r\n}desc 用于在弹出的授权提示框中展示，如下允许后即可获取接口返回的信息，此过程会在右上角胶囊按钮上显示箭头图标{\r\n    accuracy: 65\r\n    errMsg: \"getLocation:ok\"\r\n    horizontalAccuracy: 65\r\n    latitude: 30.25961    // 纬度，范围为 -90~90，负数表示南纬\r\n    longitude: 120.13026    // 经度，范围为 -180~180，负数表示西经\r\n    speed: \\-1\r\n    verticalAccuracy: 65\r\n}latitude 和 longitude 即是我们需要的两个字段腾讯地图接口逆地址解析以腾讯地图为例，我们可以去腾讯地图开放平台注册一个账号，然后在它的管理后台创建一个密钥(key)，以及进行KEY设置，按照 微信小程序JavaScript SDK 入门及使用限制文档在 KEY设置的启用产品中，勾选 WebServiceAPI，选择签名校验方式，因为我是使用云开发的方式，所以没有什么域名也没有授权IP。这部分代码逻辑如下import QQMapWX from '../../scripts/qqmap-wx-jssdk.min.js'\r\nlet qqmapsdk\r\nPage({\r\n    onLoad: function (options) {\r\n      // 实例化API核心类\r\n      qqmapsdk = new QQMapWX({\r\n         key: '开发密钥（key）'    // 必填\r\n      });\r\n      this.checkAuth((latitude, longitude) => {\r\n         // https://lbs.qq.com/qqmap\\_wx\\_jssdk/method-reverseGeocoder.html\r\n         qqmapsdk.reverseGeocoder({\r\n           sig: 'KEY设置中生成的SK字符串',    // 必填\r\n            location: {latitude, longitude},\r\n            success(res) {\r\n                wx.setStorageSync('loca\\_city', res.result.ad\\_info.city)\r\n            },\r\n            fail(err) {\r\n               console.log(err)\r\n               wx.showToast('获取城市失败')\r\n            },\r\n            complete() {\r\n               // 做点什么\r\n            }\r\n         })\r\n      })\r\n    }\r\n}）reverseGeocoder 接口返回的结果，这里面的字段比较多，详细可以看接口文档，里面好几个字段可以取到城市，其中 ad_info 是行政区划信息，我就取这里面的 city 了。全文完。关注公众号，第一时间接收最新文章。如果对你有一点点帮助，可以点喜欢点赞点收藏，还可以小额打赏作者，以鼓励作者写出更多更好的文章。"}
{"title": "基于微信小程序picker组件开发的时间自定义功能", "author": "Rolan", "time": "2019-12-23 00:33", "content": "背景需求：最近接了一个需求，需要做一个类似电影院的选座功能，不同的是需要自己选择日期，预定时间段，然后根据日期+时间段查询座位信息，结合图片说下需求。a、日期组件可选2天内（当天+第二天）。进入页面默认展示当天日期，预定开始时间为当前时间，预定结束时间为开始时间之后30分钟。b、日期确定后才能选择预定开始时间，开始时间以及结束时间我这边是固定的时间点（08:30-22:30）。开始时间分钟段以5分钟为倍数设置往后推算展示，其余时段不显示。如果当前时间为22:00，则不展示当天时间，自动切换到第二天。c、选择预定结束时间。结束时间已开始时间为标记，半小时为倍数生成规则，其余时段不显示。两个时间段确定以后算出预定时长（小时为单位），并调后端接口查询座位信息。"}
{"title": "微信小程序文本展开/收起功能", "author": "Rolan", "time": "2019-12-19 00:44", "content": "微信小程序中，有时候文本需要实现这样的功能 1、文本超过n行显示省略号 2、省略时，显示 展开/收起 按钮 3、文本不超过n行时，不显示省略号和展开/收起按钮 实现思路文本过长显示省略号、展开和收起功能，通过css样式即可实现 判断是否显示展开/收起按钮： 通过嵌套元素，可以实现text既显示省略号，其高度又是全显示时的高度 通过SelectorQuery选择器，获取text及其父元素的高度，判断text高度是否超过其父元素高度，决定是否显示展开/收起按钮即可代码wxss.frame {  width: 100%;  max-height: 206rpx;  text-align: left;  display: -webkit-box;  overflow: hidden;  text-overflow: ellipsis;  word-wrap: break-word;  white-space: normal !important;  -webkit-line-clamp: 3;  -webkit-box-orient: vertical;}.nofold {  display: block;  text-overflow: unset;  -webkit-line-clamp: unset;  max-height: unset;}frame样式设置最大高度，超过3行后出现省略号。overflow为hidden，使得text的超出父元素部分隐藏掉。nofold样式则将最大高度、出现省略号的行数去除，以展示全文。wxml<view id=\"frame\" class='frame {{fold == false ? \"nofold\":\"\"}}'>    <text id=\"content\">{{detail}}</text></view>wxml中，在view元素中嵌套text元素。样式写在view中，text不加任何样式（重要）。分别写上id，方便js代码获取其尺寸信息。 javascriptvar query = this.createSelectorQuery();query.select('#content').boundingClientRect();query.select('#frame').boundingClientRect();query.exec(function(res) {  if (res[0] && res[0].height) {    if (res[0].height > res[1].height) {      self.setData({        fold: true,      });    } else {      self.setData({        fold: null,      });    }  }})js代码中，通过选择器获取两者的高度，如果text高度高于view，则说明有省略文本，显示展开/收起按钮。 js的选择器如果是写在onshow/onload方法中，最好加上延迟，以防止出现判断时元素尚未渲染出来的情况。"}
{"title": "使用阿里云函数计算构建小程序", "author": "Rolan", "time": "2019-12-23 00:43", "content": "在用户使用HyperMotion产品过程中，用户可以通过扫描产品中二维码方式，自助进行Licnese申请。用户提交申请后，请求将发送到钉钉流程中。完成审批后，后台服务将自动根据用户的特征码、申请的数量、可使用的时间将生成好的正式Licnese发送到客户的邮箱中。在原有设计中，使用了Python Flask提供WEB界面，后台使用Celery异步的将用户请求发送至钉钉中，之后采用轮询方式监控审批工单状态，当工单完成审批后，将生成好的License发送至客户提供的邮箱中。实现的效果：这种方式虽然可以满足需求，但是在使用过程中也发现有如下痛点：1、由于对于可用性要求比较高，所以将整套应用以容器化方式部署在云主机上，程序高可用性依赖于底层的平台，基于成本考虑并没有在多可用区进行部署。2、当业务变化时，需要专人将容器从本地容器库上传后进行更新，更新速度慢，敏捷性低。3、需要专人对操作系统层进行维护，并且由于该云主机还运行了其他程序，所以管控上也存在安全风险。基于以上出现的问题，决定对原有二维码程序进行重构，并重新部署在阿里云函数计算服务上。1、第一阶段的改造主要是将二维码扫描程序移植到函数计算服务中。2、第二阶段的改造主要是将发送二维码程序改造为函数计算服务，使用钉钉流程接口中的Callback方法调用该接口，在审批结束后触发发送License流程。2、函数计算服务——无服务，零运维最早接触Serverless的雏形是在2011年开发Cloud Foundry项目时，当时留下一个非常深的印象就是把写好的应用直接上传就完成了部署、扩展等。但是当时Cloud Foundry有一个非常大的局限性，受限于几种开发语言和框架。记得当时的Cloud Foundry只支持Node.js、Python、Java、PHP、Ruby on Rails等，脱离了这个范围则就无法支持，所以当时我其实对这种形态的应用场景存在很大的疑问。这种困惑直到2013年Docker的出现而逐步解开，Docker的出现让开发语言、框架不再是问题，巧妙的解决了Cloud Foundry上述局限性。但是Docker毕竟只是一种工具形态，还不能称得上是平台，紧接着k8s的出现弥补了这一空白，使得Docker从游击队变成了正规军。在这个发展过程中我们不难看出，软件领域发展出现了重大变革，从服务器为王逐渐演进到应用为王的阶段。如果说虚拟化改变了整个物理机的格局，那么无服务化的出现则改变了整个软件开发行业。由于网上各种文档太多了，这里就不对Serverless基本概念进行介绍了，借用一张图说明下。另外还有一点，我们从这里面看到IT行业里的某些岗位，注定要消失的，比如传统运维。3、应用架构整个架构上，分为两个函数计算服务完成：二维码前端：主要用于显示页面，并承担HTTP请求转发代理的角色，将请求转发至二维码后端，发给钉钉，采用HTTP触发器，允许公网访问。二维码后端：用于将用户请求发送给钉钉，该部分服务仍然采用HTTP触发器，不同于前端，该服务是不允许公网直接访问的，但是需要配置NAT网关，通过网关访问钉钉，实现固定IP访问钉钉的效果。从逻辑上讲，整个应用并不复杂，但是在实际使用时遇到最大的问题来自钉钉白名单。由于函数服务对外连接的IP并不固定，所以无法在钉钉中添加，那么就要求函数服务对外连接的IP地址一定要固定。社区中提供的方法主要分为：ECI（运行Nginx充当Proxy），优势是便宜，劣势是高可用性需要自己维护NAT网关，优势是高可用性，劣势是比ECI贵4、构建过程由于篇幅原因，这里只介绍关键步骤。4.1 构建模板为了后续管理和扩展方便，选用了阿里云函数计算中使用flask-web模板进行构建，同时可以将前端静态文件模板存放于项目下（出于统一管理的需要，也可以存放于阿里云的OSS中，作为静态网站发布）。前端我们使用flask-web作为模板创建函数，后端我们直接采用最简单的HTTP函数。函数入口配置，及触发器配置：服务配置，包含公网访问权限，专有网络配置，日志配置，权限配置。前端服务需要公网访问权限，不需要专有网络配置，需要的权限为：AliyunLogFullAccess。后端服务不需要公网访问权限，但是需要配置好的NAT映射的专有网络，由于函数服务在北京2区中在cn-beijing-c和cn-beijing-f，所以在新建交换机时需要使用这两个区。还需要选择安全组，由于出方向并没有明确禁止，所以不需要特别的安全组规则设定。需要的权限为：AliyunLogFullAccess/AliyunECSNetworkInterfaceManagementAccess。配置好后，通过导出功能，分别下载前端和后端代码和配置，在本地进行开发调试。4.2 前端开发我们的前端采用Vue.js进行开发，在main.py同级新建templates目录。Vue编译好的静态文件可以放入该目录中，后续Flask会加载该文件作为入口文件。├── templates\r\n│   ├── index.html\r\n│   ├── static\r\n├── main.py\r\n# main.py sample\r\nfrom flask import render_template\r\n\r\nLICENSE_URL = \"https://[x](https://.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xxxx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xxxxxx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license).cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license\"\r\n\r\n@app.route('/qr_code', methods=['GET'])\r\ndef index():\r\n      return render_template('index.html')\r\n\r\n      @app.route('/qr_code/license', methods=['POST'])\r\n      def create():\r\n            payload = request.json\r\n                resp = requests.post(LICENSE_URL,\r\n                                                 json=payload,\r\n                                                                              headers=DEFAULT_HEADERS)\r\n                return make_response(resp.text, resp.status_code)\r\n4.3 后端开发后端的开发较为简单，实现一个函数支持POST请求，将转发的结果发送至钉钉即可。4.4 本地调试阿里云在本地开发时提供了fun应用部署和开发工具，详细使用方法见： https://help.aliyun.com/document_detail/64204.html 。安装funnpm config set registry [https://registry.npm.taobao.org](https://registry.npm.taobao.org/) --global\r\nnpm config set disturl [https://npm.taobao.org/dist](https://npm.taobao.org/dist) --global\r\n\r\nnpm install @alicloud/fun -g\r\n配置funfun config\r\n\r\n(venv) [root@ray-dev test_func]# fun config\r\n? Aliyun Account ID xxxxxxxx\r\n? Aliyun Access Key ID ***********r5Qd\r\n? Aliyun Access Key Secret ***********kCCi\r\n? Default region name cn-beijing\r\n? The timeout in seconds for each SDK client invoking 10\r\n? The maximum number of retries for each SDK client 3\r\n? Allow to anonymously report usage statistics to improve the tool over time? Yes\r\nHttp Trigger本地运行fun local start\r\n部署fun deploy\r\n4.5 配置域名解析部署完成后有一点需要特别注意，必须要绑定域名，并且设定必要的路由。如果在没有绑定域名的情况下，服务端会为 response header中强制添加 content-disposition: attachment字段，此字段会使得返回结果在浏览器中以附件的方式打开。（ https://www.alibabacloud.com/help/zh/doc-detail/56103.htm ）"}
{"title": "微信小程序canvas篇，实现全过程展示含demo", "author": "天下雪", "time": "2016-10-16 17:45", "content": "Demo效果图如下：                          一、Demo思路来源之所以写了这样一个Demo，是因为很久之前在慕课网看到了一个很好玩很酷炫利用canvas绘制的时钟，于是想着这样炫酷好玩的东西在小程序当中是否也能够得以实现呢？答案肯定是可以的。接下来我将把这个Demo的思路一步一步分享给大家。二、Demo实现1.微信小程序开发环境搭建 http://www.helloxcx.com/jc/devtools/download.html，如果这个地址无法下载，请使用官方地址下载；2.开发环境搭建后利用开发工具创建自己的Demo项目  1）创建项目                   2）添加核心代码countdown.js ，digit.js到index目录下3.核心代码实现(代码中有详细的开发注释)  1）digit.js（这里实现倒计时数字的排列，是一个3维数组）// 数字排列var digit = [  [    [0,0,1,1,1,0,0],    [0,1,1,0,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,0,1,1,0],    [0,0,1,1,1,0,0]  ],//0  [    [0,0,0,1,1,0,0],    [0,1,1,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [1,1,1,1,1,1,1]  ],//1  [    [0,1,1,1,1,1,0],    [1,1,0,0,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,1,1,0],    [0,0,0,1,1,0,0],    [0,0,1,1,0,0,0],    [0,1,1,0,0,0,0],    [1,1,0,0,0,0,0],    [1,1,0,0,0,1,1],    [1,1,1,1,1,1,1]  ],//2  [    [1,1,1,1,1,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,1,1,0],    [0,0,0,1,1,0,0],    [0,0,1,1,1,0,0],    [0,0,0,0,1,1,0],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0]  ],//3  [    [0,0,0,0,1,1,0],    [0,0,0,1,1,1,0],    [0,0,1,1,1,1,0],    [0,1,1,0,1,1,0],    [1,1,0,0,1,1,0],    [1,1,1,1,1,1,1],    [0,0,0,0,1,1,0],    [0,0,0,0,1,1,0],    [0,0,0,0,1,1,0],    [0,0,0,1,1,1,1]  ],//4  [    [1,1,1,1,1,1,1],    [1,1,0,0,0,0,0],    [1,1,0,0,0,0,0],    [1,1,1,1,1,1,0],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0]  ],//5  [    [0,0,0,0,1,1,0],    [0,0,1,1,0,0,0],    [0,1,1,0,0,0,0],    [1,1,0,0,0,0,0],    [1,1,0,1,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0]  ],//6  [    [1,1,1,1,1,1,1],    [1,1,0,0,0,1,1],    [0,0,0,0,1,1,0],    [0,0,0,0,1,1,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,1,1,0,0,0],    [0,0,1,1,0,0,0],    [0,0,1,1,0,0,0],    [0,0,1,1,0,0,0]  ],//7  [    [0,1,1,1,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0]  ],//8  [    [0,1,1,1,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,1,1,0],    [0,0,0,1,1,0,0],    [0,1,1,0,0,0,0]  ]//9];module.exports = {    digit : digit}  2）countdown.js（这里实现倒计时数字的绘图以及倒计时）var sort = require(\"./digit.js\")  , digit = sort.digit;   // 接收数字排列数组var CANVAS_WIDTH = 375    // canvas宽度  , CANVAS_HEIGHT = 500   // canvas高度  , RADIUS = 8            // 小球半径  , MARGIN_TOP = 60       // 图例距离右边距离  , MARGIN_LEFT = 60;     // 图例距离左边距离/** * [render 数字渲染] * @param  {[type]} time [倒计时时间] * @param  {[type]} cxt  [绘制对象] */function render(time,cxt){  cxt.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);  renderDigit(MARGIN_LEFT , MARGIN_TOP , parseInt(time/10) , cxt );  renderDigit(MARGIN_LEFT + 15*(RADIUS+1) , MARGIN_TOP , parseInt(time%10) , cxt );}/** * [renderDigit 单独小球的绘制] * @param  {[type]} x   [每个小球x轴距离] * @param  {[type]} y   [每个小球y轴距离] * @param  {[type]} num [需要绘制出来的数字] * @param  {[type]} cxt [绘制对象] */function renderDigit(x,y,num,cxt){  for(var i=0;i<digit[num].length;i++){    for(var j=0;j<digit[num][i].length;j++){      if (digit[num][i][j]){        cxt.beginPath();        cxt.arc(x+j*2*(RADIUS+1)+(RADIUS+1) , y+i*2*(RADIUS+1)+(RADIUS+1) , RADIUS , 0 ,2*Math.PI);        cxt.closePath();        cxt.fill();      }    }   }}/** * [loopTime 倒计时绘图] * @param  {[type]} time [倒计时需要绘制的数字] * @param  {[type]} cxt  [绘制对象] */function loopTime(time,cxt){  render(time,cxt);   // 获取当前context上存储的绘图动作  wx.drawCanvas({    canvasId:\"canvas\",    actions:cxt.getActions()  });}/** * [init 倒计时实现] * @param  {[type]} time [倒计时需要绘制的数字] * @param  {[type]} cxt  [绘制对象] */function init(time,cxt){  loopTime(time,cxt)  var loop = setInterval(function(){    time--;    (time < 1 ) && (      clearInterval(loop)    )    loopTime(time,cxt)  },1000);}// 将init方法暴露出去module.exports = {  render:render,  init:init}3）index.js三、Demo源码源码已托管github，地址为：https://github.com/xuqiang521/Wechat"}
{"title": "chemzqm：文件保存后自动刷新微信小程序", "author": "天下雪", "time": "2016-10-15 16:14", "content": "作者的话：我发现这个方法有副作用，就是别的应用也可能有注册这个全局快捷键，所以我开发了 https://github.com/chemzqm/wept正文部分：微信开发者工具支持刷新和重建的快捷键，所以我们可以发送一段 apple script 脚本来达到刷新/重建项目的效果，从而免去手工切换再使用快捷键的麻烦。例如：tell application \"wechatwebdevtools\"  activate  delay 0.2  tell application \"System Events\"    key code {55, 15}  end tellend tell这段代码可以使用命令 osascript 执行，效果就是聚焦微信开发者工具，然后发送 Command + R 刷新界面。这里的问题是我们还是需要每次刷新都要切换到微信开发者工具界面，这对于开发的流畅度还是有影响的。一个简单的解决办法就是修改开发者工具源码，让它支持全局快捷键，经过一番查找，找到了文件：/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/app/dist/common/menu/menu.js,添加代码：function registShortcut(key, onactive) {  var option = {    key : key,    active : onactive,    failed : function(msg) {      // :(, fail to register the |key| or couldn't parse the |key|.      console.log(msg);    }  };  // Create a shortcut with |option|.  var shortcut = new nw.Shortcut(option);  // Register global desktop shortcut, which can work without focus.  nw.App.registerGlobalHotKey(shortcut);}以及registShortcut(\"Command+Shift+R\", function () {  e.reload()})registShortcut(\"Command+Shift+B\", function () {  e.reBuild()})到 init 函数下面就可以让开发者工具支持全局刷新的热键了（Command+Shift+R 和 Command+Shift+B）,完整文件下载然后只需要让 vim 保存 wxss 和 wxml 文件后发送快捷键就可以了。使用一键安装命令：curl https://raw.githubusercontent.com/chemzqm/vim-macos/master/autoload/macos.vim > ~/.vim/autoload/macos.vim安装 vim-macos 插件, 然后在 ~/.vimrc 中配置：autocmd BufWritePost *.wxml call macos#keycodes('command', 'shift', 'r')autocmd BufWritePost *.wxss call macos#keycodes('command', 'shift', 'r')大功告成。"}
{"title": "微信小程序云端解决方案教程一：文件上传下载应用场景", "author": "天下雪", "time": "2016-10-15 16:55", "content": "内容架构：部署和运行整体架构1. 准备域名和证书2. 云主机和镜像部署3. 配置 HTTPS4. 域名解析5. 开通和配置 COS6. 启动小相册示例 Node 服务7. 微信小程序服务器配置8. 启动小相册 Demo主要功能实现上传图片获取图片列表下载和保存图片删除图片微信小程序提供了一套在微信上运行小程序的解决方案，有比较完整的框架、组件以及 API，在这个平台上面的想象空间很大。小相册是结合腾讯云对象存储服务（Cloud Object Service，简称COS）制作的一个微信小程序示例。在代码结构上包含如下两部分：applet: 小相册应用包代码，可直接在微信开发者工具中作为项目打开server: 搭建的 Node 服务端代码，作为服务器和applet通信，提供 CGI 接口示例用于拉取 COS 图片资源、上传图片到 COS、删除 COS 图片等。小相册主要功能如下：列出 COS 服务器中的图片列表点击左上角上传图片图标，可以调用相机拍照或从手机相册选择图片，并将选中的图片上传到 COS 服务器中轻按任意图片，可进入全屏图片预览模式，并可左右滑动切换预览图片长按任意图片，可将其保存到本地，或从 COS 中删除部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构1. 准备域名和证书在微信小程序中，所有的网络请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP 中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS 协议，所以你还需要为你的域名申请一个证书。域名注册好之后，可以登录微信公众平台配置通信域名了。2. 云主机和镜像部署小相册的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，大家可以直接使用。镜像已包含所有小程序的服务器环境与代码，需要体验其它小程序的朋友无需重复部署3. 配置 HTTPS镜像中已经部署了 nginx，需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx4. 域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 开通和配置 COS小相册示例的图片资源是存储在 COS 上的，要使用 COS 服务，需要登录 COS 管理控制台，然后在其中完成以下操作：开通 COS 服务分配得到唯一的APP ID使用密钥管理生成一对SecretID和SecretKey（用于调用 COS API）在 Bucket 列表中创建公有读私有写访问权限、CDN加速的 bucket（存储图片的目标容器）6. 启动小相册示例 Node 服务在镜像中，小相册示例的 Node 服务代码已部署在目录/data/release/qcloud-applet-album下：进入该目录：cd /data/release/qcloud-applet-album在该目录下有个名为config.js的配置文件（如下所示），按注释修改对应的 COS 配置：module.exports = {    // Node 监听的端口号    port: '9993',    ROUTE_BASE_PATH: '/applet',    cosAppId: '填写开通 COS 时分配的 APP ID',    cosSecretId: '填写密钥 SecretID',    cosSecretKey: '填写密钥 SecretKey',    cosFileBucket: '填写创建的公有读私有写的bucket名称',};小相册示例使用pm2管理 Node 进程，执行以下命令启动 node 服务：pm2 start process.json7. 微信小程序服务器配置进入微信公众平台管理后台设置服务器配置，配置类似如下设置：注意：需要将 www.qcloud.la 设置为上面申请的域名，将 downloadFile 合法域名设置为在 COS 管理控制台中自己创建的 bucket 的相应 CDN 加速访问地址，如下图所示：8. 启动小相册 Demo在微信开发者工具将小相册应用包源码添加为项目，并把源文件config.js中的通讯域名修改成上面申请的域名。然后点击调试即可打开小相册Demo开始体验。这里有个问题。截止目前为止，微信小程序提供的上传和下载 API 无法在调试工具中正常工作，需要用手机微信扫码预览体验。主要功能实现上传图片上传图片使用了微信小程序提供的wx.chooseImage(OBJECT)获取需要上传的文件路径，然后调用上传文件接口wx.request(OBJECT)发送 HTTPS POST 请求到自己指定的后台服务器。和传统表单文件上传一样，请求头Content-Type也是multipart/form-data。后台服务器收到请求后，使用 npm 模块 multiparty 解析 multipart/form-data 请求，将解析后的数据保存为指定目录下的临时文件。拿到临时文件的路径后，就可直接调用 COS SDK 提供的文件上传 API 进行图片存储，最后得到图片的存储路径及访问地址（存储的图片路径也可以直接在 COS 管理控制台看到）。获取图片列表调用列举目录下文件&目录 API可以获取到在 COS 服务端指定 bucket 和该 bucket 指定路径下存储的图片。下载和保存图片指定图片的访问地址，然后调用微信小程序提供的wx.downloadFile(OBJECT)和wx.saveFile(OBJECT)接口可以直接将图片下载和保存本地。这里要注意图片访问地址的域名需要和服务器配置的 dowmloadFile 合法域名一致，否则无法下载。删除图片删除图片也十分简单，直接调用文件删除 API 就可以将存储在 COS 服务端的图片删除。"}
{"title": "微信小程序云端解决方案教程三：会话管理场景", "author": "天下雪", "time": "2016-10-15 17:07", "content": "部署和运行整体架构1. 准备域名和证书2. 云主机和镜像部署3. 配置 HTTPS4. 域名解析5. 配置云存储 Redis6. 配置云数据库 MongoDB7. 启动一笔到底示例 Node 服务实现会话层实现源代码微信小程序示例 - 一笔到底微信小程序提供了一套在微信上运行小程序的解决方案，有比较完整的框架、组件以及 API，在这个平台上面的想象空间很大。微信的定位并不是 HTML5，这里很多人都有误解。在一些实现上，并不能想当然地用 HTML5 的思路来思考。比如，微信的请求接口 wx.request并不支持 cookie 传递，所以会话层不能使用传统的 Session 方式。这篇文章分享一个简单的画图应用，使用自己新鲜出炉的小程序会话管理能力来判断并当前用户的身份。小程序非常简单，使用 Canvas 绘图后，把序列化的 actions 提交给服务器保存。下次加载的时候，再列出用户曾经绘制过的图。部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构1. 准备域名和证书在微信小程序中，所有的网路请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP 中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS 协议，所以你还需要为你的域名申请一个证书。域名注册好之后，可以登录微信公众平台配置通信域名了。2. 云主机和镜像部署一笔到底的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，大家可以直接使用。腾讯云用户可以免费领取礼包，体验腾讯云小程序解决方案。镜像已包含所有小程序的服务器环境与代码，需要体验其它小程序的朋友无需重复部署3. 配置 HTTPS镜像中已经部署了 nginx，需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx4. 域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 配置云存储 Redis会话管理依赖 Redis 进行作为缓存管理，开发者可以选择自行搭建 Redis 服务或者直接购买云存储 Redis 服务。6. 配置云数据库 MongoDB一笔到底小程序使用 MongoDB 来存储用户绘制的图像路径，要运行小程序开发者需要自行搭建 MongoDB 服务或者直接购买云数据库 MongoDB。7. 启动一笔到底示例 Node 服务在镜像的 nginx 配置中（/etc/nginx/conf.d），已经把/applet/session的请求转发到 http://127.0.0.1:5757处理。我们需要把 Node 服务运行起来。Node 代码部署在目录/data/release/qcloud-applet-session下。进入该目录：cd /data/release/qcloud-applet-session在该目录下有个名为config.js的配置文件（如下所示），根据注释将appId、appSecret、redisConfig、mongoConfig修改成自己的配置。module.exports = {    port: '5757',    ROUTE_BASE_PATH: '/applet',    // 微信小程序 App ID    appId: '',    // 微信小程序 App Secret    appSecret: '',    // Redis 配置    // @see https://www.npmjs.com/package/redis#options-object-properties    redisConfig: {        host: '',        port: '',        password: '',    },    // MongoDB 配置    // @see https://www.qcloud.com/doc/product/240/3979    mongoConfig: {        username: '',        password: '',        host: '',        port: '',        query: '?authMechanism=MONGODB-CR&authSource=admin',        database: 'qcloud-applet-session',    },};一笔到底示例使用 pm2 管理 Node 进程，执行以下命令启动 node 服务：pm2 start process.json实现会话层实现会话层实现包含两个部分：服务器端：https://github.com/CFETeam/weapp-session客户端：https://github.com/CFETeam/weapp-session-client我们的 Demo 直接使用这两个仓库，可以快速地拥有会话层的能力。会话层的实现和传统 Cookie 的实现方式类似，都是在 Header 上使用特殊的字段跟踪。一个请求的完整流程如下：客户端（微信小程序）发起请求 requestweapp-session-client 包装 request首次请求调用 wx.login() 和 wx.getUserInfo() 接口获得 code、rawData 和 signaturerequset 的头部带上 code、rawData 和 signature保存 code 供下次调用非首次请求request 的头部带上保存的 code服务器收到请求 request，中间件从头部提取 code、rawData 和 signature 字段如果 code 为空，跳到第 4 步如果 code 不为空，且 rawData 不为空，需要进行签名校验使用 code，appid、app_secret 请求微信接口获得 session_key 和 openid如果接口失败，响应 ERR_SESSION_KEY_EXCHANGE_FAILED使用签名算法通过 rawData 和 session_key 计算签名 signature2对比 signature 和 signature2签名一致，解析 rawData 为 wxUserInfo把 openid 写入到 wxUserInfo把 (code, wxUserInfo) 缓存到 Redis把 wxUserInfo 存放在 request.$wxUserInfo 里跳到第 4 步签名不一致，响应 ERR_UNTRUSTED_RAW_DATA如果 code 不为空，但 rawData 为空，从 Redis 根据 code 查询缓存的用户信息找到用户信息，存放在 request.$wxUserInfo 字段里，跳到第 4 步没找到用户信息（可能是过期），响应 ERR_SESSION_EXPIREDrequest 被业务处理，可以使用 request.$wxUserInfo 来获取用户信息（request.$wxUserInfo 可能为空，业务需要自行处理）源代码可从 Github 获取 https://github.com/CFETeam/weapp-session"}
{"title": "微信小程序架构分析《一》调试技巧，模块构成，理念分析", "author": "天下雪", "time": "2016-10-15 17:21", "content": "本文分为以下几个部分：小程序调试技巧小程序主要模块构成小程序模块间通信设计理念分析小程序调试技巧微信开发者工具默认禁用了右键打开调试面板功能，我们可以修改开发者工具部分代码移除该限制。找到 app.nw 项目根目录，Mac 下为/Applications/wechatwebdevtools.app/Contents/Resources/app.nw使用 js-beautify 对代码批量格式化：cd /Applications/wechatwebdevtools.app/Contents/Resources/app.nw\r\nfind . -type f -name '*.js' -not -path \"./node_modules/*\" -not -path \"./modified_modules/*\" -exec js-beautify -r -s 2 -p -f '{}' \\;\r\n注释掉文件 app/dist/app.js 44 行和app/dist/components/simulator/webviewbody.js 149 行preventDefault 调用。101100 版本还需要修改 package.json 文件，去掉 --disable-devtools。执行完以上操作就可以右键打开页面的调试面板了，需要特别注意的是，使用 view 页面的面板后会导致 wxml 面板不可用，touch 事件无法响应等种种问题，请慎重使用。通过代码可以发现，在配置目录下添加 config.json 文件，然后加入{isDev:true} 可以启用开发者工具所谓的调试模式， 但是我在配置后程序无法正常启动，只好暂时先放弃这种方式。小程序主要模块构成小程序自身分为两个主要部分独立运行：view 模块和 service 模块。在开发者工具中，它们独立运行于不同的 webivew tag 中。view 模块负责 UI 显示，它由开发者编写的 wxml 和 wxss 转换后代码以及微信提供相关辅助模块组成。 一个 view 模块对应一个 webview 组件（也就是我们常规理解的一个页面）, 小程序支持同时多个 view 存在。view 模块通过 WeixinJSBridge 对象来跟后台通信。service 模块负责应用的后台逻辑，它由小程序的 js 代码以及微信提供的相关辅助模块组成。 一个应用只有一个 service 进程，它同样也是一个页面（至少在开发者工具内如此，上线后可能运行于 WeixinJSCore 之内），与 view 模块不同的是，它在程序生命周期内后台运行，service 模块通过与 view 模块实现不同但接口格式一样的 WeixinJSBridge 对象跟后台通信。小程序模块间通信(开发者工具内各模块通信图)做过微信开发相关的开发者会对 WeixinJSBridge 这个对象有所了解，它就是负责 UI 与后台 进行交互的一个中间层。应用号的 WeixinJSBridge 相比与之前的微信 webview 多出 publish 和 subscribe 两个公共方法来发布和订阅事件，从而进行双向通信。service 模块的 WeixinJSBridge 对象在文件app/dist/weapp/appservice/asdebug.js 中定义， view 层的 WeixinJSBridge 在文件 app/dist/inject/jweixindebug.js 中定义。 尽管两者都使用一样的接口以及使用 postMessage 方法与后台通信，但是其内部所做的事情确是完全不同的， 例如 service 模块可以直接通过 prompt 方法来通过 prompt调起底层组件，而 view 层的 WeixinJSBridge 只能发送消息 (参考 H5与Native交互之JSBridge技术)。我们来看一个典型的交互流程：用户点击界面触发事件对应 view 模块接收事件后将事件封装成所需格式后调用 publish 方法发送:WeixinJSBridge.publish('PAGE_EVENT', data)\r\ndata 参数举例：{\r\n\"data\": {\r\n  \"eventName\": \"onhidetap\",\r\n  \"data\": {\r\n    \"target\": {\r\n      ...\r\n    },\r\n    \"currentTarget\": {\r\n      ...\r\n    },\r\n    \"type\": \"tap\",\r\n    \"timeStamp\": 11457,\r\n    \"touches\": [ ...  ],\r\n    \"detail\": {\r\n      ...\r\n    }\r\n  }\r\n},\r\n\"options\": {\r\n  \"timestamp\": 1475445858336\r\n}\r\n}\r\n后台(开发者工具内为 nwjs 运行环境)将数据处理后发送给 service 模块，数据形如：{\r\n\"to\": \"appservice\",\r\n\"msg\": {\r\n  \"eventName\": \"PAGE_EVENT\",\r\n  \"data\": {\r\n    \"data\": {\r\n      \"eventName\": \"onhidetap\",\r\n      \"data\": {\r\n        \"target\": {\r\n          ...\r\n        },\r\n        \"currentTarget\": {\r\n          ...\r\n        },\r\n        \"type\": \"tap\",\r\n        \"timeStamp\": 75329,\r\n        \"touches\": [ ...  ],\r\n        \"detail\": {\r\n          ...\r\n        }\r\n      }\r\n    },\r\n    \"options\": {\r\n      \"timestamp\": 1475445858336\r\n    }\r\n  },\r\n  \"webviewID\": 0\r\n},\r\n\"command\": \"MSG_FROM_WEBVIEW\"\r\n}\r\nservice 模块的 WeixinJSBridge 内回调函数依据传来数据找到对应 view 的 page 模块后执行 对应名为 eventName 指向的函数回调函数调用 this.setData({hidden: true}) 改变 data，serivce 层计算该页面 data 后向后台发送 send_app_data 和 appdataChange 事件，具体数据格式如下：{\r\n\"appData\": {\r\n  \"page/index\": {\r\n    ...\r\n  }\r\n},\r\n\"sdkName\": \"send_app_data\",\r\n\"to\": \"backgroundjs\",\r\n\"comefrom\": \"webframe\",\r\n\"command\": \"COMMAND_FROM_ASJS\",\r\n\"appid\": \"touristappid\",\r\n\"appname\": \"chat\",\r\n\"apphash\": 70475629,\r\n\"webviewID\": 100000\r\n}\r\n{\r\n\"eventName\": \"appDataChange\",\r\n\"data\": {\r\n  \"data\": {\r\n    \"data\": {\r\n      \"hidden\": true\r\n    }\r\n  },\r\n  \"options\": {\r\n    \"timestamp\": 1475528706311\r\n  }\r\n},\r\n\"sdkName\": \"publish\",\r\n\"webviewIds\": [\r\n  0\r\n],\r\n\"to\": \"backgroundjs\",\r\n\"comefrom\": \"webframe\",\r\n\"command\": \"COMMAND_FROM_ASJS\",\r\n\"appid\": \"touristappid\",\r\n\"appname\": \"chat\",\r\n\"apphash\": 70475629,\r\n\"webviewID\": 100000\r\n}\r\n后台(文件 dist/components/simulator/webviewbody.js) 接收到appDataChange 事件数据后再将数据进行简单封装， 最后转发给到 view 层。 具体数据格式为：{\r\n\"to\": \"webframe\",\r\n\"msg\": {\r\n  \"eventName\": \"appDataChange\",\r\n  \"data\": {\r\n    \"data\": {\r\n      \"data\": {\r\n        \"hidden\": true\r\n      }\r\n    },\r\n    \"options\": {\r\n      \"timestamp\": 1475528706311\r\n    }\r\n  },\r\n  \"sdkName\": \"publish\",\r\n  \"webviewIds\": [\r\n    0\r\n  ],\r\n  \"to\": \"backgroundjs\",\r\n  \"comefrom\": \"webframe\",\r\n  \"command\": \"COMMAND_FROM_ASJS\",\r\n  \"appid\": \"touristappid\",\r\n  \"appname\": \"chat\",\r\n  \"apphash\": 70475629,\r\n  \"webviewID\": 100000,\r\n  \"act\": \"sendMsgFromAppService\"\r\n},\r\n\"command\": \"MSG_FROM_APPSERVICE\",\r\n\"webviewID\": 0,\r\n\"id\": 0.10577065353216675\r\n}\r\nview 层的 WeixinJSBridge 接收到后台的数据，如果 webviewID 匹配则将 data 与现有页面 data 合并， 然后就是 virtual dom 模块进行 diff 和 apply 操作改变 dom。小程序模块间消息传递除了界面事件和应用数据还包括触发原生方法、握手以及生命周期等类型， 尽管处理对象和处理方式不同，大体流程跟上面是一样的。view 模块和 service 模块的 WeixinJSBridge 都使用了 postMessage 接口 (参考MDN 文档) 与后台通信，但是由于该接口无法直接与 nwjs 后台进程通信，所以开发者工具会将 app/dist/contentscript/contentScript.js 文件做为contentScript 注入到 view 模块和 service 模块所在页面，contentScript.js 的代码提供了 message 消息到 chrome.runtime通信接口的转换。微信开发者工具扩展了 devtools 提供了 AppData 面板，开发者可以修改里面数据然后直接看到 view 界面的变化效果。这里修改数据后 nwjs 会将消息发送给 service 层，之后发生的事就跟上面 4 5 6 步一样：service 传递消息给 nwjs，最后到 view 层。设计理念分析小程序这样的分层设计显然是有意为之的，它的中间层完全控制了程序对于界面进行的操作， 同时对于传递的数据和响应时间也做到的监控。一方面程序的行为受到了极大限制， 另一方面微信可以确保他们对于小程序内容和体验有绝对的控制。我们在小程序的 js 代码里面是不能直接使用浏览器提供的 DOM 和 BOM 接口的，这一方面是因为 js 代码外层使用了局部变量进行屏蔽，另一方面即便我们可以操作 DOM 和 BOM 接口，它们对应的 也是 service 模块页面，并不会对页面产生影响。这样的结构也说明了小程序的动画和绘图 API 被设计成生成一个最终对象而不是一步一步执行的样子， 原因就是 json 格式的数据传递和解析相比与原生 API 都是损耗不菲的，如果频繁调用很可能损耗 过多性能，进而影响用户体验。理解了以上机制，再对 view 模块和 service 模块的 WeixinJSBridge 加以改造，我们便不难做到让 小程序跑在自己的环境下，这样就可以做些手机调试以及单页面测试等操作。"}
{"title": "微信小程序云端解决方案教程二：WebSocket长连接应用场景", "author": "天下雪", "time": "2016-10-15 16:58", "content": "部署和运行整体架构1. 准备域名和证书2. 云主机和镜像部署3. 配置 HTTPS4. 域名解析5. 启动 WebSocket 服务6. 启动微信小程序为什么要用 WebSocket通信协议设计服务器逻辑微信端实现没事打开小程序，和附近的人剪刀石头布，想来就来，想走就走。谁能成为武林高手？！微信小程序提供了一套在微信上运行小程序的解决方案，有比较完整的框架、组件以及 API，在这个平台上面的想象空间很大。腾讯云拿到了小程序内测资格，研究了一番之后，发现微信支持 WebSocket 还是很值得玩味的。这个特性意味着我们可以做一些实时同步或者协作的小程序。这篇文章分享一个简单的剪刀石头布的小游戏的制作，希望能对想要在小程序中使用 WebSocket 的开发者有帮助。整个游戏非常简单，连接到服务器后自动匹配在线玩家（没有则分配一个机器人），然后两人进行剪刀石头布的对抗游戏。当对方进行拳头选择的时候，头像会旋转，这个过程使用 WebSocket 会变得简单快速。部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构小程序的架构非常简单，这里有两条网络同步，一条是 HTTPS 通路，用于常规请求。对于 WebSocket 请求，会先走 HTTPS 后再切换协议到 WebSocket 的 TCP 连接，从而实现全双工通信。1. 准备域名和证书在微信小程序中，所有的网路请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP 中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS 协议，所以你还需要为你的域名申请一个证书。域名注册好之后，可以登录微信公众平台配置通信域名了。2. 云主机和镜像部署剪刀石头布的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，大家可以直接使用。腾讯云用户可以免费领取礼包，体验腾讯云小程序解决方案。镜像部署完成之后，云主机上就有运行 WebSocket 服务的基本环境、代码和配置了。镜像已包含所有小程序的服务器环境与代码，需要体验其它小程序的朋友无需重复部署3. 配置 HTTPS镜像中已经部署了 nginx，需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx4. 域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 启动 WebSocket 服务在镜像的 nginx 配置中（/etc/nginx/conf.d），已经把 /applet/websocket 的请求转发到 http://127.0.0.1:9595 处理。我们需要把 Node 实现的 WebSocket 服务在这个端口里运行起来。进入镜像中源码位置：cd /data/release/qcloud-applet-websocket使用 pm2 启动服务：pm2 start process.json6. 启动微信小程序在微信开发者工具中修改小程序源码中的 config.js 配置，把通讯域名修改成上面申请的域名。完成后点击调试即可连接到 WebSocket 服务进行游戏。配置完成后，运行小程序就可以看到成功搭建的提示！为什么要用 WebSocket使用传统的 HTTP 轮询或者长连接的方式也可以实现类似服务器推送的效果，但是这类方式都存在资源消耗过大或推送延迟等问题。而 WebSocket 直接使用 TCP 连接保持全双工的传输，可以有效地减少连接的建立，实现真正的服务器通信，对于有低延迟有要求的应用是一个很好的选择。目前浏览器对 WebSocket 的支持程度已经很好，加上微信小程序的平台支持，这种可以极大提高客户端体验的通信方式将会变得更加主流。Server 端需要实现 WebSocket 协议，才能支持微信小程序的 WebSocket 请求。鉴于 SocketIO 被广泛使用，剪刀石头布的小程序，我们选用了比较著名的 SocketIO 作为服务端的实现。Socket IO 的使用比较简单，仅需几行代码就可启动服务。export class Server {    init(path: string) {        /** Port that server listen on */        this.port = process.env.PORT;        /** HTTP Server instance for both express and socket io */        this.http = http.createServer();        /** Socket io instance */        this.io = SocketIO(this.http, { path });        /** Handle incomming connection */        this.io.on(\"connection\", socket => {            // handle connection        });    }    start() {        this.http.listen(this.port);        console.log(`---- server started. listen : ${this.port} ----`);    }}const server = new Server();server.init(\"/applet/ws/socket.io\");server.start();但是，SocketIO 和一些其它的服务器端实现，都有其配套的客户端来完成上层协议的编码解码。但是由于微信的限制（不能使用 window 等对象）， SocketIO 的客户端代码在微信小程序平台上是无法运行的。经过对 SocketIO 通信进行抓包以及研究其客户端源码，笔者封装了一个大约 100 行适用于微信小程序平台的 WxSocketIO 类，可以帮助开发者快速使用 SocketIO 来进行 WebSocket 通信。const socket = new WxSocketIO();socket.on('hi', packet => console.log('server say hi: ' + packet.message));socket.emit('hello', { from: 'techird' });如果想要使用微信原生的 API，那么在服务器端也可以直接使用 ws 来实现 W3C 标准的接口。不过 SocketIO 支持多进程的特性，对于后续做横向扩张是很有帮助的。腾讯云在后面也会有计划推出支持大规模业务需求的 WebSocket 连接服务，减小业务的部署成本。通信协议设计实现一个多客户端交互的服务，是需要把中间涉及到所有的消息类型都设计清楚的，就像是类似剪刀石头布这样一个小程序，都有下面这些消息类型。消息方向说明helloc => s客户端连上后发送 hello 信息，告知服务器自己身份以及位置。his => c服务器响应客户端打招呼，并且反馈附近有多少人joinc => s客户端请求加入一个房间进行游戏leavec => s客户端请求退出房间starts => c房间里面全部人都 ready 后，会发送游戏开始的信号，并且告知客户端游戏时间。choicec => s客户端选择出剪刀、石头还是布facec => s客户端更新自己的表情movements => c有用户更新选择或者更新表情会通知其它用户results => c超过选择时间后，游戏结束，广播游戏结果具体每个消息的参数可以参考源码里的 server/protocol.brief.md服务器逻辑服务器的逻辑很简单：收到用户请求加入房间（join），就寻找还没满的房间找到房间，则加入没找到房间，创建新房间有用户加入的房间检查是否已满，如果已满，则：给房间里每个用户发送开始游戏的信号（start）启动计时器，计时器结束后进行游戏结算游戏结算两两之间 PK，赢方分数加一，输方减一，最终得每个玩家基本得分 x对于每个玩家，如果分数 x 大于 0，则视为胜利，连胜次数加一，否则连胜次数归零本局得分为分数 x 乘以连胜次数发送本局游戏结果给房间里的每位玩家微信端实现微信小程序直接使用上面的协议，针对不同的场景进行渲染。整体的状态机如下。状态机整理清楚后，就是根据状态机来控制什么时候发送消息，接到消息后如何处理的问题了。具体实现请参照 app/pages/game/game.js 里的源码。"}
{"title": "微信小程序云端解决方案教程四：视频应用场景", "author": "天下雪", "time": "2016-10-15 17:12", "content": "部署和运行整体架构1. 准备域名和证书2. Nginx 和 Node 代码部署3. 配置 HTTPS4. 域名解析5. 开通 点播服务6. 准备 云数据库MySQL7. 启动新片预告示例 Node 服务8. 启动新片预告 Demo主要功能实现获取视频列表、展示评论、提交评论播放视频新片预告是结合腾讯云点播 VOD和云数据库 MySQL制作的一个微信小程序示例。在代码结构上包含如下两部分：app: 新片预告应用包代码，可直接在微信开发者工具中作为项目打开server: 搭建的Node服务端代码，作为服务器和app通信，提供 CGI 接口示例用于拉取云数据库上的视频列表、评论列表，将评论数据提交到云数据库新片预告主要功能如下：支持分页滚动加载视频列表点击海报跳转至详情页播放视频对视频进行评论展示视频的评论列表部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构1. 准备域名和证书在微信小程序中，所有的网路请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP 中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS 协议，所以你还需要为你的域名申请一个 SSL 证书。腾讯云提供域名注册和证书申请服务，还没有域名或者证书的可以去使用域名注册好之后，可以登录微信公众平台配置通信域名了。注意：需要将 www.qcloud.la 设置为上面申请的域名2. Nginx 和 Node 代码部署小程序服务要运行，需要进行以下几步：部署 Nginx，Nginx 的安装和部署请大家自行搜索（注意需要把 SSL 模块也编译进去）配置 Nginx 反向代理到 http://127.0.0.1:9994Node 运行环境，可以安装 Node V6.6.0部署 server 目录的代码到服务器上，如 /data/release/qcloud-applet-video使用 npm install 安装依赖模块使用 npm install pm2 -g 安装 pm2上述环境配置比较麻烦，新片预告的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，推荐大家直接使用。镜像部署完成之后，云主机上就有运行 WebSocket 服务的基本环境、代码和配置了。腾讯云用户可以免费领取礼包，体验腾讯云小程序解决方案。镜像已包含所有小程序的服务器环境与代码，需要体验小程序的朋友无需重复部署3. 配置 HTTPS镜像中已经部署了 nginx，需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx\r\n4. 域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 开通 点播服务新片预告示例的播放资源是存储在 腾讯云点播 上的mp4文件，要使用 点播 服务，需要登录 点播 管理控制台，然后在其中完成以下操作：上传视频资源，点播几乎支持所有主流的视频格式上传转码成功后获取mp4或m3u8源地址目前微信小程序video组件经测试支持mp4和m3u8格式，其中 m3u8 格式只能在手机上使用，开发者可以使用腾讯云点播控制台将视频源转码成 mp4 或 m3u8 格式，并且腾讯云点播会对播放的资源进行CDN加速。6. 准备 云数据库MySQL示例中拉取的视频和评论列表都是存储在 云数据库 上，要使用 云数据库 服务需要完成以下操作购买，注意购买的云数据库需要与云服务器同在一个地域分区初始化流程，本示例选用的是utf8编码点击云数据库 控制台操作栏的登录按钮，登录到phpMyAdmin创建数据库并在当前数据库中导入本示例中的SQL文件注意：导入SQL文件中包含了 点播 上传的视频列表，开发者可以基于云数据库自行开发维护一个视频发布管理系统，因为此内容跟本示例暂不相关，所以不再详述。7. 启动新片预告示例 Node 服务在镜像中，新片预告示例的 Node 服务代码已部署在目录/data/release/qcloud-applet-video下：进入该目录：cd /data/release/qcloud-applet-video\r\n在该目录下有个名为config.js的配置文件（如下所示），按注释修改对应的 MySQL 配置：module.exports = {\r\n    // Node 监听的端口号\r\n    port: '9994',\r\n    ROUTE_BASE_PATH: '/applet',\r\n\r\n    host: '填写开通 MySQL 时分配的内网IP',\r\n    user: '填写MySQL用户名',\r\n    password: '填写MySQL密码',\r\n    database: '填写上一步中创建的MySQL数据名',\r\n};\r\n示例使用pm2管理 Node 进程，执行以下命令启动 node 服务：pm2 start process.json\r\n8. 启动新片预告 Demo在微信开发者工具将新片预告应用包源码添加为项目，并把源文件config.js中的通讯域名修改成上面申请的域名。然后点击调试即可打开新片预告Demo开始体验。主要功能实现获取视频列表、展示评论、提交评论通过node的mysql模块连接mysql，进行查询，插入操作以下是查询评论列表的示例代码const mysql = require('mysql');\r\nconst config = require('../../../config');\r\n\r\nlet vid = this.req.query.vid;\r\nif (!vid) {\r\n    this.res.json({ code: -1, msg: 'failed', data: {} });\r\n    return;\r\n}\r\n\r\n//CDB Mysql配置\r\nlet connection = mysql.createConnection({\r\n    host: config.host,\r\n    password: config.password,\r\n    user: config.user,\r\n    database: config.database\r\n});\r\n\r\n//开启数据库连接\r\nconnection.connect((err) => {\r\n    if (err) {\r\n        this.res.json({ code: -1, msg: 'failed', data: {} });\r\n    }\r\n});\r\n\r\n//查询列表\r\nconnection.query('SELECT * from comment where vid = ? order by id desc', [vid], (err, result) => {\r\n    if (err) {\r\n        this.res.json({ code: -1, msg: 'failed', data: {} });\r\n        return;\r\n    }\r\n\r\n    this.res.json({\r\n        code: 0,\r\n        msg: 'ok',\r\n        data: result,\r\n    });\r\n});\r\n\r\n//查询完后关闭连接\r\nconnection.end();\r\n播放视频<video src=\"{{videoUrl}}\" binderror=\"videoErrorCallback\"></video>\r\n属性名类型说明srcString要播放视频的资源地址binderrorEventHandle当发生错误时触发error事件，event.detail = {errMsg: 'something wrong'}播放视频使用的是video标签，目前官方文档上只给出了两个参数说明，笔者测试了src支持加载mp4和m3u8格式视频，video标签的控制条暂时没办法自定义样式以及隐藏"}
{"title": "微信小程序架构分析《二》：view 模块和 service 模块的构成", "author": "天下雪", "time": "2016-10-15 17:27", "content": "你可以在app.nw/app/dist/weapp/tpl/pageFrameTpl.js 和app.nw/app/dist/weapp/tpl/appserviceTpl.js 文件内找到页面的模板。打开微信 web 开发者工具，然后输入 openVendor() 便会打开 WeappVendor这个目录，这里包含了 view 模块和 service 模块使用的几个核心文件：wcc 可执行程序，用于将 wxml 转为 view 模块使用的 js 代码，使用方式为wcc xxx.wxmlwcsc 可执行程序，用于将 wxss 转为 view 模块使用的 css 代码，使用方式为 wcsc xxx.wxssWAService.js 提供 service 模块大部分功能，下面会有详细介绍WAWebview.js 提供 view 模块大部分功能，下面会有详细介绍view 页面详解view 页面的 template 如下：<!DOCTYPE html>\r\n<html lang=\"zh-CN\">\r\n<head>\r\n  <link href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\" rel=\"Shortcut Icon\">\r\n  <meta charset=\"UTF-8\" />\r\n  <meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\" />\r\n\r\n  <script>\r\n    var __webviewId__;\r\n  </script>\r\n\r\n  <!-- percodes -->\r\n\r\n  <!--{{WAWebview}}-->\r\n\r\n  <!--{{reportSDK}}-->\r\n\r\n  <!--{{webviewSDK}}-->\r\n\r\n  <!--{{exparser}}-->\r\n\r\n  <!--{{components_js}}-->\r\n\r\n  <!--{{virtual_dom}}-->\r\n\r\n  <!--{{components_css}}-->\r\n\r\n  <!--{{allWXML}}-->\r\n\r\n  <!--{{eruda}}-->\r\n\r\n  <!--{{style}}-->\r\n\r\n  <!--{{currentstyle}}-->\r\n\r\n  <!--{{generateFunc}}-->\r\n</head>\r\n\r\n<body>\r\n  <div></div>\r\n</body>\r\n\r\n</html>\r\n其中 <!-- percodes --> 会在 dev 模式开启后被替换为一个时间锚点，例如：<script>var pageFrameStartTime = new Date();</script>\r\n<!--{{WAWebview}}--> 会被 WAWebview.js 内代码替换<!--{{WAWebview}}--> 到 <!--{{generateFunc}}--> 之间暂时没有被使用到<!--{{generateFunc}}--> 会被 wcc 命令生成后的 js 代码替换除了上面这些，页面上还会被插入页面和应用的 style 标签，如：<link rel=\"stylesheet\" type=\"text/css\" href=\"index.wxss\">\r\n这里的 wxss 文件包含的是原始 wxss 文件转换后的 css以及生成 DOM 的启动脚本：<script>\r\n  document.dispatchEvent(new CustomEvent(\"generateFuncReady\", {\r\n    detail: {\r\n      generateFunc: $gwx('./page/index.wxml')\r\n    }\r\n  }))\r\n</script>\r\nWAWebview.js 文件中的各个模块(行号为 jsbeautify 之后代码行号，开发者工具版本：092300)：1-77 行： WeixinJSBridge 对象兼容层，这个大概只会在调试时用到，因为开发时和运行时页面都会被后台以注入的方式添加 WeixinJSBridge 这个对象。我们可以通过这段代码看到它暴露的方法： invoke invokeCallbackHandleron publish subscribe subscribe subscribeHandler。78-235 行：Reporter 对象，它的作用就是发送错误和性能统计数据给后台236-596 行：wx 对象，页面的核心之一，一方面封装 WeixinJSBridge 的 invokeMethod 方位为易于调用的形式（例如 redirectTo, navigateTo等），另一方面封装 WeixinJSBridge 回调方法，调用者可以使用wx.onAppDataChange(callback) 添加数据变更的回调函数，最后提供wx.publishPageEvent 发送页面事件到后台607-1267 行：wxparser 对象，提供 dom 到 wx element 对象之间的映射操作，提供元素操作管理和事件管理功能1268-1285 行：转发 window 上的 animation 和 transition 相关的动画事件到 exparser1286-1313 行：订阅并转发 WeixinJSBridge 提供的全局事件到 exparser1324-1345 行：转发 window 上的 error 以及各种表单事件到 exparser1347-3744 行：使用 exparser.registerBehavior 和exparser.registerElement 方法注册各种以 wx- 做为标签开头的元素到 exparser3744-4498 行：virtual dom 渲染算法实现，提供 diff apply render 等方法，该模块接口基本与 virtual-dom 一致，这里特别的地方在于它所 diff 和生成的并不是原生 DOM，而是各种模拟了 DOM 接口的 wx element 对象4599-4510 行：插入默认样式到页面从页面 data 到 dom 的主要流程如下：var vtree\r\nvar rootNode\r\n\r\ndocument.addEventListener(\"generateFuncReady\", function(e) {\r\n  var generateFunc = e.detail.generateFunc;\r\n  wx.onAppDataChange(function(obj) {\r\n    // 合并 data 到现有 data\r\n    DataStore.setData(obj.data)\r\n    // 生成 virtual dom 的 javascript plain object\r\n    var props = generateFunc(DataStore.getData())\r\n\r\n    // 第一次渲染\r\n    if (obj.options.firstRender) {\r\n      vtree = createVirtualTree(props, true)\r\n      rootNode = vtree.render()\r\n      rootNode.replaceDocumentElement(document.body)\r\n      wx.initReady()\r\n    } else {\r\n      var other_vtree = createVirtualTree(props, false)\r\n      var patches = vtree.diff(other_vtree)\r\n      patches.apply(rootNode)\r\n      vtree = other_vtree\r\n      document.dispatchEvent(new CustomEvent(\"pageReRender\", {}));\r\n    }\r\n  })\r\n})\r\n上面的 DataStore 对象提供合并和获取当前页面 data 对象的功能，其实现如下：var DataStore = (function() {\r\n  var data = {}\r\n  return {\r\n    getData: function() {\r\n      return data\r\n    },\r\n    setData: function(e) {\r\n      for (var t in e) {\r\n        for (var n = (0, parsePath)(t), o = data, a = void 0, s = void 0, c = 0; c < n.length; c++) Number(n[c]) === n[c] && Number(n[c]) % 1 === 0 ? Array.isArray(o) || (a[s] = [], o = a[s]) : \"[object Object]\" !== Object.prototype.toString.call(o) && (a[s] = {}, o = a[s]), s = n[c], a = o, o = o[n[c]];\r\n        a && (a[s] = e[t])\r\n      }\r\n    }\r\n  }\r\n})()\r\n\r\n// 解析 key 为 data 内对象的路径字符串\r\nfunction parsePath(e) {\r\n  for (var t = e.length, n = [], i = \"\", r = 0, o = !1, a = !1, s = 0; s < t; s++) {\r\n    var c = e[s];\r\n    if (\"\\\\\" === c) s + 1 < t && (\".\" === e[s + 1] || \"[\" === e[s + 1] || \"]\" === e[s + 1]) ? (i += e[s + 1], s++) : i += \"\\\\\";\r\n    else if (\".\" === c) i && (n.push(i), i = \"\");\r\n    else if (\"[\" === c) {\r\n      if (i && (n.push(i), i = \"\"), 0 === n.length) throw new Error(\"path can not start with []: \" + e);\r\n      a = !0, o = !1\r\n    } else if (\"]\" === c) {\r\n      if (!o) throw new Error(\"must have number in []: \" + e);\r\n      a = !1, n.push(r), r = 0\r\n    } else if (a) {\r\n      if (c < \"0\" || c > \"9\") throw new Error(\"only number 0-9 could inside []: \" + e);\r\n      o = !0, r = 10 * r + c.charCodeAt(0) - 48\r\n    } else i += c\r\n  }\r\n  if (i && n.push(i), 0 === n.length) throw new Error(\"path can not be empty\");\r\n  return n\r\n}\r\n可以看到，每次 data 变化之后，小程序就会开始整个页面的 diff patch 过程。对于原生实现的组件， exparser 会在监视到数据变化后发送对应事件到 WeixinJSBridge。service 页面详解service 页面会被被拼接为以下的样子：<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n  <link href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\" rel=\"Shortcut Icon\">\r\n  <script>\r\n  var __wxAppData = {}\r\n  var __wxRoute\r\n  var __wxRouteBegin\r\n  </script>\r\n  <script>var __wxConfig = {\"pages\":[\"page/index\"],\r\n  // app 相关各种配置\r\n  }</script>\r\n  <script src=\"http://70475629.appservice.open.weixin.qq.com/asdebug.js\"></script>\r\n  <script src=\"http://70475629.appservice.open.weixin.qq.com/WAService.js\"></script>\r\n  <script src=\"http://70475629.appservice.open.weixin.qq.com/app.js\"></script>\r\n  <script>\r\n    __wxRoute = 'page/index';\r\n    __wxRouteBegin = true\r\n  </script>\r\n  <script src=\"http://70475629.appservice.open.weixin.qq.com/page/index.js\"></script>\r\n</head>\r\n\r\n<body>\r\n  <script>\r\n    window._____sendMsgToNW({\r\n      sdkName: 'APP_SERVICE_COMPLETE'\r\n    })\r\n  </script>\r\n</body>\r\n\r\n</html>\r\n除了配置和开发者编写的页面、app.js，页面还在加载了 asdebug.js 和 WAService.js 两个文件。asdebug.js 文件位于 nwjs 项目目录下，路径为app/dist/weapp/appservice/asdebug.js。 它包含了两个部分，一个是 WeixinJSBridge 针对 service 模块的实现，另一块是一些方便命令使用的接口， 例如：help() 会告诉你一些可用的函数：该文件只会在开发者工具内被引入，如果小程序在微信内运行，应该会由微信底层提供 WeixinJSBridge。WAService 负责 service 模块的一些核心逻辑，它包含以下部分 (行号为 jsbeautify 之后代码行号，开发者工具版本：092300)：1-78 行： 跟 WAWebview.js 一样的 WeixinJSBridge 兼容模块79-245 行： 跟 WAWebview.js 一样的 Reporter 模块246-1664 行：比 WAWebview.js 中 wx 功能更为丰富 wx 接口模块1665-2304 行：appServiceEngine 模块，提供 Page，App，GetApp 接口2305-2360 行： 为 window 对象添加 AMD 接口 require define现在的 WAService 还有有很多地方依赖 window 对象，所以很有可能它在微信中和开发者工具内一样，依然运行于 webview 标签之内。"}
{"title": "微信小程序开发教程：Flex布局", "author": "天下雪", "time": "2016-10-15 21:22", "content": "微信小程序页面布局方式采用的是Flex布局。Flex布局，是W3c在2009年提出的一种新的方案，可以简便，完整，响应式的实现各种页面布局。Flex布局提供了元素在容器中的对齐，方向以及顺序，甚至他们可以是动态的或者不确定的大小的。Flex布局的主要特征是能够调整其子元素在不同的屏幕大小中能够用最适合的方法填充合适的空间。Flex布局的特点:任意方向的伸缩，向左，向右，向下，向上在样式层可以调换和重排顺序主轴和侧轴方便配置子元素的空间拉伸和填充沿着容器对齐微信小程序实现了Flex布局,简单介绍下Flex布局在微信小程序中的使用。伸缩容器设有display:flex或者display:block的元素就是一个flex container(伸缩容器)，里面的子元素称为flex item(伸缩项目)，flex container中子元素都是使用Flex布局排版。display:block 指定为块内容器模式，总是使用新行开始显示，微信小程序的视图容器(view,scroll-view和swiper)默认都是dispaly:block。display:flex:指定为行内容器模式，在一行内显示子元素，可以使用flex-wrap属性指定其是否换行，flex-wrap有三个值:nowrap(不换行),wrap(换行),wrap-reverse(换行第一行在下面)使用display:block(默认值)的代码:  <view class=\"flex-row\" style=\"display: block;\">        <view class=\"flex-view-item\">1</view>        <view class=\"flex-view-item\">2</view>        <view class=\"flex-view-item\">3</view>    </view>显示效果:改换成display:flex的显示效果:可以从效果图看到block和flex的区别，子元素view是在换行显示(block)还是行内显示(flex)。主轴和侧轴Flex布局的伸缩容器可以使用任何方向进行布局。容器默认有两个轴：主轴(main axis)和侧轴(cross axis)。主轴的开始位置为主轴起点(main start)，主轴的结束位置为主轴终点(main end),而主轴的长度为主轴长度(main size)。同理侧轴的起点为侧轴起点(cross start),结束位置为侧轴终点(cross end),长度为侧轴长度(cross size)。详情见下图:注意，主轴并不是一定是从左到右的，同理侧轴也不一定是从上到下，主轴的方向使用flex-direction属性控制,它有4个可选值:row :从左到右的水平方向为主轴row-reverse：从右到左的水平方向为主轴column:从上到下的垂直方向为主轴column-reverse从下到上的垂直方向为主轴如果水平方向为主轴，那个垂直方向就是侧轴，反之亦然。四种主轴方向设置的效果图:图中的实例展示了使用了不同的flex-direction值排列方向的区别。实例代码:<view >    <view class=\"flex-row\" style=\"display: flex;flex-direction: row;\">        <view class=\"flex-view-item\">1</view>        <view class=\"flex-view-item\">2</view>        <view class=\"flex-view-item\">3</view>    </view>    <view class=\"flex-column\" style=\"display:flex;flex-direction: column;\" >        <view class=\"flex-view-item\">c1</view>        <view class=\"flex-view-item\">c2</view>        <view class=\"flex-view-item\">c3</view>    </view></view>运行效果：对齐方式子元素有两种对齐方式：justify-conent 定义子元素在主轴上面的对齐方式align-items 定义子元素在侧轴上对齐的方式jstify-content有5个可选的对齐方式:flex-start 主轴起点对齐(默认值)flex-end 主轴结束点对齐center 在主轴中居中对齐space-between 两端对齐，除了两端的子元素分别靠向两端的容器之外，其他子元素之间的间隔都相等space-around 每个子元素之间的距离相等，两端的子元素距离容器的距离也和其它子元素之间的距离相同。justify-content的对齐方式和主轴的方向有关，下图以flex-direction为row，主轴方式是从左到右,描述jstify-content5个值的显示效果:align-items表示侧轴上的对齐方式:stretch 填充整个容器(默认值)flex-start 侧轴的起点对齐flex-end 侧轴的终点对齐center 在侧轴中居中对齐baseline 以子元素的第一行文字对齐align-tiems设置的对齐方式，和侧轴的方向有关，下图以flex-direction为row,侧轴方向是从上到下,描述align-items的5个值显示效果:有了主轴和侧轴的方向再加上设置他们的对齐方式，就可以实现大部分的页面布局了。案例地址：https://github.com/jjz/weixin-mina/blob/master/pages/flex/flex.wxml"}
{"title": "微信小程序架构分析《三》：实现过程以及实时更新", "author": "天下雪", "time": "2016-10-15 17:36", "content": "小程序实时运行工具 wept 的开发已经基本完成了， 你可以通过我的代码对小程序的 web 环境实现有更全面的认识。下面我将介绍它的实现过程以及实时更新的原理。小程序 web 服务实现我在 wept 的开发中使用 koa 提供 web 服务，以及 et-improve 提供模板渲染。第一步： 准备页面模板我们需要三个页面，一个做为控制层 index.html，一个做为 service 层service.html，还有一个做为 view 层的 view.htmlindex.html:<div class=\"head\">\r\n</div>\r\n<div class=\"scrollable\">\r\n</div>\r\n<div class=\"tabbar-root\">\r\n</div>\r\n<script>\r\n  var __wxConfig__ = {{= _.config}}\r\n  var __root__ = '{{= _.root}}'\r\n</script>\r\n<script src=\"/script/build.js\"></script>\r\nservice.html:<head>\r\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n  <link href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\" rel=\"Shortcut Icon\">\r\n  <script>\r\n  var __wxAppData = {}\r\n  var __wxRoute\r\n  var __wxRouteBegin\r\n  global = {}\r\n  var __wxConfig = {{= _.config}}\r\n  </script>\r\n  <script src=\"/script/bridge.js\" type=\"text/javascript\"></script>\r\n  <script src=\"/script/service.js\" type=\"text/javascript\"></script>\r\n  {{each _.utils as util}}\r\n  <script src=\"/app/{{= util}}\" type=\"text/javascript\"></script>\r\n  {{/}}\r\n  <script src=\"/app/app.js\" type=\"text/javascript\"></script>\r\n  {{each _.routes as route}}\r\n  <script> var __wxRoute = '{{= route | noext}}', __wxRouteBegin = true;</script>\r\n  <script src=\"/app/{{= route}}\" type=\"text/javascript\"></script>\r\n  {{/}}\r\n</head>\r\n<body>\r\n  <script>\r\n    window._____sendMsgToNW({\r\n      sdkName: 'APP_SERVICE_COMPLETE'\r\n    })\r\n  </script>\r\n</body>\r\nview.html:<head>\r\n  <link href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\" rel=\"Shortcut Icon\">\r\n  <meta charset=\"UTF-8\" />\r\n  <meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\" />\r\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"/css/default.css\">\r\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"/app/app.wxss\">\r\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"/app/{{= _.path}}.wxss\">\r\n  <script> var __path__ = '{{= _.path}}'</script>\r\n  <script src=\"/script/ViewBridge.js\" async type=\"text/javascript\"></script>\r\n  <script src=\"/script/view.js\" type=\"text/javascript\"></script>\r\n  <script>\r\n  {{= _.inject_js}}\r\n  </script>\r\n  <script>\r\n    document.dispatchEvent(new CustomEvent(\"generateFuncReady\", {\r\n      detail: {\r\n        generateFunc: $gwx('./{{= _.path}}.wxml')\r\n      }\r\n    }))\r\n  </script>\r\n</head>\r\n<body>\r\n  <div></div>\r\n</body>\r\n第二步： 实现 http 服务用 koa 实现的代码逻辑非常简单：server.js// 日志中间件\r\napp.use(logger())\r\n// gzip\r\napp.use(compress({\r\n  threshold: 2048,\r\n  flush: require('zlib').Z_SYNC_FLUSH\r\n}))\r\n// 错误提醒中间件\r\napp.use(notifyError)\r\n// 使用当前目录下文件处理 404 请求\r\napp.use(staticFallback)\r\n// 各种 route 实现\r\napp.use(router.routes())\r\napp.use(router.allowedMethods())\r\n// 对于 public 目录启用静态文件服务\r\napp.use(require('koa-static')(path.resolve(__dirname, '../public')))\r\n// 创建启动服务\r\nlet server = http.createServer(app.callback())\r\nserver.listen(3000)\r\nrouter.jsrouter.get('/', function *() {\r\n  // 加载 index.html 模板和数据，输出 index 页面\r\n})\r\n\r\nrouter.get('/appservice', function *() {\r\n  // 加载 service.html 模板和数据，输出 service 页面\r\n})\r\n\r\n// 让 `/app/**` 加载小程序所在目录文件\r\nrouter.get('/app/(.*)', function* () {\r\n  if (/\\.(wxss|js)$/.test(file)) {\r\n    // 动态编译为 css 和相应 js\r\n  } else if (/\\.wxml/.test(file)) {\r\n    // 动态编译为 html\r\n  } else {\r\n    // 查找其它类型文件, 存在则返回\r\n    let exists = util.exists(file)\r\n    if (exists) {\r\n      yield send(this, file)\r\n    } else {\r\n      this.status = 404\r\n      throw new Error(`File: ${file} not found`)\r\n    }\r\n  }\r\n})\r\n第三步：实现控制层功能实现完上面两步，就可以访问 view 页面了，但是你会发现它只能渲染，并不会有任何功能，因为 view 层功能依赖于控制层进行的通讯， 如果控制层收不到消息，它不会响应任何事件。控制层是整个实现过程中最复杂的一块，因为官方工具的代码与 nwjs 以及 react 等第三方组件耦合过高，所以无法拿来直接使用。 你可以在 wept 项目的 src 目录下找到控制层逻辑的所有代码，总体上控制层要负责以下几个功能：实现 service 层，view 层以及控制层之间的通讯逻辑依据路由指令动态创建 view （wept 使用 iframe 实现）根据当前页面动态渲染 header 和 tabbar实现原生 API 调用，返回结果给 service 层wept 里面 iframe 之间的通讯是通过 message.js 模块实现的，控制页面（index.html）代码如下：window.addEventListener('message', function (e) {\r\n  let data = e.data\r\n  let cmd = data.command\r\n  let msg = data.msg\r\n  // 没有跟 contentscript 握手阶段，不需要处理\r\n  if (data.to == 'contentscript') return\r\n  // 这是个遗留方法，基本废弃掉了\r\n  if (data.command == 'EXEC_JSSDK') {\r\n    sdk(data)\r\n  // 直接转发 view 层消息到 service，主要是各种事件通知\r\n  } else if (cmd == 'TO_APP_SERVICE') {\r\n    toAppService(data)\r\n  // 除了 publish 发送消息给 view 层以及控制层可以处理的逻辑（例如设置标题），\r\n  // 其它全部转发 service 处理，所有控制层的处理结果统一先返回 service\r\n  } else if (cmd == 'COMMAND_FROM_ASJS') {\r\n    let sdkName = data.sdkName\r\n    if (command.hasOwnProperty(sdkName)) {\r\n      command[sdkName](data)\r\n    } else {\r\n      console.warn(`Method ${sdkName} not implemented for command!`)\r\n    }\r\n  } else {\r\n    console.warn(`Command ${cmd} not recognized!`)\r\n  }\r\n})\r\n具体实现逻辑可以查看 src/command.js src/service.jssrc/sdk/*.js。对于 view/service 页面只需把原来 bridge.js 的window.postMessage 改为 window.top.postMessage 即可。view 层的控制逻辑由 src/view.js 以及 src/viewManage.js 实现，viewManage 实现了 navigateTo， redirectTo 以及 navigateBack 来响应 service 层通过名为 publish 的 command 传来的对应页面路由事件。header.js 和 tabbar.js 包含了基于 react 实现的 header 和 tabbar 模块（原计划是使用 vue，但是没找到与原生 js 模块通讯的 API）sdk 目录下包含了 storage，录音，罗盘模块，其它比较简单一些的原生底层调用我直接写在 command.js 里面了。以上就是实现运行小程序所需 webserver 的全部逻辑了，其实现并不复杂，主要困难在与理解微信这一整套通讯方式。实现小程序实时更新第一步： 监视文件变化并通知前端wept 使用了 chokidar 模块监视文件变化，变化后使用 WebSocket 告知所有客户端进行更新操作。 具体实现位于 lib/watcher.js 和 lib/socket.js, 发送内容是 json 格式的字符串。前端控制层收到 WebSocket 消息后再通过 postMessage 接口转发消息给 view/service 层：view.postMessage({\r\n  msg: {\r\n    data: {\r\n      data: { path }\r\n    },\r\n    eventName: 'reload'\r\n  },\r\n  command: 'CUSTOM'\r\n})\r\nview/service 层监听 reload 事件：WeixinJSBridge.subscribe('reload', function(data) {\r\n  // data 即为上面的 msg.data\r\n})\r\n第二步： 前端响应不同文件变化前端需要对 4 种（wxml wxss json javascript）不同类型文件进行 4 种不同的热更新处理，其中 wxss 和 json 相对简单。wxss 文件变化后前端控制层通知（postMessage 接口）对应页面（如果是 app.wxss 则是所有 view 页面）进行刷新，view 层收到消息后只需要更改对应 css 文件的时间戳就可以了，代码如下：o.subscribe('reload', function(data) {\r\n    if (/\\.wxss$/.test(data.path)) {\r\n    var p = '/app/' + data.path\r\n    var els = document.getElementsByTagName('link')\r\n    ;[].slice.call(els).forEach(function(el) {\r\n      var href = el.getAttribute('href').replace(/\\?(.*)$/, '')\r\n      if (p == href) {\r\n        console.info('Reload: ' + data.path)\r\n        el.setAttribute('href', href + '?id=' + Date.now())\r\n      }\r\n    })\r\n  }\r\n})\r\njson 文件变化首先需要判断，如果是 app.json 我们无法热更新，所以目前做法是刷新页面，对于页面的 json， 我们只需要在控制层上对 header 设置相应状态就可以了 (渲染工作由 react 帮我们处理)：socket.onmessage = function (e) {\r\n  let data = JSON.parse(e.data)\r\n  let p = data.path\r\n  if (data.type == 'reload'){\r\n    if (p == 'app.json') {\r\n      redirectToHome()\r\n    } else if (/\\.json$/.test(p)) {\r\n      let win = window.__wxConfig__['window']\r\n      win.pages[p.replace(/\\.json$/, '')] = data.content\r\n      // header 通过全局 __wxConfig__ 获取 state 进行渲染\r\n      header.reset()\r\n      console.info(`Reset header for ${p.replace(/\\.json$/, '')}`)\r\n    }\r\n  }\r\n}\r\nwxml 使用 VirtualDom API 提供的 diff apply 进行处理。首先需要一个接口获取新的 generateFunc 函数（用于生成 VirtualDom）， 添加 koa 的 router：router.get('/generateFunc', function* () {\r\n  this.body = yield loadFile(this.query.path + '.wxml')\r\n  this.type = 'text'\r\n})\r\n\r\nfunction loadFile(p, throwErr = true) {\r\n  return new Promise((resolve, reject) => {\r\n    fs.stat(`./${p}`, (err, stats) => {\r\n      if (err) {\r\n        if (throwErr) return reject(new Error(`file ${p} not found`))\r\n        // 文件不存在有可能是文件被删除，所以不能使用 reject\r\n        return resolve('')\r\n      }\r\n      if (stats && stats.isFile()) {\r\n        // parer 函数调用 exec 命令执行 wcsc 文件生成 wxml 对应的 javascript 代码\r\n        return parser(`${p}`).then(resolve, reject)\r\n      } else {\r\n        return resolve('')\r\n      }\r\n    })\r\n  })\r\n}\r\n有了接口就可以请求接口，然后执行返回函数进行 diff apply：// curr 为当前的 VirtualDom 树\r\nif (!curr) return\r\nvar xhr = new XMLHttpRequest()\r\nxhr.onreadystatechange = function() {\r\n  if (xhr.readyState === 4) {\r\n    if (xhr.status === 200) {\r\n      var text = xhr.responseText\r\n      var func = new Function(text + '\\n return $gwx(\"./' +__path__+ '.wxml\")')\r\n      window.__generateFunc__ = func()\r\n      var oldTree = curr\r\n      // 获取当前 data 生成新的树\r\n      var o = m(p.default.getData(), false),\r\n      // 进行 diff apply\r\n      a = oldTree.diff(o);\r\n      a.apply(x);\r\n      document.dispatchEvent(new CustomEvent(\"pageReRender\", {}));\r\n      console.info('Hot apply: ' + __path__ + '.wxml')\r\n    }\r\n  }\r\n}\r\nxhr.open('GET', '/generateFunc?path=' + encodeURIComponent(__path__))\r\nxhr.send()\r\njavascript 更新逻辑相对复杂一些, 首先依然是一个接口来获取新的 javascript 代码：router.get('/generateJavascript', function* () {\r\n  this.body = yield loadFile(this.query.path)\r\n  this.type = 'text'\r\n})\r\n然后我们在 window 对象上加入 Reload 函数执行具体的更换逻辑：window.Reload = function (e) {\r\nvar pages = __wxConfig.pages;\r\nif (pages.indexOf(window.__wxRoute) == -1) return\r\n// 替换原来的构造函数\r\nf[window.__wxRoute] = e\r\nvar keys = Object.keys(p)\r\n// 判定是否当前使用中页面\r\nvar isCurr = s.route == window.__wxRoute\r\nkeys.forEach(function (key) {\r\n  var o = p[key];\r\n  key = Number(key)\r\n  var query = o.__query__\r\n  var page = o.page\r\n  var route = o.route\r\n  // 页面已经被创建\r\n  if (route == window.__wxRoute) {\r\n    // 执行封装后的 onHide 和 onUnload\r\n    isCurr && page.onHide()\r\n    page.onUnload()\r\n    // 创建新 page 对象\r\n    var newPage = new a.default(e, key, route)\r\n    newPage.__query__ = query\r\n    // 重新绑定当前页面\r\n    if (isCurr) s.page = newPage\r\n    o.page = newPage\r\n    // 执行 onLoad 和 onShow\r\n    newPage.onLoad()\r\n    if (isCurr) newPage.onShow()\r\n    // 更新 data 数据\r\n    window.__wxAppData[route] = newPage.data\r\n    window.__wxAppData[route].__webviewId__ = key\r\n    // 发送更新事件, 通知 view 层\r\n    u.publish(c.UPDATE_APP_DATA)\r\n    u.info(\"Update view with init data\")\r\n    u.info(newPage.data)\r\n    // 发送 appDataChange 事件\r\n    u.publish(\"appDataChange\", {\r\n      data: {\r\n        data: newPage.data\r\n      },\r\n      option: {\r\n        timestamp: Date.now()\r\n      }\r\n    })\r\n    newPage.__webviewReady__ = true\r\n  }\r\n})\r\nu.info(\"Reload page: \" + window.__wxRoute)\r\n}\r\n以上代码需要添加到 t.pageHolder 函数后才可运行最后在 view 层初始化后把 Page 函数切换到 Reload 函数(当然你也可以在请求返回 javascript 前把 Page 重命名为 Reload) 。<body>\r\n<script>\r\n  window._____sendMsgToNW({\r\n    sdkName: 'APP_SERVICE_COMPLETE'\r\n  })\r\n</script>\r\n</body>\r\n总算是把这个坑填上了。希望通过这一系列的分析带给前端开发者更多思路。"}
{"title": "微信小程序技术教程：集成 Redux", "author": "天下雪", "time": "2016-10-15 21:48", "content": "示例Redux是什么Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux官方文档为什么要使用Redux小程序俨然是一个类似Hybrid App的东西，前面是SPA，小程序提供一些原生功能的接口。现在前端程序规模都比较大，页面状态，数据缓存，需要管理的东西太多。引入Redux可以方便的管理这些状态。并且Redux丰富的周边工具也是很有吸引力的。集成Redux小程序的模块化微信的文档并没有指出如何使用第三方库，所以只能从微信小程序的模块化入手。文档中提到，模块化的关键是：module.exports = function(){}同时，如果我们去观察小程序开发环境的network面板，点击任何一个js，我们可以发现：项目目录中的所有js文件都会自动被加载，无论我们是否在代码中require所以的模块都会被套上下面的代码：define(\"reducers/visibilityFilter.js\", function(require, module){var window={Math:Math}/*兼容babel*/,location,document,navigator,self,localStorage,history,Caches;/*******************//******你写的代码******/                                                                 /********************/})这实际上是类似AMD的加载方式，但是跟标准的AMD又有些不同，缺少了依赖部分的声明。function(require, module){}: 这个函数包裹的是模块的实现，也就是我们自己写的代码，小程序给我们暴露了两个参数require和module，require用来在模块中加载其他模块，module用来将模块中的方法暴露出去：module.exports = function(){}所以只要需要让第三方库的代码使用这种形式的export就可以了。构建Redux的微信小程序包这里主要目标是打一个Redux包，让它可以兼容微信小城的加载方式下载Redux的代码到本地：git clone https://github.com/reactjs/redux.git安装依赖：npm install打包：npm run build:umd && npm run build:umd这些命令的详细内容可以到redux项目的package.json中查看。这些命令是是使用webpack构建UMD模式的包。也就是说所有的代码，包括依赖的库都会被打包到一个文件中，并且自带一段模块加载代码，文件可以在dist目录下找到。带min.js后缀的是minify过的。      4.微调加载方式：用编辑器打开dist目录下的redux.js文件(function webpackUniversalModuleDefinition(root, factory) {    if(typeof exports === 'object' && typeof module === 'object')        module.exports = factory();    else if(typeof define === 'function' && define.amd)        define([], factory);    else if(typeof exports === 'object')        exports[\"Redux\"] = factory();    else        root[\"Redux\"] = factory();})(this, function() {...  })这段代码是用来加载模块的，里面的factory函数的返回的内容是用webpack提供的loader组织起来的redux的代码和第三方依赖。如果我们把这个文件拷贝到小程序中，只需要让程序能正常进入第三行代码，就能把Redux加载进来。将第二行代码：if(typeof exports === 'object' && typeof module === 'object')      修改成：if(typeof module === 'object')这样修改的原因是，在微信小程序的环境中是没有exports变量的，所以就没办法正确进入这个分支，删除之后就可以正确进入了拷贝进工程目录例如，我们拷贝到libs目录下，那么我们在程序中使用时，只要当做是一个本地模块去require就可以了：var redux = require('./libs/redux.js')通过这里的示例，其实我们发现，我们可以通过类似的方法，使用Webpack打包第三方库，就可以集成任何库了。使用Redux我们可以使用Redux的微信小程序绑定库来简化一些代码：wechat-weapp-redux，详细的安装和使用说明可以参照wechat-weapp-redux的README集成Redux-devtools如果没有redux-devtools那么使用redux的效果可能是要减半的。因为微信小程序的开发环境是定制的，暂时没有发现办法直接安装redux-devtool的插件。这里使用remote-redux-devtools，remotedev-server安装remote-redux-devtools原版的remote-redux-devtools使用的一个websocket的依赖会使用原生的WebSocket，小程序是不支持的，所以需要改成小程序的websocket实现。修改好的包在这里：remote-redux-devtools把代码下载到工程目录里面就可以用了。安装和启动remotedev-servernpm install -g remotedev-serverremotedev --hostname=localhost --port=5678          因为没办法用npm安装到本地（开头提到的，微信小程序会尝试去加载项目目录中的所有js），所以这里使用全局安装，第二条命令是启动remotedev-server，hostname和port分别指定为localhost和5678。     3.  集成devtoolconst {createStore, compose} = require('./libs/redux.js');const devTools = require('./libs/remote-redux-devtools.js').default;const reducer = require('./reducers/index.js')function configureStore() {  return createStore(reducer, compose(devTools({    hostname: 'localhost',    port: 5678,    secure: false  })));}module.exports = configureStore;把devtool使用redux的compose加到store中去。hostname和port是指定为之前启动remotedev-server启动时候指定的参数。保存之后重启一下小程序，如果没有报错的话就OK了      4.  打开监视器          可以在浏览器中访问localhost:5678，这是remotedev-server自带的监视器，正常打开的话是这样的：          左边有一个@@INIT说明小程序的redux连接成功了。但是这里这个自带的监视器可能打不开，因为它的一些js包是存在国外的cdn上的，偶尔访问不到。这个时候可以使用http://remotedev.io/local/，点击下面的setting，设置使用本地的server。保存之后刷新页面，应该跟上面显示的结果一样。示例详细的代码示例，可以参照：wechat-weapp-redux-todos"}
{"title": "梁兴臣:微信小程序开发三宗罪和解决方案", "author": "天下雪", "time": "2016-10-15 22:33", "content": "在微信公布小程序的文档和开发工具后，脉冲软件在第一时间进行了学习和体验，我们发现微信小程序的技术架构和开发体验让我们非常失望。由于微信小程序的运行环境并不是一个标准的浏览器环境，而且微信的封装工作并不完善，所以我们以往开发中的很多经验并不适用。这并非简单的开发习惯不适应，更重要的是我们的开发流程、规范将不适用。微信小程序开发第一宗罪: 无法调用NPM包虽然微信小程序开发工具打包时实现了require函数加载依赖，但并不是完整的CommonJS依赖管理。因为require函数仅仅能够加载项目中的JS文件，而且必须严格定义JS文件路径，路径不支持CommonJS的路径风格。例如如下加载方式都将出错：require('lodash');require('lodash/map');require('./foo');在微信小程序开发工具中，我们必须对应写为如下格式：require('node_modules/lodash/lodash.js');require('node_modules/lodash/map.js');require('./foo.js');虽然我们可以像上面代码一样加载node_modules目录中的库，但是实际运行时却发生了：在调试工具的Network选项卡中，我们看到运行时加载了1000多个文件，总数据量1.8MB，而我们仅仅是在代码中加载了一个lodash库而已！这是因为微信小程序开发工具会将所有项目下的js文件视为项目文件，并进行打包。而实际开发中，我们需要安装很多的NPM扩展库，而这些扩展库中有大量的不需要打包的文件，例如lodash中有上千文件，而我们只需要用到其中的非常少的一部分。另外，在开发中，我们往往需要安装babal、eslient、webpack、grunt等待开发工具，微信小程序开发工具会一视同仁将这些工具的源码也进行打包......实测开发者工具将崩溃！开发者将崩溃！我崩溃！所以不支持NPM包的原因，是微信开发者工具不支持CommonJS标准，不支持CommonJS标准的原因，是微信开发者工具想当然地认为项目目录下的js文件一定是项目文件，所以只实现了简单的require函数，想当然的原因是。。。微信小程序开发第二宗罪: 无法使用Babel转码无法使用Babel转码的原因其实仍然归结于无法加载NPM库。但是后果将十分严重。因为你将不能再安全使用ES6/7特性，你将无法使用async/await函数，你将和无尽的callback做斗争，你该怎样描述自己？回调地狱中的苦逼程序员？如果你看到这里不明白Babel为何物，那么祝贺你，因为不曾见过天堂就不知何为地狱，你无须为不支持ES6/7而烦恼。但一旦你的大脑支持了ES6/7，用过了Babel，你就回不去了，像我一样，无Babel不编码。微信小程序开发第三宗罪: 无法重用组件其实微信小程序开发是并非完全不能重用组件，比如WXML语法中支持import和 include。但是那仅仅是视图模板可重用，并非组件可重用，因为我们认为组件在应当包含视图和逻辑。WXML其实是基于可重用的组件，但是不允许我们自定义组件。如果你有React经验，你就会明白我的意思。例如，你的小程序是个电商APP，项目中有两个页面中同时包含了商品列表组件，比如某分类下商品列表和搜索结果列表，我们知道这两个列表其实仅仅是参数不同而已。但是在小程序开发中，你只能将列表的模板抽象出来，不能将逻辑抽象出来，所以你就需要在两个页面上都实现一遍列表组件的控制逻辑，比如刷新、加载更多。。。我们的实践只吐槽、管杀不管埋是不道德的，既然发现了微信小程序开发中的各种弊端，我们脉冲软件在开发之中总结出了一套流程和工具，专为解决上述三个问题，并免费发布到了开源社区，这就是Labrador。接下来我们一起来尝试一下我们脉冲软件的开发体验。安装Labrador通过命令 npm install -g labrador-cli 全局安装Labrador控制行工具。初始化项目通过如下命令新建一个Labrador项目：mkdir democd demonpm initlabrador init项目初始化完成后，该目录是这个样子的：图中的src是我们的源码目录，node_modules是NPM包目录，dist是目标输出目录。请在开发者工具中新建一个项目，并设置路径到dist目录，请勿设置为demo目录！使用WebStorm或Sublime打开demo目录，开发过程中，我们使用WebStorm或Sublime修改src目录下的源码，请勿直接修改dist目录中的文件，因为dist目录是通过labrador命令生成的。在demo目录中运行 labrador build 命令编译项目，该命令会将src目录下的文件一一处理并生成dist目录下对应的文件。我们也可以运行 labrador watch 命令监控src目录下的文件变化，这样就不用每次修改后手动运行编译命令。加载NPM包我们以lodash包为例，在src/app.js中键入代码 const _ = require('lodash'); 编译后，我们看到dist目录下的文件是这样的：我们看到dist目录下有一个npm/lodash目录，该目录下只有一个lodash.js文件，那么在微信web开发者工具中打包预览，lodash的库将只有这个文件被加载。这一切是怎么发生的？我们看一下dist/app.js的源码，发现源码中const _ = require('lodash'); 被编译为 var _ = require('./npm/lodash/lodash.js'); 然后labrador命令将node_modules/lodash/lodash.js 文件复制到了dist/npm/lodash/lodash.js 。这就是通过labrador可以调用NPM包的原理。重要的是，只有真正用到的js文件才被labrador命令加入到项目目录中。这样一个小小的改进象征着我们的小程序可以便捷调用NPM仓库中海量的扩展库！Babel转码在初始化的示例代码src/app.js中的内容是这样的：图中timer和getUserInfo属性都为async函数，函数体内使用await调用异步操作。labrador 库对微信API进行了封装，使用 const wx = require('labrador'); 覆盖默认的全局变量wx; 封装后的wx对象提供的异步方法返回的都是Promise异步对象，结合async/await函数彻底终结callback，将异步代码同步写，轻松逃离回调地狱！但目前async/await函数是不被浏览器支持的，我们需要使用babel对其转码，labrador编译命令已经内置了babel转码，转码后的代码可以查看dist/app.js，内容过长，不再张贴。重用组件重用组件最需要解决的问题是组件的逻辑代码怎样重用。在实例代码中有一个src/components目录，用来存放项目内的可重用组件，其结构是这样的：子目录src/components/list中存放着一个可重用的组件。list.js / list.less / list.xml 分别对应微信小程序的 js / wxss / wxml 文件。JS为控件的逻辑层，其代码如下：文件导出一个List类，这个组件类拥有像Page一样的生命周期函数onLoad, onReady, onShow, onHide, onUnload 以及setData函数。LESS文件对应微信的WXSS文件，因为微信小程序实现的限制，LESS中无法使用连级选择语法，但是可以定义变量，方便开发。XML文件对应微信的WXML文件，是组件视图描述文件，list.xml内容为：文件中导出一个名为list的template。组件不但可以存放在src/components目录内，还可以单独做成NPM包，这样就可以轻松做到跨项目间的组件共享。组件定义完成后，接下来是在页面中调用，在 src/pages/index/index.js 中有如下代码：代码中首先引入了labrador库替换全局的默认wx对象，并使用labrador.createPage方法代替全局的Page函数声明页面。然后加载List组件类，在页面声明配置中，增加了components属性，并将List组件类实例化传入。labrador.createPage方法是对Page方法的一层封装，目的是在页面初始化时和组件对象进行关联。在 src/pages/index/index.less 中加入代码 @import 'list' 即可调用list组件的样式，如果在src/components/list中找不到list.less，那么编译命令将在NPM包中寻找 node_modules/list/index.less 。在 src/pages/index/index.xml 中加入代码 <component key=\"list\"/> 即可调用list组件的模板文件，component 是Labrador自定义的组件，编译后对应生成 import 和 template。如果在src/components/list中找不到list.xml，那么编译命令将在NPM包中寻找 node_modules/list/index.xml"}
{"title": "新手入门福音：微信小程序试水体验过程", "author": "天下雪", "time": "2016-10-16 13:26", "content": "1. https://mp.weixin.qq.com注册一个公众号，成为开发者，拿到一个appId。2. 下载微信开发者工具，https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1476197489869。3. 使用微信扫码登录4. 添加一个项目，把注册公众号获得到的appId复制到appId，名称目录填写好后，点击添加项目，显示小程序还处于内测阶段，没有被邀请的用户获取的appId无法使用，尝试认证，但个人用户无法认证（有说关注大于500的可以，一时难以凑齐，弃之），因2013年以后公众号无法升级为服务号，于是又开始注册服务号，因为不是企业，没有各种相关信息，又弃之，最后只能选择无appId进行项目添加，虽少些功能，但也大体可以使用。往一个空的文件夹中添加项目，会自动创建一个获取信息和登录日志的小demo，结构非常清晰（加了几个接口和一个文件夹detail图）.js => .js   .wxml => .html  .wxss => .css  .json => .json 点击调试可以看到效果，头像，昵称，和helloword（因为是扫码登录，开发者工具绑定了开发者信息，所以可以拿到个人信息）。点击左侧编辑可对代码进行编辑，编辑完后保存、编译就可查看新效果。"}
{"title": "微信小程序试水教程：参数传递", "author": "天下雪", "time": "2016-10-16 13:42", "content": "教程一：参数传递这里我找到两种小程序上的参数传递方式，为了方便，我单独拿出来和大家分享下.一、通过事件进行参数传递先来看眼小程序对事件的定义：#什么是事件?\r\n\r\n这里是列表文本事件是视图层到逻辑层的通讯方式。\r\n这里是列表文本事件可以将用户的行为反馈到逻辑层进行处理。\r\n这里是列表文本事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。\r\n这里是列表文本 事件对象可以携带额外信息，如id, dataset, touches。\r\n很明确的指出了是视图层【wxml】到逻辑层【js】的通信方式，时间对象可以携带额外信息，用这个事件来传递参数肯定没错了，接下来我们就来实际看下例子：视图.wxml  <view id=\"tapTest\" data-hi=\"MINA\" bindtap=\"tapName\"> Click me! </view>\r\n逻辑.jsPage({\r\n  tapName: function(event) {\r\n            console.log(event.target)\r\n  }\r\n})\r\nlog打印可以看到 dataset 里面就是我们设置的data-hi=\"MINA\"的值了。现在我们来看下刚刚我们写的， 首先 bindtap,以bind开头的就是要给他绑定个事件，这个事件的名字就是“=”号后面的数值就是绑定的事件名称，需要在 逻辑【js】层定义上。 然后就是传值了，注意到的朋友可以看到 我们这里写了data-hi 和我们平时写js的传值是同一个定义方法。这个data-*就对应事件的属性target里的dataset 值。这里我们需要调用的话就是event.target.dataset.hi就能取到data-hi所对应的值。这里需要注意下 data的定义名称： 书写方式： 以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.target.dataset 中会将连字符转成驼峰elementType。官方示例：<view data-alpha-beta=\"1\" data-alphaBeta=\"2\" bindtap=\"bindViewTap\"> DataSet Test </view>\r\n\r\nPage({\r\n  bindViewTap:function(event){\r\n    event.target.dataset.alphaBeta == 1 // - 会转为驼峰写法\r\n    event.target.dataset.alphabeta == 2 // 大写会转为小写\r\n  }\r\n})\r\n二、navigator 跳转url传参*.wxml<view class=\"btn-area\">\r\n  <navigator url=\"navigate?title=navigate\" hover-class=\"navigator-hover\">跳转到新页面</navigator>\r\n  <navigator url=\"redirect?title=redirect\" redirect hover-class=\"other-navigator-hover\">在当前页打开</navigator>\r\n</view>\r\n*.js 跳到新页面之后在onload里面直接接收参数，接收方法也就是 options.[参数值]Page({\r\n  onLoad: function(options) {\r\n    this.setData({\r\n      title: options.title\r\n    })\r\n  }\r\n})\r\n好啦，今天就写到这里，我顺便把文档链接写上，上面写的文档里都有。我只是把它们搬出来了，用我的话说了一遍。 …(⊙＿⊙；)…什么是事件navigator"}
{"title": "微信小程序试水教程：富文本转文本", "author": "天下雪", "time": "2016-10-16 13:47", "content": "最近小程序这么火，我也来搞搞。发现了一个恶心的问题。小程序没有组件能支持富文本内容的，改接口又不太合适，于是有了这问，没技术含量纯粹记录首先我们看眼没有被格式的富文本显示：*.wxml内代码。content是富文本内容    <view>\r\n     <text>{{content}}</text>\r\n    </view>\r\n显示结果：由以上图片看到，小程序无法解析html文件我们需要处理html富文本内容，让其显示好看点下面直接上代码了，主要功能就是利用js的replace 对富文本经行处理，大家可以看一下。一起优化，方便对富文本更好的处理。convertHtmlToText: function convertHtmlToText(inputText) {\r\n    var returnText = \"\" + inputText;\r\n    returnText = returnText.replace(/<\\/div>/ig, '\\r\\n');\r\n    returnText = returnText.replace(/<\\/li>/ig, '\\r\\n');\r\n    returnText = returnText.replace(/<li>/ig, '  *  ');\r\n    returnText = returnText.replace(/<\\/ul>/ig, '\\r\\n');\r\n    //-- remove BR tags and replace them with line break\r\n    returnText = returnText.replace(/<br\\s*[\\/]?>/gi, \"\\r\\n\");\r\n\r\n    //-- remove P and A tags but preserve what's inside of them\r\n    returnText=returnText.replace(/<p.*?>/gi, \"\\r\\n\");\r\n    returnText=returnText.replace(/<a.*href=\"(.*?)\".*>(.*?)<\\/a>/gi, \" $2 ($1)\");\r\n\r\n    //-- remove all inside SCRIPT and STYLE tags\r\n    returnText=returnText.replace(/<script.*>[\\w\\W]{1,}(.*?)[\\w\\W]{1,}<\\/script>/gi, \"\");\r\n    returnText=returnText.replace(/<style.*>[\\w\\W]{1,}(.*?)[\\w\\W]{1,}<\\/style>/gi, \"\");\r\n    //-- remove all else\r\n    returnText=returnText.replace(/<(?:.|\\s)*?>/g, \"\");\r\n\r\n    //-- get rid of more than 2 multiple line breaks:\r\n    returnText=returnText.replace(/(?:(?:\\r\\n|\\r|\\n)\\s*){2,}/gim, \"\\r\\n\\r\\n\");\r\n\r\n    //-- get rid of more than 2 spaces:\r\n    returnText = returnText.replace(/ +(?= )/g,'');\r\n\r\n    //-- get rid of html-encoded characters:\r\n    returnText=returnText.replace(/&nbsp;/gi,\" \");\r\n    returnText=returnText.replace(/&amp;/gi,\"&\");\r\n    returnText=returnText.replace(/&quot;/gi,'\"');\r\n    returnText=returnText.replace(/&lt;/gi,'<');\r\n    returnText=returnText.replace(/&gt;/gi,'>');\r\n\r\n   return returnText;\r\n}\r\n将上面代码放入任意适合的小程序js文件中， 然后在需要处理数据的js文件里，引入文件，下面给出放入app.js文件中的调用示例：var app = getApp()//获取app小程序实例\r\n onLoad: function (options) {\r\n       wx.request({\r\n      url: 'http://example.com/api' + options.id+'.json',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      success: function (res) {\r\n       res.data.content =  app.convertHtmlToText(res.data.content )\r\n         that.setData({\r\n           art: res.data.content\r\n         })\r\n         console.log(res.data)\r\n      }\r\n    })\r\n｝\r\n然后编译刷新下，可以看到结果了：这里可以继续调整下css，使显示得更好看点。"}
{"title": "前端之巅：在Chrome浏览器上运行微信小程序", "author": "天下雪", "time": "2016-10-16 17:36", "content": "微信小程序的开发框架体验起来，还不错——自带了UI框架。但是问题是它的IDE，表现起来相当的糟糕——其实主要是因为，我当时买WebStorm License买了好多年。所以，我觉得他的IDE真不如我这个付费好用。而且，作为一个拥护自由和开源的“GitHub 中国区首席Markdown程序员”。微信在微信小程序引导着Web开向封闭，我们再也不能愉快地分享我们的代码了。如果我们放任下去，未来的Web世界令人堪忧。好了，废话说完了，本文只是一个Demo的介绍。文章太长不想看，可以直接看Demo哈哈：GitHub: https://github.com/phodal/weapp-webdemo 预览：http://weapp.phodal.com/真实世界下的MINA三基本元素微信小程序的背后运行的是一个名为MINA框架。在之前的几篇文章里，我们介绍得差不多了。现在让我们来作介绍pipeline：Transform WXML和WXSS当我们修改完WXML、WXSS的时候，我们需要重新编译项目才能在浏览器上看到效果。这时候后台就会执行一些transform动作： WCC来转换WXML为一个genrateFun，执行这个方法将会得到一个Virtual DomWXSS就会转换WXSS为CSS——这一点有待商榷。WCC和WXSS，可以从vendor目录下获取到，在“微信Web开发者工具”下敲入help，你就会得到下面的东东：运行openVendor()，你就会得到上面的WCSS、WXSS、WAService.js、WAWebview.js四个文件了。Transform js文件对于JS文件来说，则是一个拼装的过程，如下是我们的app.js文件：它在转换后会变成：我假装你已经知道这是什么了，反正我也不想、也不会解释了~~。同理于：至于它是如何replace或者apend到HTML中，我就不作解释了。MINA如何运行？为了运行一个Page，我们需要有一个Virtual Dom，即用WCC转换后的函数，如：然后在我们的HTML中加一个script，如就会凑发这个事件了。我简单的拆分了WXWebview.js得到了几个功能组件：define.js，这里就是定义AMD模块化的地方exparser.js，用于转换WXML标签到HTML标签exparser-behvaior.js，定义不同标签的一些行为mobile.js，应该是一个事件库，好像我并不关心。page.js，核心代码，即Page、App的定义所在。report.js，你所说的一切都能够用作为你的呈堂证供。virtual_dom.js，一个virtual dom实现结合wcc使用，里面应该还有component.css，也可能是叫weuiwa-wx.js，定义微信各种API以及WebView和Native的地方，和下面的WX有冲突。wx.js，同上，但是略有不同。wxJSBridge.js，Weixin JS Bridge于是，我就用上面的组件来定义不同的位置好了。当我们触发自定义的generateFuncReady事件时，将由virtual_dom.js来接管这次Render：因此，这里就是负责DOM初始化的地方了，这里得到的Dom结果是这样的：而我们写的WXML是这样的：很明显view会被转换为wx-view，text会被转换为wx-text等等，以此类推。这个转换是在virtual dom.js中调用的，调用的方法就是exparser。遗憾的是我现在困在 data 初始化上面了~~，这里面有两套不同的事件系统，有一些困扰。其中有一个是：WeixinJSBridge、还有一个是app engine中的事件系统，两个好像不能互调。使用WebStorm开发在浏览器上运行之前，我们需要简单的mock一些方法，如： window.webkit.messageHandlers.invokeHandler.postMessagewindow.webkit.messageHandlers.publishHandler.postMessageWeixinJSCore.publishHandlerWeixinJSCore..invokeHandler然后把 config.json中的一些内容变成__wxConfig，如： 如这里我们的appname是哈哈哈哈哈哈哈——我家在福建。然后在我们的HTML中引入各个JS文件，啦啦。我们还需要一个自动化的glup脚本来watch wxml和wxss的修改，然后编译，如：说了这么多，你还不如去看代码好了：GitHub: https://github.com/phodal/weapp-webdemo 预览：http://weapp.phodal.com/"}
{"title": "Runlin微信小程序系列教程一：从零开始写一个demo《中》", "author": "天下雪", "time": "2016-10-16 18:59", "content": "上一节写了一个首页列表的展示，现在我们需要一个效果：点击每个列表项，能后看到更多的细节和大图。在本页面展示或者加个弹窗是基本不可能的了。下面我们就创建一个新的页面来展示更多细节（我们之前已经创建了2个页面，其中rank页面还是空的，这里故意先不写，后面自然会补在）在pages下创建新的文件夹：detail，同时创建4个detail文件js,json,wxml,wxss对于每一个页面都需要写到app.json的pages中，因此要将我们新增的\"pages/detail/detail\"添加到“pages”数组中去。如果新增的页面是底部tabBar栏中的一项，还需要添加到tabBar中的List数组，我们这里是列表点击时的新页面，所以不需要写到list中。我们希望的效果大概是这样的：现在有一个问题时：我如何在点击的时候获取到对应的每一项的数据，并且在新的页面展示出来呢？这里要解决2个问题：###导航；参数的传递；导航 :实现导航的方法有2种，一种是直接利用navigator组件, 另一种是利用导航api，通过给列表添加点击事件，实现wx.navigateTo（保留当前页面，有左上角返回）或者wx.redirectTo（关闭当前页面，没有右上角返回按钮）。为了方便我们这里直接采用组件来写<block wx:for=\"{{moivelist}}\">   //在这之后插入导航标签    <navigator url=\"../detail/detail\">         //url对应文件的路径，不需要写后缀wxml    　　　　xxxxx还是原来的配方xxxxxxxx    </navigator></block>然后我们就可以实现点击跳转的效果了，但是这时候detail.wxml还是空白的。下面开始写detail.wxml<view class=\"container\">    <image class=\"imgs\" style=\"\" mode=\"\" src=\"{{item.images.large}}\" binderror=\"\" bindload=\"\"></image>    <text> {{item.title}} </text>        <text> {{\"评分\"+item.original_title}} </text>     <text> {{\"导演\"+item.directors[0].name}} </text>      <text> {{\"主演\"+item.rating.average}} </text> </view><view>    {{item.summary}}</view>跟之前index一样，我们这里的数据也是从js拿过来，不过这里是从detail.js拿的，但是这个时候detail.js中的data是没有数据的，因为我们希望数据是从index列表的每一项点击时传过来的，而不是我们直接写到detail.js里面的，这个时候就需要用到生命周期函数的onload函数了也就是说，每个页面在Onload时，都可以获取上一个页面传递给你的参数（假如有的话），那么现在要解决2个问题：1是上一个页面如何传给我，2是我如何接收数据。旧页面传递参数：我们刚才在index里面加了一个导航并且 url=\"../detail/detail\" ，需要传递参数时，仅需要在url后面：+?+数据例如：url=\"../detail/detail?id=test\"例如：https://i.cnblogs.com/EditPosts.aspx?opt=1可以发现格式其实就是get提交数据时的格式，写过html表单form的一定很熟悉了，需要提交多个参数时，需要在后面加 & 符号例如： url=\"../detail/detail?id=test1&name=test2&age=12345\"新页面接受数据 (注意只有在Onload时才可以接受传过来的数据)在新页面js中 onLoad: function(options) {console.log(options)} 即可打印出传过来的数据，你会发现这是一个对象，我们需要将这个对象,通过this.setData转化为新页面的数据，//我们这里为什么要用item是因为我们上面的数据绑定用的是{{item.xxx}}, 需要对应好，如果一个发生变动，另一个也要跟着改变//detai.js代码如下：Page({  data:{    title:\"加载中\",    item:{},    loading:false  },    onLoad:function(options){      this.setData({        item:options      })    },    onReady:function(){                 },        onShow:function(){    },        onHide:function(){    },        onUnload:function(){    }})detail.js就算写完了，CSS方面就不写了，比较无脑，没什么好讲的，简单设置一下样式不要太丑即可，整个detail的文件都搞定了。目前我们前面的第二个导航rank还空着呢，从表象上看，rank的格式跟index是一样，仅仅是数据不同，那么我们只要把index的文件复制一份过来就可以了，把模拟的数据改一下即可。虽然可以，但是代码很多重复，下面我们就引进一个新的东西叫模板 template 。定义一个name为test的模板<template name=\"test\">　　<view>hhahahha我是模板{{item}}</view></template>使用时，需要先引入所写的模板所在的位置<template is=\"test\" data={{item:\"你好模板\"}}></template>因此，同样的我们再创建一个文件夹template放模板，同时创建.js和.wxml文件这2个即可。 template.js并不需要数据，只是用来注册一下页面（不注册控制台有报错提示你page.js xxx什么的），将其他页面的.js复制过来，并将data里面的数据和其他的事件都出掉，保留最基本的空数据和空函数。template.wxml内容如下：<template name=\"try\" >    <navigator url=\"../detail/detail?imgsrc={{item.imgsrc}}&title={{item.title}}&author={{item.author}}&introduce={{item.introduce}}&rank={{item.rank}}\">            <view class=\"moive-item\">                    <image class=\"moive-img\" style=\"\" mode=\"\" src=\"{{item.imgsrc}}\" binderror=\"\" bindload=\"\"></image>                        <view class=\"moive-content\">                           <view class=\"content-titile\">                    <text>{{item.title}}</text>                </view>                                    <view class=\"content-introduce\">                     <text>{{item.introduce}}</text>                </view>                                    <view class=\"content-author\">                    <text>{{item.author}}</text>                    </view>                </view>                        <text class=\"content-rank\">{{item.rank}}</text>        </view>     </navigator></template>定义好模板好，将rank.wxml内容写为：<view class=\"head-title\" \">    <text>电影top20</text></view><scroll-view class=\"main\" scroll-y=\"true\" bindscrolltoupper=\"\" bindscrolltolower=\"\" bindscroll=\"\" scroll-into-view=\"\" scroll-top=\"\">      <import src=\"../temple/temple.wxml\"></import>       //引入模板     <block wx:for=\"{{moivelistB}}\">        <template is=\"try\" data=\"{{item}}\"></template>           //使用模板，并通过wx:for将数据循环展示出来     </block>   </scroll-view>将index.wxss和index.js文件复制一份到rank.js，同时将rank.js中data的数据稍微修改一下，不要让数据都跟index的一样.同时将我们的index.wxml中列表也修改为使用上面的模板，至此就基本完成了。回顾一下我们主要的知识点：导航写法，如何传递参数，声明周期函数，如何获取传递过来参数，如何定义和使用模板及使用参数。到此我们使用的都是虚拟的数据，下一篇我们将调用豆瓣提供的接口来调用数据，模拟跟后台的交互。demo2源文件见 https://github.com/linrunzheng/wx-samll-demo"}
{"title": "Runlin微信小程序系列教程一：从零开始写一个demo《下》", "author": "天下雪", "time": "2016-10-16 19:14", "content": "上一节实现了循环列表数据渲染到视图，并给列表每一项添加了路由导航到新页面查看更多细节，但是目前我们的数据都是虚拟的，现在我们就开始利用微信的request请求来接收豆瓣电影接口提供的数据。API: wx.request(OBJECT)参数有7个，这里主要讲一下几个重要的：url : 请求的地址data: 携带的数据method : 请求方式，默认为getsuccess: 请求成功的回调函数了解了网路请求的方法后，我们就不需要我们原来模拟的那些数据了，把所有的假数据统统干掉，留一个空的数据用来放数据即可。data:{    moivelist:[],    loading:false  }  现在页面进来的时候只展示了一个标题，因为数据为空了循环不出来了，现在需要我们在页面进来的时候发送一个请求来接受数据。豆瓣提供的API：[Title]https://developers.douban.com/wiki/?title=movie_v2#search具体参数和接口请自行查阅，使用方法：https://api.douban.com + 对应的接口 + 参数(如果需要的话)例子：https://api.douban.com/v2/movie/top250我们以请求 排行250 这个接口为例：onLoad: function() {        var url=https://api.douban.com/v2/movie/top250;        var that = this;//确保回调函数this的指向正确,后面会以es6的箭头函数代替        wx.request({            url：url,  //KEY和KEY值相同可简写为url            data: {},  //不要求数据            header: { 'Content-Type': 'application/json' },            //成功时的回调，res为返回值，需要储存到我们的data数据里面            success: function(res) {                that.setData({                    moivelist: res.data.subjects,                    loading: true                })              }           })        }写完后，页面进来的时候就会发送请求，并将数据保存到moiveList,并通过循环把数据展示出来，但是如果网络差的话，会有一段真空期是没有数据的，我们需要给用户一个提示。给页面添加一个loading<loading hidden=\"{{loading}}\">    加载中....</loading>###我们让这个loading一开始就是显示的，当数据加载成功后，才让他消失。我们通过将hidden绑定到{{loading}}上，更改{{loading}}的布尔值来实现这个效果。一开始{{loading}}的值是false的，也就是不隐藏；success后将他设置为true，从而实现这个效果。###这样我们这个页面就做好了，另一个页面同理，改变一下接口就行了，我们主要看一下detail这个文件。###我们现在可以实现网络请求了，在之前我们detail的数据都是外面从列表传过来的，我们是这么写的。<navigator url=\"../detail/detail?imgsrc={{item.imgsrc}}&title={{item.title}}&author={{item.author}}&introduce={{item.introduce}}&rank={{item.rank}}\">我靠这么长一段代码，真的需要吗？我们现在就可以简写了，我们只需要传一个参数就可以了。把template模板里面wxml里面上述代码改成下面的<navigator url=\"../detail/detail?id={{item.id}}\">我们只需要一个这个电影的ID就行了，我们可以根据这个ID自己请求数据//在detail.js的Onload函数中获取到页面传过来的ID onLoad: function(options) {        var that = this;        var address = 'https://api.douban.com/v2/movie/subject/';        wx.request({            url: address + options.id,            data: {},            header: { 'Content-Type': 'application/json' },            success: function(res) {                that.setData({                    item: res.data,                    loading: true                })            }        })    }这样就完成了，现在我们在tabBar新增一个搜索页面。记住新页面都要添加到app.json中，这里就不再阐述了，页面大概这个样子<import src=\"../temple/temple.wxml\"></import><loading hidden=\"{{loading}}\">    加载中....</loading><view class=\"searchWrap\">    <view class=\"inputWrap\">        <icon type=\"search\" size=\"20\"/>         <input placeholder=\"请输入搜索内容\"  value=\"{{content}}\" type=\"text\"  placeholder-style=\"custom-placeholder-style\" placeholder-class=\"custom-placeholder-class\"   bindinput=\"inputing\"  bindblur=\"quick\"/>    </view>      <view class=\"cancel\" bindtap=\"searching\">{{cancel}}</view></view><scroll-view class=\"main\" scroll-y=\"true\" bindscrolltoupper=\"\" bindscrolltolower=\"\" bindscroll=\"\" scroll-into-view=\"\" scroll-top=\"\">    <block wx:for=\"{{moivelist}}\">        <template is=\"try\" data=\"{{item}}\"></template>    </block></scroll-view>  下面的列表跟前面一样，就多个了Input和按钮而已，同样的wxss样式我们就不管了，只看js。主要代码如下：data: {        moivelist: [],        loading: true,        cancel: \"取消\",        search: \"\"    }   ,        inputing: function(event) {        if (event.detail.value) {            this.setData({                cancel: \"搜索\"            })        } else {            this.setData({                cancel: \"取消\"            })        }    },    //失去焦点事件    quick: function(event) {        if (!event.detail.value) {            this.setData({                cancel: \"取消\"            })        } else {            this.setData({                search: event.detail.value            })        }    },    //点击搜索事件    searching: function() {        if (this.data.cancel === \"取消\") {            wx.hideKeyboard()        } else {                      this.setData({                loading: false            })            wx.request({                url: url + this.data.search,                data: {},                header: { 'Content-Type': 'application/json' },                success: function(res) {                    that.setData({                        moivelist: res.data.subjects,                        loading: true                    })                }            })        }    }看起来写了很多，其实就2件事：* 判断Input的值，如果为空，则让按钮的值为“取消”；不为空则为“搜索”。* 根据按钮的值绑定点击事件，为取消则让键盘下去(手机才行）为“搜索”则发送网络请求，并将接收的数据保存以便循环展示出来。到此，几个文件就都写好了，现在来对代码优化一下。1. wxml：我们已经创建了一个通用的模板了，好像没得优化了。2. css : 可以发现我们几个列表都用了一个模板，因此对应的CSS代码也是一样的，我们可以把这部分CSS代码放到app.wxss公共样式里面，其他页面对应的WXSS那部分都可以删除了。3. js:wx.request时用到了基本相同的东西，可以放到一个单独的js里面。创建一个util文件夹，在里面创建一个util.js文件，用来放我们的方法。function getData(address,datas,cb){    wx.request({        url: address,        data:datas,        header: { 'Content-Type': 'application/json' },        success: cb    })}module.exports = {    getData: getData}我们定义了一个方法，并通过module.exports将他导出，其他页面需要使用方法时，需要先导入var util = require(\"../../utils/utils.js\")使用时：util.getData(参数1，参数2，参数3)如：onLoad: function() {        util.getData(url,{},(res)=>{          this.setData({              moivelist: res.data.subjects,              loading: true          })        })    }到此我们整个APP就算基本完成了，后续如果还有补充则再继续添加。代码参见demo4 ， 网址为：https://github.com/linrunzheng/wx-samll-demo"}
{"title": "Runlin微信小程序系列教程一：从零开始写一个demo《上》", "author": "天下雪", "time": "2016-10-16 18:55", "content": "本文已获得原作者授权微信小程序内测至今也有20天左右，也有很多人作出了很多不错的DEMO并发布到github了。前几日看见了豆瓣电影这个demo，感觉很不错，也跟着做了一个，作为复习巩固文档API用。废话不多说，直接进入正题：第一节只写一个首页的展示，数据用的是自己写的虚拟的数据 新建一个demo，不要使用微信自带的DEMO，直接从零开始写起：首先创建3个文件：app.jsonapp.jsapps.wxss app.json  : 主要写配置项：内容如下，具体的每个key值对应的意思，这里就不再细说了，可以看我之前的配置指南，{\"pages\":[\"pages/index/index\",\"pages/rank/rank\",],\"window\":{\"enablePullDownRefresh\":true,\"backgroundColor\":\"#eee\",\"navigationBarTitleText\": \"上导航标题文字\",\"navigationBarTextStyle\":\"white\" },\"tabBar\": {\"color\": \"#d7ced5\",\"selectedColor\": \"#535f71\",\"borderStyle\": \"white\", \"backgroundColor\": \"#f9f9f9\",\"list\": [ {\"pagePath\": \"pages/index/index\", \"text\": \"推荐电影\", \"iconPath\": \"images/board.png\", \"selectedIconPath\": \"images/board-actived.png\" },{\"pagePath\": \"pages/rank/rank\",\"text\": \"北美票房\",\"iconPath\": \"images/note.png\",\"selectedIconPath\": \"images/note-actived.png\"}]},\"networkTimeout\": {\"request\": 10000,\"downloadFile\": 9000,\"uploadFile\":8000,\"connectSocket\":7000},\"debug\": true} app.js  :  主要用来注册一个小程序的实例 App({onLaunch: function () {},onShow: function () {},onHide: function () {},globalData: 'I am global data'});  app.wxss : 公用样式，基本等同于CSS，暂时不需要写内容。 创建好3个文件后，就可以开始写页面的内容了：新创建2个文件夹images和pages，一个放图片一，个放页面。目前只pages下面再创建2个文件夹index和rank，每个文件下分别创建json,js,wxml,wxss文件，此时目录如下：虽然不一定4个文件类型都需要用到，但为了之后方便，建议还是先创建好，需要用到的时候就比较方便了，不用再去创建。首先写index.js:   (为了模拟循环数组，data下面的moivelist还需要多复制几份，这里只写了一份出来，imgsrc路径要写好) Page({    data:{    moivelist:[{    imgsrc: \"../../images/AN2.jpg\",    title: \"肖申克的救赎\",    introduce: \"The shrakwos RedenpeTion(1994)\",    author: \"弗兰克*德拉立邦\",    rank: \"9.6\"}]},onLoad: function(options) {console.log(1);},onReady: function() {// Do something when page ready.},onShow: function() {// Do something when page show.},onHide: function() {// Do something when page hide.},onUnload: function() {// Do something when page close.},onPullDownRefresh: function() {// Do something when pull down},// Event handler.viewTap: function() {this.setData({text: 'Set some data for updating view.'})}})这里出现了很多on函数事件，对应页面的生命周期每个过程对应的事件，这里暂时先关注data对象小程序是以数据驱动的，页面进来的时候通过动态获取数据，通过{{xxx}}将数据绑定，并将数据渲染到视图层，这里先以一个虚拟的data数据模拟 然后写index.wxml文件：从上面显示的首页的图片来看，主要是1个标题，以及下面一个列表，列表用过循环来渲染出所有的数据标题:  标题比较简单，主要是写css<view class=\"head-title\"><text>豆瓣电影top250</text></view>这里主要讲下面的列表循环，可以发现我们只要写好列表中的第一个就可以了，其他的通过循环来展示列表主要分为左中右三块，分别为图片，内容，以及评分3块<block wx:for=\"{{moivelist}}\">  //循环渲染，wx:for=\"{{ xxx }}\" 代表循环js文件里面的data数据中的xxx<view>//微信循环时会给出每个项目的内容以及每个项目的下标，默认为item和index，item.imgsrc意为对象的（imgsrc）  key值图片：<image class=\"moive-img\" style=\"\" mode=\"\" src=\"{{item.imgsrc}}\" binderror=\"\" bindload=\"\"></image>内容：<view class=\"moive-content\">     <view class=\"content-titile\">        <text >{{item.title}}</text>    </view>    <view class=\"content-introduce\">         <text >{{item.introduce}}</text>    </view>    <view class=\"content-author\">        < text >{{item.author}}</text>\t    </view>\t</view>评分：<text class=\"content-rank\">{{item.rank}}</text></view></block>   基本都这里wxml就结束了，样式主要通过wxss来操作，样式比较简单，就不写了，主要讲一下左中右这三块通过将左中右这三块的父级设置为display:flex;左边和右边都设置为固定rpx，中间设置为flex:1。这样写代表中间这一块的内容占满：左边和右边布局后生下来的空间 ，即左右布局好后，剩多少，flex：1就等于多少。 第一节项目代码见：demo1https://github.com/linrunzheng/wx-samll-demo"}
{"title": "lypeer：一名Android开发者的微信小程序填坑之路《下》", "author": "天下雪", "time": "2016-10-17 11:12", "content": "上一篇是九月二十七日写的，而这一篇我动笔的时间是十月十日（特殊的日子），中间相隔十三天——当然是因为国庆节。说老实话，这十三天里面我都没有碰和小程序有关的东西——毕竟学习小程序的开发也只是起于兴趣，而平时的工作并不会涉及与其相关的东西——但是在这十三天里，我能明显的感受到小程序热正在逐渐的消退，或者说大家正在逐渐以一种较为平和的姿态接受它的存在，其实这是一件好事。期待公测的到来。接下来我就直接进入正题了，另外，文末我想和大家分享一下我的国庆节。PS：这篇文章是接着上一篇文章 一名Android开发者的微信小程序填坑之路《上》 写的，建议没看过上一篇文章的同学先看一下上一篇哈~正文6，后台接收 post 请求要表单？首先问题是：我要向后台 post 一些数据，但是后台需要接收一个表单，我应该怎样获得一个表单或者将本地的数据转换成一个表单呢？在写 wechat-weapp-gank 的提交干货模块的时候，我就遇到了这个问题。一开始我挺纳闷的，明明是把后台需要的数据都给传过去了，结果后台老是跟我说我的数据不对，后来我才发现是因为后台那边要求接收一个表单，而我传过去的是一个 json 数据。于是我就开始了漫长的探索之旅。（就为了这一个问题，从晚上十一点多一直搞到第二天凌晨四点多。。。如果不是有一个群里有个老司机帮忙说不定就死在这个问题上了）首先我想的是能不能把现成的 json 数据直接转化为 form 表单？因为我已经完成了获取要输的信息然后把它变成了 json 数据的工作，如果能直接把 json 对象转化为 form 对象的话我需要对程序做的改动肯定是最小的。然而遗憾的是，似乎并没有可行的方案。（也有可能是因为我 js 功底太差吧，我确实是没有找到相应的方法，要生成一个 form 似乎是需要 document 的，而小程序中我们并不能够得到它）此路不通，另觅他途。在查阅资料的过程中，我发现在 HTML 中似乎是有 这个标签的，然后我就兴冲冲的又去翻阅了一下小程序的官方文档，果不其然，小程序还是很良心的，有这方面的描述：然后我就兴冲冲的去按照官方的介绍用 标签来提交数据，js 里的代码是这样的：formSubmit: function (event) {\r\n        wx.request({\r\n            url: Constant.BASE_URL + \"/add2gank\",\r\n            method: \"POST\",\r\n            //按照官方文档，event.detail.value应该就是  标签获得的数据\r\n            data: event.detail.value,\r\n            complete: function (res) {\r\n                  //省略\r\n            }\r\n        });\r\n}我满心欢喜的以为可以了，结果并不可以。。。后台还是跟我说获得的数据有问题，结果我 console.log() 了看 给我返回的数据，它竟然还是个 json。。。说好的 form 呢！感觉受到了欺骗。濒临崩溃。幸好这时候一个老司机点醒了我：为啥那么纠结在本地数据是什么样子的？归根结底我们是要把数据传到后台去，那么只需要让数据在请求里面是 form 的格式不就 OK 了？所以 form 表单在请求里面是长什么样子的呢？json数据：\r\n{name: \"lypeer\",  gender: \"男\"}\r\nform数据：\r\n\"name=lypeer & gender=男\"123所以只要直接对数据进行操作，不用去管什么鬼 json 对象 form 对象什么的，那位老司机写了个方法，我无耻的直接拿来用了：function json2Form(json) {\r\n    var str = [];\r\n    for(var p in json){\r\n        str.push(encodeURIComponent(p) + \"=\" + encodeURIComponent(json[p]));\r\n    }\r\n    return str.join(\"&\");\r\n}ok，然后就可以用这个方法转换数据后来 post 一发：formSubmit: function (event) {\r\n        console.log(event);\r\n        wx.request({\r\n            url: Constant.BASE_URL + \"/add2gank\",\r\n            header: {\r\n                \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n            },\r\n            method: \"POST\",\r\n            data: Util.json2Form(event.detail.value).concat(\"&debug=false\"),\r\n\r\n            complete: function (res) {\r\n                //省略\r\n            }\r\n        });\r\n}23456789101112131415这里有一点需要注意，必需修改 content-Type 为 application/x-www-form-urlencoded ，不然还是会出问题。通过上面的方式就可以愉快的给后台传表单啦~~~另外关于 这个标签，虽然说他不会直接给我们返回 form 表单，但是我感觉它还是很好用的，可以直接获得里面的很多信息，不用很麻烦的一个一个去获取数据了。不过这个标签也是有一些坑的，下面会讲到它。7，解析 HTML 代码块？有时候我们会有解析 HTML 代码块的需求（爬了一个网页需要解析，或者后台出于某种原因返回给你了一个 HTML 代码块），但是我们能获得的通常是一个 String 值（ json 里返回的），在这种情况下通常我们会想到两种解析方式：直接使用正则匹配字符串或者将其装化成一个 DOM（Document Object Model，文档对象模型，没怎么接触过 JS 的同学可能对这个不太清楚） 然后解析。直接使用正则的方式这里我就不具体说了，这玩意儿在有些时候还是很好用的，但是在有些时候不那么方便，毕竟它不是为了解析 HTML 而生的。而一提到转化为 DOM ， 大家的脑海里就会浮现出这行代码来：var el = document.createElement( 'html' );el.innerHTML = htmlString;//htmlString是一串 HTML 代码的 String 值1212再然后就可以对 el 执行一系列的解析操作了：el.getElementById( idName );el.getElementsByTagName( tagName );......123123毫无疑问，这种方式在大多数情况下是比正则来的简单方便的，毕竟你不需要绞尽脑汁去写合适的正则表达式了。那么问题来了，在小程序里面我们无法直接获得 window 和 document 对象，那么如何把一段 HTML 代码的 String 值转化为 DOM 呢？不知道那些前端老司机是怎么做的，反正我是这么做的：function parseHtml(htmlBlock) {        var parser = new DOMParser();        return parser.parseFromString(htmlBlock, \"text/html\");}12341234我惊讶的发现，虽然微信小程序里面没有 ducument ， window 的概念，但是可以通过 DOMParser 对象来获得一个 document 对象 ……不要问我怎么发现的，这里面的艰辛不足为外人道也。然后我们就可以愉快的通过这个返回的对象来进行一系列解析操作啦~~~8，<form/> 里面无法获取 <picker/> 的取值？在微信小程序的官方文档里，是指明了 <form/> 标签里可以提交 <picker/> 的数据的，但是如果你真的在 <form/> 标签里放了一个 <picker/> 的话，你会发现，童话里都是骗人的。什么鬼！说好的数据呢！！！死活都获取不了数据，甚至还会让整个程序崩掉。并且坑爹的是，在小程序官网上面的那个 DEMO 里面，关于 <form/> 标签的使用有一个例子，例子里面几乎包含了 <form/> 标签中会提取数据的所有控件，就是没有 <picker/> 。那怎么办？这当然是难不倒我的。最终我采取了这样的方式来解决这个问题：<picker bindchange=\"onPickerChanged\" value=\"{{index}}\" range=\"{{array}}\">        <input class=\"picker\" disabled=\"disabled\" name=\"type\" value=\"{{array[index]}}\"/></picker>这是一个 <form/> 标签里面的 <picker/> 标签，我采取的方式是用一个 <input/> 标签来获取 <picker/> 的值，然后让 <form/> 获取 <input/> 的值，从而达到将 <picker/> 里面的值传递给 <form/> 的目的。9，要实现多层列表？在做 wechat-weapp-gank 的每天干货展示的页面的时候，有一个这样的页面需要实现：这个东西说白了就是个两层的列表，在原先做 Android 的时候这个是很容易的，直接嵌套嘛，但是现在做小程序的这个效果还是遇到了一些问题。这其中最大的问题就是在嵌套的过程中究竟在绑定数据的时候应该怎么写——第二个列表应该怎么传数据进去呢？第二个列表的列表项应该怎么获取数据呢？最后我摸索出来的结果是这样的：<view class=\"frame\" wx:for=\"{{data}}\">        <view class=\"tag\">{{item.tag}}</view>        <view wx:for=\"{{item.singleItems}}\">                <view class=\"singleItem\" href=\"{{item.src}}\">{{index}}，{{item.title}}</view>        </view></view>其中 data 是一个数组，它里面装的是一个一个的的 json 数据，每个 json 数据里面又装了 tag，singleItems 等数据，其中 singleItems 又是一个数组，它里面装的也是一个一个的 json 数据，每个 json 数据里装了每个二级列表的 item 所需的数据。具体的可以去我的项目代码里去看，具体的代码路径在这里：post.wxml 和 post.js。10，如何方便愉快的实现类似 Java 里面的静态变量的效果？这点的话纯粹是我的一点执念吧，我是从事 Android 开发的，也有点开发中的小癖好，喜欢把一些字符串弄成全局静态的放到一个专门的地方去。如果是在 Java 里面的话，我喜欢这样做：然后在调用的时候就可以这样做：String appId = Constants.AppSign.V_APP_ID;这样做我觉得很舒服，条理很清晰。但是在微信小程序中想要得到这样的体验就很困难——不过还是让我找到了方法——在小程序里面，是可以通过module.exports 将一个 js 文件模块化，然后让别的 js 文件通过 require( URL ) 引用的，我们可以通过这个特性来实现字符串的全局化，像这样：这样的话，我们就可以在需要使用的时候这样：这个其实不算踩过的坑哈，只是一个 Android 程序员的小执念而已，大家可以无视。。。结语最近在恶补一些前端的东西，感觉我已经快成为一个前端开发工程师了。。。"}
{"title": "Code4Android：微信小程序体验历程：我遇到的问题及解决方法", "author": "天下雪", "time": "2016-10-17 10:20", "content": "因为自己对小程序也是很有兴趣的，感觉是很有意思的一个东西，所以以QQ练手，做一个高仿QQ的微信小程序，由于本人是Android开发者，平时很少接触前端的一些东西，水平有限，所以代码很多地方是不规范的，做的过程也就是一个学习的过程，一个提高的过程。\r\n这篇文章主要写我在SmallAppForQQ这个项目进展的过程中遇到的一些问题。如果阅读此文的你有一定帮助，很是欣慰，欢迎star项目。\r\n\r\nSmallAppForQQ源码\r\n开发工具\r\n官方demo\r\n\r\n项目结构\r\n文章开头，先简单介绍下项目结构，若没有安装开发工具，可去GitHub:https://github.com/xiehui999/SmallAppForQQ下载。微信小程序项目结构主要有四个文件类型,如下\r\n\r\n\r\nWXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。\r\n\r\n\r\nWXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，\r\n\r\n\r\njs 逻辑处理，网络请求\r\n\r\n\r\njson  小程序设置，如页面注册，页面标题及tabBar。\r\n\r\n\r\n注意：为了方便开发者减少配置项，规定描述页面的这四个文件必须具有相同的路径与文件名。\r\n在根目录下用app来命名的这四中类型的文件，就是程序入口文件。\r\n\r\napp.json必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航条样式，配置默认标题。\r\n\r\napp.js必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。\r\n\r\n\r\napp.wxss全局配置的样式文件，项目非必须。\r\n\r\n\r\n知道小程序基本文件结构，就可以开始研究官方demo了，研究过程中如果有不明白的地方可以去官方文档寻求答案，如果找不到答案或者有疑问，可再此博客留言，相互交流。下面介绍下出现概率较高的几个问题。\r\n常见问题\r\nrpx（responsive pixel）\r\n微信小程序新定义了一个尺寸单位，可以适配不同分辨率的屏幕，它规定屏幕宽为750rpx，如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。\r\n这里写图片描述\r\n\r\n这个项目我用的都是rpx尺寸单位，期间遇到一个很奇葩的问题。在相邻的两条信息直接都会有一个分割线，我将线的高度都设置成1rpx,但是不有个别分割线是不显示的，如下图\r\n这里写图片描述\r\n\r\n看到没在第一条和第二条直接并没有现实这条线，但是其他的都展示了，分割线的属性是一样的，而且在不同的手机上（分辨率不同）不显示的分割线也是不同的，有的分辨率好几条分割线都不显示，不知道这是模拟器的bug还是rpx的bug。最后分割线的高度尺寸单位使用了px,解决了这个问题。\r\n40013错误\r\n这里写图片描述\r\n\r\n在微信小程序刚出来的时候如果输入AppID提示这个信息就表示没有破解，但是现在官方软件更新可以选择无AppID开发，如下图，我们之间选择无AppID，即可解决此错误。建议安装官方开发工具。可去此处找下载链接。\r\n这里写图片描述\r\n\r\n-4058错误\r\n微信小程序创建项目时选择无AppID，创建项目时会生成app.json，app.josn是程序启动最重要的文件，程序的页面注册，窗口设置，tab设置及网络请求时间设置都是在此文件下的。如果你创建的项目目录下没有app.json文件就会报下面的错误。\r\n这里写图片描述\r\n\r\n我们看到上面的错误信息中有个数字-4058，这应该是初入微信小程序遇到最多的错误了，这种一般都是文件缺失，后面有个path，可以对着该路径看看是否存在这个文件。造成这种错误的原因一般都是创建项目选择的目录不正确，或者在app.json注册了一个不存在的页面。当然还有一种情况就是在app.json文件的pages注册的页面是没有创建的，或者你删除了某个页面，但是没有取消注册也会是-4058错误。\r\nPage注册错误\r\n这里写图片描述\r\n\r\n这个错误可能很容易理解，页面注册错误。页面是通过Page对象来渲染的，每个页面对应的js文件必须要创建page，最简单的方式就是在js文件下写入Page({})，在page中有管理页面渲染的生命周期，以及数据处理，事件都在这完成。这个错误引起的原因一般都是刚创建页面，js文件还有有处理或者忘了处理。所以要养成创建页面的同时在js文件先创建Page的习惯.\r\nPage route错误\r\n这里写图片描述\r\n\r\n字面意思就是页面路由错误，在微信中有两种路由方式一种是在wxml文件使用<navigator />组件，一种是调用wx.navigateTo。如下代码：\r\nwxml文件：\r\n<navigator url=\"search/search\">\r\n<view class=\"serach_view_show\" bindtap=\"bindtap\"> 搜索</view>\r\n</navigator>\r\njs文件事件处理函数：\r\n  bindtap:function(event){\r\nwx.navigateTo({\r\n  url: \"search/search\"\r\n})\r\n  }\r\n如果你这样写的话，恭喜你，你就会看到上面提示的错误，这是因为重复调用路由引起的，处理方法就是删除一个路由，删除<navigator />组件或者删除wx.navigateTo。除了上面说的可能导致路由错误外，还有一种情况，类似于下面的代码\r\n<navigator url=\"search/search\">\r\n<navigator url=\"search/search\">\r\n<view class=\"serach_view_show\" bindtap=\"bindtap\"> 搜索</view>\r\n</navigator>\r\n</navigator>\r\n这种也是不允许的，也就是说<navigator/>组件内部不能再嵌套<navigator/>组件。它只能是单层存在的。\r\nDo not have * handler in current page.\r\n这里写图片描述\r\n\r\n大概意思就是当前页面没有此处理，让确定是否已经定义，还指出了错误出现的可能位置pages/message/message,其实这种问题出现一般就是我们在wxml定义了一些处理事件，但是在js文件中没有实现这个时事件的处理方法，就会出现这个错误。那么我们按提示在js文件加上事件处理，如下代码，加上后就不会再有此错误提示。\r\n  bindtap:function(event){\r\nwx.navigateTo({\r\n  url: \"search/search\"\r\n})\r\n  },\r\ntabBar设置不显示\r\n对于tabBar不显示，原因有很多，查找这个错误直接去app.json这个文件，最常见的也是刚学习微信小程序最容易犯的错误无外乎下面几种\r\n注册页面即将页面写到app.json的pages字段中，如\r\n \"pages\":[\r\n\r\n    \"pages/message/message\",\r\n    \"pages/contact/contact\",\r\n    \"pages/dynamic/dynamic\",\r\n     \"pages/dynamic/music/music\",\r\n    \"pages/index/index\",\r\n    \"pages/logs/logs\"\r\n  ]\r\n\r\n\r\ntabBar写法错误导致的不显示，将其中的大写字母B写成小写，导致tabBar不显示。\r\n\r\n\r\ntabBar的list中没有写pagePath字段，或者pagePath中的页面没有注册\r\n\r\n\r\ntabBar的list的pagePath指定的页面没有写在注册页面第一个。微信小程序的逻辑是\"pages\"中的第一个页面是首页，也就是程序启动后第一个显示的页面，如果tabBar的list的pagePath指定的页面都不是pages的第一个，当然也就不会电视tabBar了。\r\n\r\n\r\ntabBar的数量低于两项或者高于五项，微信官方中明确规定tabBar的至少两项最多五项。超过或者少于都不会显示tabBar。\r\n\r\n\r\nnavigationBarTitle显示问题\r\n这里写图片描述\r\n\r\n 通过这个动态图你应该发现问题了，当点击音乐进入音乐界面时，title先显示了WeChatForQQ然后显示的音乐，这个体验肯定是难以接受的，原因是音乐界面的title是在js文件中page的生命周期方法中设置的。 若你不了解生命周期，可以点击查看\r\nPage({\r\n  data:{\r\n    // text:\"这是一个页面\"\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n    //NavigationBarTitle如果此处和json文件都设置，最后展示此处的标题栏\r\nwx.setNavigationBarTitle({\r\n  title: '音乐'\r\n})\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})\r\n通过注释你应该明白了，设置标题写在了onReady方法中，也就是页面已经渲染完成了，在onReady之前显示的title就是json文件（覆盖关系，如果在子页面json文件设置title会覆盖app.json全局设置）中的title。可能你会说将wx.setNavigationBarTitle写在onLoad函数中，不过如果这样设置是不对的，因为onLoad执行过后才渲染页面，在渲染页面时title会从json文件中读取，导致onLoad设置的title会只在页面渲染之前展示，之后就显示json文件的tile，所以现在你应该明白ttle设置最优的地方就是给子文件写一个json文件，在文件中写入，如果想改变颜色直接在文件中添加就可以，该文件所写的属性值会覆盖app.json中设置的值。\r\n{\r\n    \"navigationBarTitleText\": \"音乐\"\r\n}\r\nwx.navigateTo无法打开页面\r\n一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。请避免多层级的交互方式，或者使用wx.redirectTo\r\n本地资源无法通过 css 获取\r\nbackground-image：可以使用网络图片，或者 base64，或者使用<image/>标签\r\n页面间数据传递\r\n微信小程序路由（页面跳转）是通过API wx.navigateTo或者wxml中<navigator/>组件实现的，不管哪种实现都会有一个重要的参数就是url，它指定了要跳转的页面，并且页面之间数据传递也是通过url来实现的，这个数据传递有点类似于我们使用的get网络请求，把参数都拼接在要跳转界面地址的后面并以“？”连接。然后将要传入的数据以键和值的形式追加在\"?\"后面，多个参数直接用\"&\"符合。如我们点击消息聊天记录，将列表上的数据传到下一个页面，可以这样写。\r\n <navigator url=\"/pages/dynamic/dynamic?title={{item.title}}&message={{item.message}}\">\r\n          <view class=\"item\" >\r\n             <view class=\"item-left\">\r\n                  <image src=\"{{item.url}}\" class=\"image\"/>\r\n             </view>\r\n             <view class=\"item-middle\">\r\n                  <view>\r\n                       <text class=\"title\">{{item.title}}</text>\r\n                  </view>\r\n                  <view>\r\n                      <text class=\"message\">{{item.message}}</text>\r\n                  </view>\r\n            </view>\r\n            <view class=\"item_right\">\r\n                <view><text class=\"time\">{{item.time}}</text></view>\r\n                <view class=\"mark\" wx:if=\"{{item.count>0}}\"><text class=\"text\">{{item.count}}</text></view>\r\n            </view>\r\n         </view>\r\n         <view  class=\"line\"></view>\r\n       </navigator>\r\n而数据接收是在js文件的page里接收的，page生命周期有一个onLoad函数，它就是做一些初始化数据的工作，onLoad函数有一个参数options，我们就可以通过key将数据获取，如下\r\nPage({\r\n  data:{\r\n    // text:\"这是一个页面\"\r\n    isHiddenToast:true\r\n  }\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n    console.log(options.title)\r\n     console.log(options.message)\r\n\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  },\r\n  bindtap:function(event){\r\nwx.navigateTo({\r\n  url: \"/pages/message/search/search\"\r\n})\r\n  },\r\n})\r\n这样就实现了页面间数据传递功能。\r\n好了，今天就写到这了后期若遇到微信小程序其它一些问题，我会追加到此文，若你在开发过程中遇到比较坑的问题已经解决方案，可在本文评论，方便大家。谢谢支持。"}
{"title": "lypeer：一名Android开发者的微信小程序填坑之路《上》", "author": "天下雪", "time": "2016-10-17 11:05", "content": "前言首先要声明的是，我是一名 Android 开发者，之前基本没有前端开发经验，甚至连 JS ，HTML 都是为了开发小程序现学的一些皮毛——所以文章中所提到的一些点也许在资深前端开发者看来只是小case，但是站在一个 Android 开发者的角度来看确实是大坑。前面就不说太多东西了，文章的末尾再谈谈我对小程序的一些看法——这篇文章主要是谈谈在开发小程序的过程中遇到的一些坑。PS：推荐一下我写的一个微信小程序版的Gank客户端：wechat-weapp-gank正文1，获取小程序开发工具并正确安装？最近在一些地方看到很多人在入小程序坑的第一步就出现了很多的问题，其实很早之前（22号）关于怎样搞定小程序的开发工具就已经有比较好的资料了，大家可以直接去看一下然后照着做，基本上就没啥问题：获取小程序开发工具并正确安装的教程2，直接在微信开发工具上写代码？目前来讲，我们只能在微信的开发工具上编译小程序的代码，但是这并不意味着我们必须要在那个开发工具上写小程序的代码——用过那个开发工具的人就会知道，那个开发工具并没有多好用，代码提示挺弱鸡的，而且没有自动保存是硬伤。那么怎么办呢？我们完全可以在别的工具里面写代码然后在小程序的开发工具里面编译。我试过 sublime 和 webstorm ， 都是可以在上面开发的，但是最后还是发现 ws 更好用。我就不讲 sublime 怎么用了，大家只需要直接在里面打开项目文件夹然后点右下角选择当前的语言就可以了。接下来着重讲一讲如何在 ws 里面编写小程序代码。首先选择小程序的目录在 ws 里面打开，这是很简单的。但是这个时候打开里面的文件之后你会发现，除了 js 代码它能认出来之外，其他的代码他都并不能够认出来——主要是 .wxml 和 .wxss 文件。为什么呢？因为虽然 .wxml 和 .html 文件很像，.wxss 文件和 .css 文件很像，但是编译器并不知道！这样一来，我们就无法在这两种文件里面享受 ws 强大的代码提示功能了——我们能接受这种事么？果断不能！那么接下来我们应该怎么办呢？告诉编译器，.wxml 格式的其实是 HTML 文件，.wxss 格式的其实是 CSS 文件。上图把做这件事的流程讲的很详细了，.wxss 文件的转化同理。这样做了之后，编辑器就会知道他们的真实面目，然后就可以有棒棒的代码提示了（但是请注意，有写微信自己写的东西编辑器不仅没有代码提示反而会报错，不管他就好了）！接下来就可以直接 ws 一个桌面小程序开发工具一个桌面，在 ws 里面写了代码直接划过去点编译了。3，跳转page的时候怎么传递数据？小程序给我们开放了很好的接口来进行页面之间的跳转：但是在这个地方微信官方对于这一个接口并没有太多的描述，只是简简单单的给了我们一行代码：wx.navigateTo({url: \"test ? id = 1\"}); ，其实这里这样写是有些难以理解的——test 是个什么鬼 ? id 是个什么鬼？中间那个问号是个什么鬼？这都是些什么鬼？反正我看到的时候是一头雾水的。不过还好，经过一些摸索，终于知道了他们是啥。首先，代码里的 test 代表要跳转到的 page 的url 地址。比如：那么代码就应该是：wx.navigateTo({url: \"/pages/specific/specific\"});11聪明的人可能已经发现了，上面的代码没有了示例代码里面 ? id = 1 的部分，怎么回事，是我写错了么？并不是。这一部分其实是跳转 page 时用来传值的关键方法，并不必需，但很有用。* ? 是一个分隔符一样的东西，它的后面就是所有要传到目标 page 的值。而这些值是通过键值对来一一对应的，每个键值对之间用 & 隔开。但是要注意的是，似乎这种方式传值只能传 String 过去，不是 String 类型的值传过去之后也会被转化为 String 。*比如，我传了个 array 和 json 过去：var arrayData = [\"firstData\" , \"secondData\"];\r\nvar jsonData = {first: \"firstData\" , second: \"secondData\"};\r\nwx.navigateTo({url: \"/pages/specific/specific ? data: \" + arrayData + \"&json=\" + jsonData});结果目标page里接受到的是：//目标page的onLoad方法\r\nonLoad: function (options) {\r\n        //结果是：firstData , secondData\r\n        console.log(options.data);\r\n        //结果是：f\r\n        console.log(options.data[0]);\r\n        //结果是：[object Object]\r\n        console.log(options.json);\r\n        //结果是：undefined\r\n        console.log(options.data.first);\r\n\r\n        //很显然，被转化了  \r\n}上面其实也演示了如何在目标 page 里面接收传过来的数据，直接在 onLoad() 里面的 options 取就可以了。另外，其实更多的时候我们的需求并不是直接传一个固定的参数到目标 page 里面去，而是根据用户的一些操作传递不同的值到目标 page 里面去，这个时候该怎么办呢？要知道，我们是没有办法获得组件的（这点太坑了，没有 window 和 document）。这个时候，我们可以通过 dataset 来通过绑定组件数据达到目的。什么？你不知道 dataset 是什么东西？多读书，多看报，多看文档少睡觉。4，某些图片无法加载？这个坑真的是深坑，可能很久很久都不会遇到，但是一旦遇到真的很蛋疼。我拿来练手的项目是 Gank.io 的客户端，而 Gank 网站上的图片都是寄放在新浪图床上的，默认的存储的 url 是http://ww{1 || 2 || 3 || 4}.xxxxx.xxxxx.jpg，然后在小程序里死活都加载不出来这些图片！！！我一开始不知道到底是小程序的 <image> 标签的问题还是图片的问题，就找了很多地方的图片来做测试，包括 CSDN 上的，简书上的，github 图床上的，结果是这些图片都可以正常显示——甚至新浪微博上的，一些人的头像，都可以显示！后来我发现，只要 URL 是 ww+数字 开头的图片，都不能正常的显示！这也太坑了。。。后来我就在思考怎么解决这个问题——要么改变 标签，他自身肯定是有问题的，可能对某些来源的图片不太友好；要么改变图片，让它去适应这个 标签。这两方面要改其实都挺难的，但是显然第一种方式基本上是不可能的，就只能在第二种方式上去下功夫。最后经过不断地尝试，我总结了很多规律，最后通过把图片的 URL 由 ww+数字变成 ws+数字 解决了这个问题，让图片得以显示在小程序上。比如：本来的URL：\r\nhttp://ww1.sinaimg.cn/large/610dc034jw1f87z2n2taej20u011h11h.jpg\r\n变换之后的URL：\r\nhttp://ws1.sinaimg.cn/large/610dc034jw1f87z2n2taej20u011h11h.jpg不要问我为什么这样改了就可以显示了，因为我也不知道。。。太神奇了。。。5，this.setData() 显示没这个方法？首先想要说的是，作为一个 Android 开发者，我非常不适应小程序的数据与控件绑定的方式。在 Android 开发的时候，我们是可以直接获得控件然后对控件做数据绑定的工作的，而在小程序里，我并不能够直接获得控件的对象，所有的数据绑定与动态修改只能通过维护 Page 里面的 data{} 以及调用setData() 方法来进行，我不好评判这两种方式的优劣，只能说真的很不习惯。但是有些和我一样以前没怎么接触过前端开发的朋友在做这个的时候就有可能会踩坑了——setData() 是 Page 这个层级上的方法，并不是在任何地方调用 this.setData() 方法都可以顺利的得到我们预期的结果的。比方说：Page({\r\n    onLoad: function (options) {\r\n        wx.request({\r\n            url: Constant.GET_URL,\r\n            success: function (res) {\r\n                this.setData({...});\r\n            }\r\n        });\r\n    },\r\n});我在 wx.request() 的回调接口里面 success() 里面写 this.setData({...})，就不能完成预期操作，程序会报错说没有 setData() 这个方法，因为这个时候 this 获取到的已经并不是 Page 了，上下文已经发生了变化，那么当前层级没有 setData() 方法就很正常了。那么怎么解决这个问题呢？像这样：Page({\r\n    onLoad: function (options) {\r\n        that = this;\r\n        wx.request({\r\n            url: Constant.GET_URL,\r\n            success: function (res) {\r\n                that.setData({...})\r\n            }\r\n        });\r\n    },\r\n});\r\n\r\nvar that;和一开始的区别在于多了一个全局变量 that，并且在 onLoad() 方法里面对它进行了赋值，使它等于 this。这样的话，我们就可以在这个 Page 的任何地方调用 that.setData() 来动态的改变控件的属性了。结语本来是还有一些问题要谈一谈的，但是写到这里篇幅已经挺长的了，就干脆把其他的放到下一篇里面算了。剩下的问题还有：后台接收数据需要表单？小程序并不能很方便的获得数据的表单，甚至 <form>标签获得的数据也不是。解析 HTML 块？没有document，没有window，解析它简直是一种折磨。<form/> 里面无法获取 <picker/> 的取值？明明文档里有说在 <form/> 里面是可以支持 <picker/> 的，结果你会发现死活无法获得他的值。要实现多层列表？有的时候也许需要在一个列表项的每一项下面又有一个子列表，在小程序里怎么做？如何方便愉快的实现类似 Java 里面的静态变量的效果？没有一个专门的类存放 static final 的值供其他地方使用感觉全身都不自在。接下来我想谈一下我对小程序的看法。第一点，不管小程序能不能在未来的时间里在移动端大放异彩，学习它，掌握它，都是没有任何坏处的。第二点，就目前的版本而言，小程序的表现让我有些失望——实在是太过封闭。开发小程序就感觉像是在微信给我们划定的一个小圈子里兜兜转转，在圈里也许我们能得到很良好的开发体验，但是一步都出去不得。第三点，在性能与便捷之间，最终往往会是便捷取胜。第三点，能用 js 开发的，最终都会用 js 开发。多谢各位看官看到这，顺便去点个star吧：wechat-weapp-gank"}
{"title": "微信小程序学习点滴《二》：开发者工具快捷键，轮播图 swiper图片组件 ...", "author": "天下雪", "time": "2016-10-17 13:04", "content": "一：开发者工具快捷键微信小程序已经跑起来了.快捷键设置找了好久没找到,完全凭感觉.图贴出来.大家看看.我现在用的是0.10.101100的版本,后续版本更新快捷键也应该不会有什么变化.现在貌似不能修改.如果有同学找到修改的方法,麻烦告诉我微信小程序代码编辑快捷键常用快捷键格式调整Ctrl+S：保存文件Ctrl+[， Ctrl+]：代码行缩进Ctrl+Shift+[， Ctrl+Shift+]：折叠打开代码块Ctrl+C Ctrl+V：复制粘贴，如果没有选中任何文字则复制粘贴一行Shift+Alt+F：代码格式化Alt+Up，Alt+Down：上下移动一行Shift+Alt+Up，Shift+Alt+Down：向上向下复制一行Ctrl+Shift+Enter：在当前行上方插入一行光标相关Ctrl+End：移动到文件结尾Ctrl+Home：移动到文件开头Ctrl+i：选中当前行Shift+End：选择从光标到行尾Shift+Home：选择从行首到光标处Ctrl+Shift+L：选中所有匹配Ctrl+D：选中匹配Ctrl+U：光标回退界面相关Ctrl + \\：隐藏侧边栏二：轮播图 swiper图片组件照着开发文档尝试,总是能有所收获.之前做Android开发,做个轮播图并不简单,用上viewpage再设置圆点,折腾一通之后还一堆bug.今天尝试微信小程序开发做轮播图,真是感动的泪流满面.废话说完了,上图.上图就是一个简易的轮播图,是不是很简易.23333主要是代码也很简单.1.index.wxml<!--index.wxml-->        <swiper class=\"swiper\" indicator-dots=\"true\" autoplay=\"true\" interval=\"5000\" duration=\"1000\">          <block wx:for=\"{{movies}}\" wx:for-index=\"index\">            <swiper-item>              <image src=\"{{item.url}}\" class=\"slide-image\" mode=\"aspectFill\"/>            </swiper-item>          </block>        </swiper>这里有几个属性需要说明.微信小程序开发的循环用到了<block wx:for >我这里是遍历movies[]数组.<swiper-item>就是item2.index.js//index.js    //获取应用实例    var app = getApp()    Page({      data: {        movies:[        {url:'http://img04.tooopen.com/images/20130712/tooopen_17270713.jpg'} ,        {url:'http://img04.tooopen.com/images/20130617/tooopen_21241404.jpg'} ,        {url:'http://img04.tooopen.com/images/20130701/tooopen_20083555.jpg'} ,        {url:'http://img02.tooopen.com/images/20141231/sy_78327074576.jpg'}         ]      },      onLoad: function () {      }    })   3.WXML/**index.wxss**/.swiper {  height: 400rpx;  width: 100%;}.swiper image {  height: 100%;  width: 100%;}WXSS不多说,跟CSS没啥区别.不明白的看看开发文档"}
{"title": "微信小程序学习点滴《三》：开发工具及开发环境配置，尺寸单位rpx与px,rem相互转换 ...", "author": "天下雪", "time": "2016-10-17 13:11", "content": "一：开发工具及开发环境配置1.开发工具下载地址Windows 64位 下载Windows 32位 下载MacOS 下载2.安装过程对于Windows用户直接双击下一步的方式安装即可，此处注意我们使用的版本是官方最新的版本（不需要破解），可以不用AppID，也就是说没有资格的开发者也可以测试。2.1 环境测试以及演示项目2.1.1安装完成过后通过打开我们已经完成的应用测试环境是否正常2.1.2开发者工具安装完成后，打开并使用微信扫码登录。2.1.3选择创建“项目”，填入你在公众平台的`AppID`，如果没有的话可以点击`无AppID`。2.1.4设置一个本地项目的名称（非小程序名称），比如`WeApp Demo`，并选择一个本地文件夹作为存储目录。点击\"添加项目\"2.2  接下来点击`新建项目`就可以在主界面中预览到示例项目了二：尺寸单位rpx与px,rem相互转换1. rpx :微信小程序开发中新出了尺寸单位rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。微信官方建议视觉稿以iPhone 6为标准.2.rem rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。微信小程序开发尺寸单位文档"}
{"title": "微信小程序学习点滴《一》：如何获取时间，页面跳转，传递参数 ... ...", "author": "天下雪", "time": "2016-10-17 12:18", "content": "一：如何获取时间：获取时间直接用 Date.now() 得到一串数字.如下图:获取格式化的时间用 util.formatTime(new Date)util是微信官方demo里面的提供的工具:如下代码function formatTime(date) {  var year = date.getFullYear()  var month = date.getMonth() + 1  var day = date.getDate()  var hour = date.getHours()  var minute = date.getMinutes()  var second = date.getSeconds()  return [year, month, day].map(formatNumber).join('/') + ' ' + [hour, minute, second].map(formatNumber).join(':')}获取到时间如下:二：页面跳转,页面之间传递参数  先上demo图:  为了简化逻辑,所以index.wxml里面只写了两个text.既然是跳转,那就还有其他页面.目录如下:三个页面,但是代码很简单.直接上代码<!--index.wxml-->  <view class=\"btn-area\">    <navigator url=\"../navigator/navigator?title=我是navigate\" >跳转到新页面</navigator>    <navigator url=\"../redirect/redirect?title=我是redirect\" redirect>在当前页打开</navigator>  </view>index.wxml中的URL就是跳转的页面路径.上面代码中就是navigator目录下的navigator页面,title是参数. navigator下redirect属性是值在当前页打开.如果不加redirect就是跳转到新页面.都可以携带参数.<!--navigatort.wxml-->  <view style=\"text-align:center\"> {{title}} </view> 在navigatort.wxml中通过js代码可以获取到title,代码如下.options.title//navigator.js  Page({    onLoad: function(options) {      this.setData({        title: options.title      })    }  }) <!--redirect.wxml-->  <view style=\"text-align:center\"> {{title}} </view> //redirect.js  Page({    onLoad: function(options) {      this.setData({        title: options.title      })    }  })最后上两张跳转后的图.1.跳转到新页面2.在原来的页面打开有没有发现一个细节,在原来的页面打开是不会出现返回按钮的,而跳转到新页面后会出返回按钮.这是因为我写了两个页面.如果indexwxml不是一级页面,这里都会出现返回按钮.当然返回的结果是不一样的:1.跳转到新页面,返回是回到之前的页面;2.在原来页面打开,返回是回到上一级页面."}
{"title": "微信小程序学习点滴《四》：网络请求", "author": "天下雪", "time": "2016-10-17 13:19", "content": "微信小程序开发中网络请求必不可少,今天说说最简单的请求.后续会尝试上传下载,Socket这些.1.一个微信小程序，同时只能有5个网络请求连接。这个规定应该是微信为了保证用户体验制定的,毕竟是小程序.2.wx.request(OBJECT)  参数说明:微信小程序支持GET,POST等请求.用method可以设置.以下是GET请求的代码://rate.js  //获取应用实例  var app = getApp()  Page( {    data: {      code: 'USD',      currencyF_Name: '',      currencyT_Name: '',      currencyF: '',      currencyT: '',      currencyFD: 1,      exchange: 0,      result: 0,      updateTime: '',    },    onLoad: function( options ) {      var that = this;        //获取汇率        wx.request( {          url: \"http://op.juhe.cn/onebox/exchange/currency?key=我的appkey&from=CNY&to=\"+code,          success: function( res ) {            that.setData( {              currencyF_Name: res.data.result[0].currencyF_Name,              currencyT_Name: res.data.result[0].currencyT_Name,              currencyF: res.data.result[0].currencyF,              currencyT: res.data.result[0].currencyT,              currencyFD: res.data.result[0].currencyFD,              exchange: res.data.result[0].exchange,              result: res.data.result[0].result,              updateTime: res.data.result[0].updateTime,            })          }        })    }  })上面代码中只需要给出URL即可,onLoad函数在页面初始化时启动,wx.request({})中success的res.data是从后台获取的数据,这一点需要注意.以下是获取的json数据的格式.json的解析都不需要自己做了.我做Android的时候还得用gson或者是fastjson来解析json.微信为我们解决了很多麻烦.微信小程序开发网络请求文档"}
{"title": "微信小程序把玩《二》：页面生命周期，模块化，数据绑定，view组件 ... ...", "author": "天下雪", "time": "2016-10-17 14:52", "content": "五：页面生命周期这里只要熟悉页面的基本生命周期即可，业务在指定生命周期函数内书写。以下是官网给出的生命周期函数方法和状态图上面的生周期函数图对于做Android 或者IOS的来书理解起来应该不是难事，具体怎么掌握只有慢慢尝试和摸索代码处理:这里的代码主需要对使用创建项目时index目录下文件处理下就行,至于跳转后的页面用的还是logs不需要更改！下面贴下代码注释也比较详细index.wxml<!--index.wxml--><view class=\"container\"><!--绑定点击事件-->  <view  bindtap=\"bindViewTap\" class=\"userinfo\">  </view>  <view class=\"usermotto\">  <!--数据绑定-->    <text class=\"user-motto\">{{motto}}</text>  </view></view>index.wxss<!--index.wxml--><view class=\"container\"><!--绑定点击事件-->  <view  bindtap=\"bindViewTap\" class=\"userinfo\">  </view>  <view class=\"usermotto\">  <!--数据绑定-->    <text class=\"user-motto\">{{motto}}</text>  </view></view>index.js//index.js//获取应用实例var app = getApp()Page({  /**   * 通过data初始化数据   */  data: {    motto: '点击上面View跳转',    // userInfo: {}  },  //事件处理函数  bindViewTap: function() {    //通过调用API进行跳转    wx.navigateTo({      url: '../logs/logs'    })  },  /**   * 监听页面开在加载的状态   *    页面加载完成之后就不会在执行   */  onLoad: function () {    console.log('index---------onLoad()')    // //this指的就是本页面对象    // var that = this    // //调用应用实例的方法获取全局数据    // app.getUserInfo(function(userInfo){    //   //更新数据    //   that.setData({    //     userInfo:userInfo    //   })    //   //更新本页面    //   that.update()    // })  },  /**   *  监听页面显示，   *    当从当前页面调转到另一个页面   *    另一个页面销毁时会再次执行   */  onShow: function() {    console.log('index---------onShow()')  },  /**   * 监听页面渲染完成   *    完成之后不会在执行   */  onReady: function() {    console.log('index---------onReaday()');  },  /**   * 监听页面隐藏   *    当前页面调到另一个页面时会执行   */  onHide: function() {    console.log('index---------onHide()')  },  /**   * 当页面销毁时调用   */  onUnload: function() {    console.log('index---------onUnload')  }})六：模块化模块化也就是将一些通用的东西抽出来放到一个文件中，通过module.exports去暴露接口。我们在最初新建项目时就有个util.js文件就是被模块化处理时间的//index.js//获取应用实例var app = getApp()赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                (1)\r\n\r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (2 人)\r\n\r\n\r\n\r\n\r\nlily@\r\n\r\n\r\n\r\ngyx2813\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序把玩《一》：window配置，tabBar底部导航，应用生命周期 ... \n              微信小程序学习《一》：目录文件详解，视图渲染详解 \n            \n             \n            \n                  原作者: 顺子_RTFSC \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序把玩《三》：scroll-view组件，swiper组件，icon组件\n                                    \n                  • 微信小程序把玩《四》：text组件，progress组件，button组件\n                                    \n                  • 微信小程序把玩《六》：picker组件，radio组件，slider组件\n                                    \n                  • 微信小程序把玩《十》：wx.request(object) API，wx.uploadFile(object)\n                                    \n                  • 微信小程序把玩《十一》：Image API，Record API，Audio API\n                                    \n                  • 微信小程序把玩《十二》：Video API，Storage API，location API\n                                    \n                  • 微信小程序把玩《十三》：获取设备信息 API，navigation API，animation API ...\n                                    \n                  • 微信小程序把玩《十四》：canvas API\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSp343Jj', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n关于对小程序网络请求的封装(详尽版)2020-05-19微信小程序bindtap与catchtap的区别2020-05-26小程序运行机制以及相关知识点2020-05-27\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     © 2019 极乐科技 | \n         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement(\"script\"),tag=t.getElementsByTagName(\"script\")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,\"script\",\"assets.growingio.com/2.1/gio.js\",\"gio\");\r\n  gio('init','874f0f6c4c3a4387', {});\r\n\r\n//custom page code begin here\r\n\r\n//custom page code end here\r\n\r\ngio('send');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1590581735|5d8c9cd3e46ace73ceb6090bbfe1278c|2';"}
{"title": "微信小程序把玩《一》：window配置，tabBar底部导航，应用生命周期 ...", "author": "天下雪", "time": "2016-10-17 14:39", "content": "小程序工具\" style=\"margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: rgb(51, 51, 51); line-height: 26px; background-color: rgb(255, 255, 255);\">本篇默认已经成功安装微信小程序工具一：Hello WeApp新建项目AppID查看公众开发平台设置查看（https://mp.weixin.qq.com） 项目名称随意填写本地开发项目： 新建一个空的文件夹勾线当前会生成一个项目打开项目更详细的说多了也没啥意义看官网的简易教程非常详细！ https://mp.weixin.qq.com/debug/wxadoc/dev/?t=1474644089807二：window配置window用于设置小程序的状态栏、导航条、标题、窗口背景色。注意在app.json中配置的属性会被子window属性覆盖只需在app.json配置即可三：tabBar底部导航tabBar相对而言用的还是比较多的，但是用起来并没有难，在app.json中配置下tabBar即可，注意tabBar至少需要两个最多五个Item选项主要属性：对于tabBar整体属性设置：对于tabBar中每个Item属性设置：下面是官网一张图对tabBar描述：app.json的配置相对就简单了：四：应用生命周期App() 函数用来注册一个小程序，注意必须在 app.js 中注册，且不能注册多个。 使用方式也跟Android中的Application中初始化一些全局信息以供使用。方法：应用生命周期代码："}
{"title": "【微信小程序】知乎视频查看", "author": "Rolan", "time": "2019-12-24 00:04", "content": "第一版做了知乎视频保存视频到本地相册的功能。进一步我们可以做一个增强功能，支持视频查看。用户在登录状态下载过的知乎视频，可以在我的浏览或者查看历史记录在线查看视频这个功能的核心其实是用户身份标识的获取，因为我们只要拿到了用户标识，相应用户下载过的视频就可以和用户标识绑定，存储到数据库中。当用户下次再进入app，只要通过用户标识就可以去数据库中拿用户之前下载过的视频就可以了。表结构如下：CREATE TABLE `wx_user_zhihu_answer` (\r\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\r\n  `is_delete` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '软删除标识',\r\n  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\r\n  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\r\n  `openId_md5` varchar(128) NOT NULL DEFAULT '' COMMENT 'openId md5加密',\r\n  `answer_url` varchar(128) NOT NULL DEFAULT '' COMMENT '知乎回答url',\r\n  PRIMARY KEY (`id`),\r\n  KEY `idx_is_delete` (`is_delete`),\r\n  KEY `idx_openId_md5` (`openId_md5`),\r\n  KEY `idx_answer_url` (`answer_url`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户及知乎回答信息';获取用户标识我们借鉴微信的例程来设计用户登录逻辑首先按钮上设置open-type=\"getUserInfo\",可以让用户自主选择是否授权小程序。<button class=\"login-btn\" wx:if=\"{{!hasUserInfo}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">\r\n  点击登录\r\n</button>当用户点击并确认授权，会执行回调的getUserInfo方法getUserInfo: function(e) {\r\n  app.globalData.userInfo = e.detail.userInfo;\r\n  this.setData({\r\n    userInfo: e.detail.userInfo,\r\n    hasUserInfo: true\r\n  });\r\n\r\n  // 登录\r\n  wx.login({\r\n    success: res => {\r\n      const { code } = res;\r\n      app.globalData.loginInfo.jsCode = code;\r\n      this.fetchUserIdInfo();\r\n      // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n    }\r\n  });\r\n  // 获取用户信息\r\n  wx.getSetting({\r\n    success: res => {\r\n      if (res.authSetting[\"scope.userInfo\"]) {\r\n        // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n        wx.getUserInfo({\r\n          success: res => {\r\n            const { encryptedData, iv } = res;\r\n            // 可以将 res 发送给后台解码出 unionId\r\n            app.globalData.loginInfo.encryptedData = encryptedData;\r\n            app.globalData.loginInfo.iv = iv;\r\n            this.fetchUserIdInfo();\r\n          }\r\n        });\r\n      }\r\n    }\r\n  });\r\n},\r\nfetchUserIdInfo() {\r\n  const { jsCode, encryptedData, iv } = app.globalData.loginInfo;\r\n  if (!(jsCode && encryptedData && iv)) {\r\n    return;\r\n  }\r\n  wx.request({\r\n    url: userInfoFetchUrl,\r\n    method: \"POST\",\r\n    data: {\r\n      jsCode,\r\n      encryptedData,\r\n      iv\r\n    },\r\n    header: {\r\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n    },\r\n    success: res => {\r\n      res = res.data;\r\n      if (res.code === 1) {\r\n        app.globalData.userIdInfo = res.data;\r\n      }\r\n    }\r\n  });\r\n},getUserInfo可以获取用户的信息，调用wx.login能够拿到code,调用wx.getUserInfo能够拿到encryptedData和iv。拿到code、encryptedData、iv我们就可以调用微信接口以及解码逻辑拿到用户的openId和unionId,我们这部分都放在了后端接口(userInfoFetchUrl)处理，这里我们使用openId标识用户身份，该接口返回的是openId用m5加密后的id。由于所以身份标识相关的操作都在服务器进行且返回的是md5加密后的值，所以极大提高了用户信息的安全性。后端解析用户标识的逻辑如下exports.infoFetch = async params => {\r\n  const { jsCode, encryptedData, iv } = params;\r\n  const sessionRes = await axios.get(\r\n    `${jscode2sessionUrl}?appid=${appId}&secret=${appSecret}&js_code=${jsCode}&grant_type=authorization_code`\r\n  );\r\n  const sessionResData = sessionRes.data;\r\n  const sessionKey = sessionResData.session_key;\r\n  const openId = sessionResData.openid;\r\n  const pc = new WXBizDataCrypt(appId, sessionKey);\r\n  const userInfo = pc.decryptData(encryptedData, iv);\r\n  const unionId = userInfo.unionId;\r\n  if (unionId && openId) {\r\n    return {\r\n      openIdMD5: md5(openId),\r\n      unionIdMD5: md5(unionId)\r\n    };\r\n  } else if (openId) {\r\n    return {\r\n      openIdMD5: md5(openId)\r\n    };\r\n  }\r\n  return {};\r\n};拿到用户标识后工作基本就完成了。我们还需要做一些优化，在app.js的onLaunch回调和登录页onLoad回调中获取用户信息，使得用户再次打开app在有效登录时间内依然可以直接使用用户标识。"}
{"title": "小程序 找不到可构建的npm包-解决方法", "author": "Rolan", "time": "2019-12-23 00:52", "content": "问题复现：在项目根目录执行npm init -y # 初始化npm最近在学习7yue老师的koa课，使用到npm包，出现这个问题，目录结构如下工具 -> 构建 npm -> '没有找到可以构建的 NPM 包'查看文档查阅npm 支持| 微信开放文档)有如下说明此处并没有强制要求 node_modules 必须在小程序根目录下（即 project.config.js 中的 miniprogramRoot 字段），也可以存在于小程序根目录下的各个子目录中。但是不允许 node_modules 在小程序根目录外。所以： npm包应放在小程序根目录下 ，而我搞混了小程序目录和项目根目录小程序根目录(为 /project.config.json 中 miniprogramRoot字段指定)项目根目录(为 / )是两个不同位置原来是我的node-models放错了地方，正确位置应该是**miniprogram**文件夹下问题解决cd miniprogramnpm init -ynpm install lin-ui --production工具 -> 构建 npm目录如下，出现了miniprogram_npm"}
{"title": "微信小程序学习《一》：目录文件详解，视图渲染详解", "author": "天下雪", "time": "2016-10-17 20:38", "content": "一、目录文件详解1.首先看下根目录下的app.json的文件，可以看到在”pages”的数组里，里面配置了每个界面，且包含了每个界面文件的目录2.可以看到每个页面需要包含两个文件，一个是js文件，是每个界面的入口，wxml的文件是每个界面的布局文件，那wxss是什么呢？它是每个界面的样式文件。比如：看下图可以看到，创建新的项目有两个界面，一个是index.js界面，一个是logs.js的界面，且都有对应的布局文件（.wxml）和样式文件（.wxss）3.可以看到在logs文件夹中比index文件夹中多出了一个logs.json的文件，这个文件是干嘛的呢？可见，这个文件不是必须的，因为index界面的文件夹中就没有这个文件，logs.json这个文件配置了一个界面的title的信息具体效果可以看下gif图总结1.根目录下的app.js是整个程序的入口，app.json配置整个程序的信息2.一个微信小程序必需包含的文件只需要有app.js和app.json以及对应界面的js文件和布局文件（.wxml）就可以了二、视图渲染一：创建一个页面1.首先我们新建一个项目，在新建的项目中有index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js后缀的文件是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件，.wxml后缀的文件是页面结构文件。好了，然后我们新建一个自己的页面，首先建一个文件夹（myPage），在文件夹下创建对应的布局文件（myPage.wxml）和js文件（myPage.js），最后记得在app.json中配置页面信息，在app.json中需要注意了，在pages的数组里，第一个代表着启动时第一个加载的页面2.然后进入调试界面，点击重启按钮，看下效果，会发现在控制台中弹出了报错的信息，如下：3.看报错的信息，很清楚的知道在myPage.js文件中没有找到Page方法，因此我们在myPage.js文件中调用Page方法，然后调试，重启，就会发现不报错了！4.好了，在第一点中也说到，在app.json中pages的数组里，第一个代表着启动时第一个加载的页面，那好我们把顺序调转一下，就可以验证我们的结论了建议看官方的教程：https://mp.weixin.qq.com/debug/wxadoc/dev/二、组件的使用和数据的绑定1.要了解微信小程序组件的使用，最好的方法就是查看微信小程序的API文档：https://mp.weixin.qq.com/debug/wxadoc/dev/component/可以看到API文档详细的介绍了各种组件的使用，要熟悉组件的使用，最好的方式就是多练了!2.看着文档，把官方文档的例子直接贴进来，然后我们也创建一个text组件，看看效果先吧：结合代码进行分析：js代码：三、渲染标签微信小程序给我提供了两种渲染标签：1.判断标签wx:if和wx:else虽然之前没有接触过js，可是代码也挺容易理解的，逻辑思维跟Android还是有点像，不过想学好，还是要学下js的，所以最近我也会学下js最后我们看下效果图吧，可以看到当位true的时候就显示1 false时显示22.循环标签（wx:for）看下循环标签在布局文件中的使用吧看下效果图：四、样式模板的使用从上面的代码就可以看到，一个界面可能会用到很多布局的代码，可是界面与界面之间可能会有很多重复的样式，然而这些样式的代码，每次都要重新写就很麻烦了，而且也浪费资源，微信小程序像其他开发一样，也有样式模板的使用方式1.使用include的方式包含模板样式 例如：<include src=\"../templates/myText\"  /> 具体的使用看图片：使用这种方式引用模板，实际上就是等同于把templates中的myText的代码全部复制到include这里2.使用import的方式 例如：<!--模板样式的使用  底部样式-->\r\n<import src=\"../templates/footer\"  />\r\n<template is=\"footer1\" />123最后看下效果图： Demo下载地址：Text1.zip"}
{"title": "【微信小程序】写一个能自定义尺寸、样式的switch", "author": "Rolan", "time": "2019-12-24 00:51", "content": "小程序原生的switch不能灵活的修改宽高、样式，很不方便，我这边参考 WeUI 的开关，写了一个可以自定义尺寸样式的switch组件。直接上代码： https://gitee.com/piscdong/we...效果如下图，可以自定义宽高，可以做成方角的代码分析这个switch主要的难点就是点击后背景颜色变换的动画，这里用到了css的transition、transform两个属性来实现动画，以及::before和::after两个伪元素。wxml基本结构为：<view class=\"switch\">\r\n    <view></view>\r\n</view>父级view是整个switch容器，会用到::before做背景色切换动画，::after做禁用时的灰色遮罩。内部的一个view是来回切换的白点。未选中时默认class是switch，选中时增加一个class：switch_checked。选中状态到未选中状态背景有一个从中间变大到全部的白色动画，所以需要给父级view设置一个颜色作为背景色。.switch {\r\n    ...\r\n    background: #00c000;\r\n    position: relative;\r\n}未选中时::before覆盖整个容器，选中时::before设置 transform: scale(0); ，这样选中时白色区域就会缩放到最小，再加上transition的实现动画效果。.switch::before {\r\n    display: block;\r\n    content: '';\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    border-radius: 9999rpx;\r\n    background: #fff;\r\n    transition: all 0.35s cubic-bezier(0.45, 1, 0.4, 1);\r\n}\r\n\r\n.switch_checked::before {\r\n    transform: scale(0);\r\n}来回移动的白点，未选中时通过 left: 0; 定位到左侧，选中时将left设置为100%定位到右侧，但是这样白点会完全移出容器范围，所以还需要加上 transform: translateX(-100%); 将白点向左再一定自身宽度的100%，同样加上transition的实现动画效果。.switch view {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 60rpx;\r\n    height: 60rpx;\r\n    border-radius: 50%;\r\n    background: #fff;\r\n    box-shadow: 0 2rpx 6rpx rgba(0, 0, 0, 0.4);\r\n    transition: all 0.35s cubic-bezier(0.45, 1, 0.4, 1);\r\n}\r\n\r\n.switch_checked view {\r\n    left: 100%;\r\n    transform: translateX(-100%);\r\n}关于“::”最后搭车说一下“:”和“::”，“:”是伪类，“::”是伪元素。按照我的理解：伪类不会在dom中增加节点，只不过是css选择器的一种特殊效果；伪元素会增加节点，flex布局中会影响到其他元素。为了保证兼容性，css3是允许伪元素使用单个冒号。"}
{"title": "小程序的getElementsById，就像一把梭", "author": "Rolan", "time": "2019-12-24 00:52", "content": "使用selectComponent可以抓取自定义组件实例对象，但在层层嵌套结构的业务场景中，id的设置繁复，js/wxml开发界面频繁的切换，查找、维护、调整的开发工作很是让人抓狂啊好想封装一个getElementsById方法给小程序，像在web开发中那样能够方便的获取页面元素。在父子子子子级间轻松调用，好想念jquery开发的一把梭时代！实现如下需求：任何绑定id的自定义组件都能够方便抓取实例对象(任何嵌套层级均可调用)通过数据配置思路实现不难，我们可以将所有自定义组件在create生命周期方法时将\tthis 挂载到一个全局变量中，\tdetached 生命周期时销毁该实例(不然爆内存)实现准备一个全局变量app._elements = {}\r\n复制代码挂载/销毁方法一个全局的挂载、销毁方法，方便将实例对象注册、注销在app._elements上app.mount = function(id, context){\r\n    app._elements[id] = context\r\n}\r\n\r\napp.unmount = function(id){\r\n    app._elements[id] = null\r\n}\r\n复制代码getElementsById定义全局\tgetElementsById 在Page中能够方便调用app.getElementsById = function(id){\r\n    let res = app._elements[id]\r\n    if (!res) {  // 兼容selectComponent\r\n        return wx.selectComponent('#'+id) || wx.selectComponent('.'+id)\r\n    }\r\n    return res\r\n}\r\n复制代码自定义组件ui-component组件const app = getApp()\r\nComponent({\r\n  options: {\r\n    multipleSlots: true, // 在组件定义时的选项中启用多slot支持\r\n    addGlobalClass: true\r\n  },\r\n  properties: {\r\n    dataSource: {\r\n      type: Object,\r\n    },\r\n  },\r\n  data: {},\r\n  behaviors: [],\r\n  lifetimes: {\r\n    created: function() {\r\n    },\r\n    attached: function() {\r\n        this.id = this.data.dataSource.$$id  // 专用$$id来指定唯一名称\r\n    },\r\n    ready: function() {\r\n        app.mount(this.id, this)\r\n    },\r\n    detached: function(){\r\n        app.unmount(this.id)\r\n    }\r\n  },\r\n  methods: {\r\n      active(clsName){\r\n          /* do something */\r\n      }\r\n  })\r\n复制代码应用下面开始在Page中使用\tgetElementsById 来抓取自定义组件实例wxml<ui-component dataSource=\"{{config}}\" />\r\n复制代码jsPage({\r\n    data: {\r\n        config:  {\r\n            $$id: 'component-id',\r\n            title: 'some text'\r\n        }\r\n    },\r\n    \r\n    onReady(){\r\n        // 我们应该在onReady中来调用，onLoad时，页面组件结构并没有渲染完成  \r\n        const $ele = app.getElementsById('component-id')\r\n        $ele.active('.active') \r\n    }\r\n})\r\n复制代码至此，基本思路已经实现，现在即兼容了selectComponent方法，又简化了写模板id的麻烦。不知道大家有没有了解小程序组件是可以递归嵌套自己的(模板不能递归嵌套)。因此聪明的你应该可以想到通过数据嵌套去实现组件嵌套，进而实现结构嵌套，这样我们就能够实现很复杂的页面结构，当然小程序目前建议是结构应该在30层左右，然并卵，反正它能够正常显示，哈哈"}
{"title": "微信小程序使用Promise实践", "author": "天下雪", "time": "2016-10-17 16:06", "content": "官方小例子代码getUserInfo:function(cb){\r\n    var that = this\r\n    if(this.globalData.userInfo){\r\n      typeof cb == \"function\" && cb(this.globalData.userInfo)\r\n    }else{\r\n      //调用登录接口\r\n      wx.login({\r\n        success: function () {\r\n          wx.getUserInfo({\r\n            success: function (res) {\r\n              that.globalData.userInfo = res.userInfo\r\n              typeof cb == \"function\" && cb(that.globalData.userInfo)\r\n            }\r\n          })\r\n        }\r\n      })\r\n    }\r\n  },昨天研究了一下微信小程序的例子，看见了熟悉cb了。我们好不容易从cb走向了Promise，如果开发小程序要回到cb中，这是我不能接受的，搞得我昨晚一晚上没有睡好，今年早一大早就到公司想办法解决问题。解决思路\r\n1、直接使用Promise，我试了一下，是可行的，但这受限于运行程序的浏览器。不能保证所有浏览器都支持Promise。\r\n2、使用第三方库，bluebird，Q，Defrered等，这样可以不依赖浏览器实现。\r\n说做就做，我最熟悉的是bluebird，于是先就在工程文件夹下执行npm init\r\nnpm i bluebird --save得到项目结构如下图\r\n\r\n在App.js中写入var Promise = require(\"node_modules/node_modules/js/browser/bluebird.js\");通过调试发现Promise为undfine，解决问题失败！\r\n深入分析\r\n难道真如网上所说不能加载第三方JS？我觉得应该不可能，如果不能使用第三方程序，什么都靠自己写，累都累死。忽然想到一段代码logs.js\r\nvar util = require('../../utils/util.js')\r\n\r\nutil.js\r\nmodule.exports = {\r\n  formatTime: formatTime\r\n}如果能在logs.js中引入util.js，就一定能引第三方包，只是我没有搞清楚这个加载机制。看上面的代码好像是CMD。我想来想去，最终在浏览器发现了这个。define(\"utils/util.js\", function(require, module){var window={Math:Math}/*兼容babel*/,location,document,navigator,self,localStorage,history,Caches;\r\n\r\nmodule.exports = {\r\n  formatTime: formatTime\r\n}\r\n\r\n})这是浏览加载后的代码，通过代码分析，总结出如下经验：\r\n1、原来小程序是自己定义了一套加载机制，不是CMD也不是AMD，到有点与NG相同。\r\n2、小程序会为每个js文件加一个包头，每个包中都增加一个window对象，所以在小程序中，window对象是一个局部变量。\r\n3、document对象不一定有值\r\n4、require是一个函数，module是一个对象这点与CMD一至\r\n再次尝试\r\n要在小程序中使用第三方包，就必须修改加载头。当我打开个bluebird源码时，立马就懵逼了，看不懂。所以就选择了Q，这个简单些，先看没有修改之样的。(function (definition) {\r\n    \"use strict\";\r\n\r\n    // This file will function properly as a <script> tag, or a module\r\n    // using CommonJS and NodeJS or RequireJS module formats.  In\r\n    // Common/Node/RequireJS, the module exports the Q API and when\r\n    // executed as a simple <script>, it creates a Q global instead.\r\n\r\n    // Montage Require\r\n    if (typeof bootstrap === \"function\") {\r\n        bootstrap(\"promise\", definition);\r\n\r\n    // CommonJS\r\n    } else if (typeof exports === \"object\" && typeof module === \"object\") {\r\n        module.exports = definition();\r\n\r\n    // RequireJS\r\n    } else if (typeof define === \"function\" && define.amd) {\r\n        define(definition);\r\n\r\n    // SES (Secure EcmaScript)\r\n    } else if (typeof ses !== \"undefined\") {\r\n        if (!ses.ok()) {\r\n            return;\r\n        } else {\r\n            ses.makeQ = definition;\r\n        }\r\n\r\n    // <script>\r\n    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\r\n        // Prefer window over self for add-on scripts. Use self for\r\n        // non-windowed contexts.\r\n        var global = typeof window !== \"undefined\" ? window : self;\r\n\r\n        // Get the `window` object, save the previous Q global\r\n        // and initialize Q as a global.\r\n        var previousQ = global.Q;\r\n        global.Q = definition();\r\n\r\n        // Add a noConflict function so Q can be removed from the\r\n        // global namespace.\r\n        global.Q.noConflict = function () {\r\n            global.Q = previousQ;\r\n            return this;\r\n        };\r\n\r\n    } else {\r\n        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\r\n    }\r\n\r\n})(function () {\r\n\"use strict\";这段代码，我立马就看懂了，这就是一个标准的闭包，definition是定义函数，Q一共适配了CommonJS，RequireJS加载，但可惜能过调试，进入了<script>这个分支，原因很简单，有window对象。但此window不是彼window，所以加载失败。想明白了就好改了，改后代码如下：(function (definition) {\r\n    \"use strict\";\r\n    module.exports = definition();\r\n})(function () {\r\n\"use strict\";需要注意的是definition后面一定要带()，表示执行这个函数，我一开始没有执行，结果使用时没有得到Q对象。原因是definition函数返回Q对象，大家看最一行代码。\r\n使用Q改写获取用户\r\nQ的使用很简单，主要改了这样几处地方//app.js\r\nvar Q = require(\"utils/q.js\");\r\nApp({\r\n  onLaunch: function () {\r\n    //调用API从本地缓存中获取数据\r\n    var logs = wx.getStorageSync('logs') || []\r\n    logs.unshift(Date.now())\r\n    wx.setStorageSync('logs', logs)\r\n  },\r\n  globalData:{\r\n    userInfo:null\r\n  },\r\n  login : function() {\r\n    var def = Q.defer();\r\n    wx.login({\r\n      success : function() {\r\n        def.resolve();\r\n      }\r\n    });\r\n    return def.promise;\r\n  },\r\n  getUserInfo : function() {\r\n    var that = this;\r\n    var def = Q.defer();\r\n    \r\n    if( this.globalData.userInfo ) {\r\n      def.resolve(this.globalData.userInfo);\r\n    } else {\r\n      this.login().then(function(){\r\n        wx.getUserInfo({\r\n          success : function( res ) {\r\n            that.globalData.userInfo = res.userInfo;\r\n            def.resolve(res.userInfo);\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    return def.promise;\r\n  }\r\n})//index.js\r\n//获取应用实例\r\nvar app = getApp()\r\nPage({\r\n  data: {\r\n    motto: 'Hello World',\r\n    userInfo: {}\r\n  },\r\n  //事件处理函数\r\n  bindViewTap: function() {\r\n    wx.navigateTo({\r\n      url: '../logs/logs'\r\n    })\r\n  },\r\n  onLoad: function () {\r\n    console.log('onLoad')\r\n    var that = this\r\n    //调用应用实例的方法获取全局数据\r\n    app.getUserInfo().then(function(userInfo){\r\n      that.setData({\r\n        userInfo:userInfo\r\n      })\r\n    });\r\n    console.log(window.document);\r\n  }\r\n})总结\r\n1、不要先入为主，网上的东西不能不信，也不能尽信，尽量去自己尝试。\r\n2、X讯自己造了一个封闭的环境，开放？封闭？这个东西好坏得时间来验证。\r\n3、得理解包加载机制，基础的东西最重要。"}
{"title": "纯CSS实现圆环型进度条", "author": "Rolan", "time": "2019-12-27 00:07", "content": "以下内容来自于去年的一次案例，随着微信小程序的不断改版，部分条件可能已不再适用，请谨慎参考。内容比较短，主要都在代码片段里。案例某个项目中需要用到如下图这样的一个圆环行的进度条。一开始的想法是使用canvas来实现，但是canvas是原生组件，层级最高（当时的情况），实际使用时不方便使用。所以决定尝试用纯CSS来实现这一效果。实现原理先上代码：https://developers.weixin.qq....这里主要用到的是CSS中的clip属性，将一个正方形裁剪后只显示右侧一半，但是仍然以正方形中心为圆心来旋转，来实现需要的角度。clip: rect(0rpx, 46rpx, 92rpx, 0rpx);这样最上面那个进度条就可以由以下三部分叠加，在最上面再叠加一个小一号的白色圆形，最外层加上圆角后就可以实现。（下图中红线示例了最外层的圆角以及最上层叠加的白色圆形位置）叠加效果用到蓝色圆环小于180度的情况下，需要把背景色和前景色对调。"}
{"title": "小程序标签展开收起功能实现", "author": "Rolan", "time": "2019-12-27 00:41", "content": "先看效果主要结构我用的mpvue，如用原生标签直接转换成原生即可<div id=\"labelBox\">\r\n    <div class=\"label userLabel\" v-for=\"(label,inx) in labelList\" :key=\"inx\">{{label}}</div>\r\n    <div class=\"more\" v-show=\"showLabel===1\" id=\"moreLabel\" @click=\"openMore\">\r\n        <div>全部{{allLabel.length}}个</div>\r\n        <img class=\"icon ml5\" src=\"/static/img/i_label_down.png\" />\r\n    </div>\r\n    <div class=\"more\" v-show=\"showLabel===2\" @click=\"closeMore\">\r\n        <div>收起</div>\r\n        <img class=\"icon ml5\" src=\"/static/img/i_label_up.png\" />\r\n    </div>\r\n</div>export default {\r\n    data() {\r\n        return {        \r\n            labelList: [],  // 视图显示的标签集合\r\n            allLabel: [],   // 所有的标签集合\r\n            firstLabel: [], // 默认显示的标签集合\r\n            showLabel: 1,   // 0 两个按钮都不显示，1 显示展开，2 显示收起\r\n        }\r\n    },\r\n    ...\r\n}思路利用小程序api NodesRef.boundingClientRect 获取节点的位置与大小信息，主要用到 width,left,right循环所有标签(.userLabel)，看是否有多行，通过所有节点的 left 去判断，如果 left 相同的有多个，就证明有多行获取标签父级(#labelBox)的宽度 width获取到按钮(#moreLabel)的宽度过滤第一行节点的 right，如果与按钮的width相加小于等于父级盒子的width就保留 具体的代码\r\n wxp为微信接口Promise化，会在之后列出用到的\r\n\r\n export default {\r\n    data() {\r\n        return {        \r\n            labelList: [],  // 视图显示的标签集合\r\n            allLabel: [],   // 所有的标签集合\r\n            firstLabel: [], // 默认显示的标签集合\r\n            showLabel: 1,   // 0 两个按钮都不显示，1 显示展开，2 显示收起\r\n        }\r\n    },\r\n    methods: {\r\n        async loadPageData(){\r\n            // 请求后台数据\r\n            const res = ...\r\n\r\n            // 设置\r\n            this.allLabel = res.labes;          // 记录所有的标签\r\n            this.labelList = this.allLabel;     // 先插入所有表情\r\n            // 设置状态\r\n            if(this.allLabel.length>0){\r\n                await wxp.timeout(300); // 插入视图之后不会马上获取到节点信息，延迟获取\r\n                this.setLabelStauts();\r\n            }\r\n            \r\n        },\r\n\r\n        // 设置标签状态\r\n        async setLabelStauts(){\r\n            const boxDom = await wxp.getElementById('#labelBox');\r\n            const labelDoms = await wxp.getElementsByClassName('.userLabel');\r\n            const btnDom = await wxp.getElementById('#moreLabel');\r\n            const left = labelDoms[0].left;\r\n\r\n            // 分行转为二维数组\r\n            let lineArr = [];       \r\n            let lineIndex = -1;\r\n            labelDoms.forEach(v => {\r\n                if(v.left==left){\r\n                    lineIndex++;\r\n                    lineArr[lineIndex] = [];\r\n                }\r\n                lineArr[lineIndex].push(v);\r\n            })\r\n\r\n            // 超过一行\r\n            if(lineArr.length>1){\r\n                // 默认显示加载更多按钮\r\n                this.showLabel = 1;\r\n                const firstTr = lineArr[0].filter(v => (v.right+btnDom.width+(left/15*15)) <= boxDom.width);\r\n                this.firstLabel = this.allLabel.slice(0,firstTr.length);\r\n                this.labelList = this.firstLabel;\r\n            }else{\r\n                this.showLabel = 0;\r\n            }\r\n        },\r\n\r\n        // 展开\r\n        openMore(){\r\n            this.showLabel = 2;\r\n            this.labelList = this.allLabel;\r\n        },\r\n        // 收起\r\n        closeMore(){\r\n            this.showLabel = 1;\r\n            this.labelList = this.firstLabel;\r\n        }\r\n    }\r\n}wxp.js相关代码/**\r\n * 延时\r\n * @param {*} delay \r\n */\r\nexport const timeout = delay => new Promise(resolve => setTimeout(resolve, delay));\r\n\r\n/**\r\n * 根据ID获取dom的盒模型信息\r\n * @param {*} id \r\n */\r\nexport const getElementById = (id='') => {\r\n    return new Promise((resolve, reject) => {\r\n        if ((typeof id).toLowerCase() !=='string'){\r\n            const err = {\r\n                errMsg: '请输入字符串，例如 #box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        } else if (id.indexOf('#') < 0) {\r\n            const err = {\r\n                errMsg: '请输入ID，例如 #box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        }else{\r\n            var query = wx.createSelectorQuery()\r\n            query.select(id).boundingClientRect();\r\n            query.selectViewport().scrollOffset();\r\n            query.exec(rect => {\r\n                if (rect[0]){\r\n                    let info = rect[0];\r\n                    info.position = {\r\n                        left: rect[1].scrollLeft + info.left,\r\n                        top: rect[1].scrollTop + info.top\r\n                    };\r\n                    resolve(info);\r\n                }else{\r\n                    const err = {\r\n                        errMsg: '没有获取到信息'\r\n                    }\r\n                    reject(error(err.errMsg,err));\r\n                }\r\n            })\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * 根据类名获取dom信息\r\n * @param {*} className \r\n */\r\nexport const getElementsByClassName = (className = '') => {\r\n    return new Promise((resolve, reject) => {\r\n        if ((typeof className).toLowerCase() !== 'string') {\r\n            const err = {\r\n                errMsg: '请输入字符串，例如 .box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        } else if (className.indexOf('.') < 0) {\r\n            const err = {\r\n                errMsg: '请输入类名，例如 .box'\r\n            }\r\n            reject(error(err.errMsg,err));\r\n        } else {\r\n            wx.createSelectorQuery().selectAll(className).boundingClientRect(rects => {\r\n                resolve(rects);\r\n            }).exec();\r\n        }\r\n    })\r\n}作者：不二很纯洁链接：https://www.jianshu.com/p/87f3c14038a6"}
{"title": "从CSS角度来做一个模态框", "author": "Rolan", "time": "2019-12-30 00:42", "content": "今天我们从CSS角度来做一个下图这种模态框。先上代码： https://developers.weixin.qq....模态框背后的背景是一个fixed定位，四个方向都为0的view，主要是怎么实现中间弹窗的垂直水平居中，这里提供两个方案。1、定位这种方案是将弹窗设置绝对定位后，左边（上边）距设为50%，就是弹窗左上角距父级左上角的距离正好是父级的宽度（高度）的50%，就是在正中间，同时使用 transform 属性，将弹窗向左（上）移动自身宽度（高度）的50%，来实现弹窗正好在水平（垂直）方向都能居中。position: absolute;\r\ntop: 50%;\r\nleft: 50%;\r\ntransform: translateX(-50%) translateY(-50%);2、flex布局这种方案更简单，只需要将父级设置为flex布局的同时设置 justify-content 和 align-items都是 center 就可以了。display: flex;\r\njustify-content: center;\r\nalign-items: center;彩蛋模态框弹出后，在父级上加上 catchtouchmove=\"ture\" 就可以阻止背后页面的上下滚动。"}
{"title": "xquery小程序简易步进器", "author": "Rolan", "time": "2019-12-30 00:29", "content": "这样一个简单的组件，翻了ant.design才知道这种组件叫做步进器(steper)，步进器常用于购物车等需要增减数量的场景，最近的旅游项目中用于增减房间数和人数，从产品的角度来理解步进器很简单，但在开发角度来说需要适应多种场景及控制一些状态边界值(最大值，最小值)，初始值，步进值(一次增减数量)需要可控边界状态，即超出后显示为什么状态可供外部设置边界状态的api方法内部加减方法可供外部调用的加减方法(一些场景中，外部有一个总量约束，比如sku场景)加减回调方法，比如当数量超出时提示用户相关信息多实例模式，实例之间即隔离又能交互大致需求如上，demo及实现部分如下GITHUB源码小程序代码片段wxml<view class=\"container\">\r\n  <ui-item item=\"{{steperConfig}}\" />\r\n</view>\r\n复制代码Page因为是直接使用Item组件实现，所以组件写在Page页面中，当然独立成组件看需求了const Pager = require('../components/aotoo/core/index')\r\nlet lib = Pager.lib\r\n\r\nfunction mkSteper(id=lib.suid('step_'), min, max, step=1) {\r\n  return {\r\n    $$id: id,\r\n    itemClass: 'steper-class',\r\n    title: [\r\n      {title: '-', aim: 'reduce', itemClass: 'steper-reduce'},\r\n      {title: '0', aim: 'custom', itemClass: 'steper-counter'},\r\n      {title: '+', aim: 'plus', itemClass: 'steper-plus'},\r\n    ],\r\n    methods: {\r\n      __ready(){\r\n        this.count = 0\r\n        this.min = min||0\r\n        this.max = max||10\r\n        this.step = step||1\r\n        this.stat = {\r\n          reduce: true,\r\n          plus: true,\r\n          count: true\r\n        }\r\n      },\r\n      reduce(e, param, inst){\r\n        let step = this.step\r\n\r\n        if (!inst) {\r\n          inst = this.children[0]\r\n        }\r\n\r\n        if (e === false) {\r\n          this.stat.reduce = false\r\n          inst.addClass('disable')\r\n        }\r\n\r\n        if (e === true) {\r\n          this.stat.reduce = true\r\n          inst.removeClass('disable')\r\n        }\r\n\r\n        if (typeof e === 'number') {\r\n          step = e\r\n        }\r\n\r\n        this.count -= step\r\n        if (this.count <= this.min) {\r\n          this.count = this.min\r\n          this.stat.reduce = false\r\n          inst.addClass('disable')\r\n        }\r\n\r\n        if (this.count < this.max && !this.stat.plus) {\r\n          this.stat.plus = true\r\n          let $plus = inst.siblings('steper-plus')\r\n          $plus.removeClass('disable')\r\n        }\r\n        this.changeNum(inst)\r\n        this.hooks.emit('reduce', {count: this.count}, this)\r\n\r\n      },\r\n      plus(e, param, inst){\r\n        let step = this.step\r\n\r\n        if (!inst) {\r\n          inst = this.children[2]\r\n        }\r\n\r\n        if (e === false) {\r\n          this.stat.plus = false\r\n          inst.addClass('disable')\r\n        }\r\n        if (e === true) {\r\n          this.stat.plus = true\r\n          inst.removeClass('disable')\r\n        }\r\n        if (typeof e === 'number') {\r\n          step = e\r\n        }\r\n\r\n        this.count += step\r\n        if (this.count >= this.max) {\r\n          this.count = this.max\r\n          this.stat.plus = false\r\n          inst.addClass('disable')\r\n        }\r\n        if (this.count > this.min && !this.stat.reduce) {\r\n          this.stat.reduce = true\r\n          let $reduce = inst.siblings('steper-reduce')\r\n          $reduce.removeClass('disable')\r\n        }\r\n        this.changeNum(inst)\r\n        this.hooks.emit('plus', {count: this.count}, this)\r\n      },\r\n      changeNum(inst){\r\n        let count = this.count\r\n        if (typeof inst === 'number') {\r\n          count = inst\r\n          inst = undefined\r\n        }\r\n\r\n        if (!inst) {\r\n          inst = this.children[1]\r\n        }\r\n\r\n        let $counter = inst.siblings('steper-counter')\r\n        $counter.update({\r\n          title: count\r\n        })\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nPager({\r\n  data: {\r\n    steperConfig: mkSteper('steper'),\r\n  },\r\n  onReady(){\r\n    let $steper = this.getElementsById('steper')\r\n    $steper.hooks.on('plus', function(param) {\r\n      if (this.count === 10) {\r\n        Pager.alert('不能再多了，仓库没货了')\r\n      }\r\n    })\r\n    $steper.hooks.on('reduce', function(param) {\r\n      if (param.count <= 0) {\r\n        Pager.alert('大哥，买点啊')\r\n      }\r\n    })\r\n  }\r\n})\r\n复制代码"}
{"title": "小程序初实践总结", "author": "Rolan", "time": "2019-12-31 00:05", "content": "近期组内接了小程序项目，也是有幸能够加入到项目中，做一些简单的开发。之前对小程序有所接触，但是仅限于自己了解和书写demo，真正项目开发还是第一次~开发过程中也是遇到了一些不熟悉和自己觉得是小坑的地方，做个简单总结，给自己做个记录，同时给需要的小伙伴一些小小参考。一、添加一个新组建，控制台报错“Component is not found in path '../../components/xx/xx'”。答：这个问题开始是很迷茫的，仔细检查了文件名称、引用路径以及父组件usingComponents，都没有发现有问题，但是控制台依旧提示找不到对应组件。后面经过大老提示： 对于一个新的组件，必须在对应的js里添加Component({})，json文件里也要写上component:true。加上相关配置后，控制台就不会飘红了。二、text组件，默认会出现上内边距。答：使用text组件展示文字内容，看上去并没有什么技术而言，直接引用就好了（心里默默开森）<text>\r\n  this is component\r\n</text>复制代码但是，看到效果之后，显然有点蒙圈，为什么上边会出现那么大的距离啊？！第一个想法是去看css，是否有默认内边距样式，然而并没有；通过padding、margin去设置值，也没什么用；然后。。然后。。。我就不知道怎么办了，只好请教度娘。网上有小伙伴给出了答案，其实并不是样式问题，而是text组件本身问题，要修改这个问题，只需要把text标签和内容写在一行就可以了。<text>this is component</text>\r\n复制代码三、小程序分享功能，页面分享和按钮分享功能。答：众所周知，小程序是可以进行分享的，有两种方式，一个是自带的分享功能，另一个是页面上按钮点击分享。本质上他们调用的是同一个方法，即onShareAppMessage，可以通过options参数的options.from区分是来自按钮还是原生分享，可以通过设置对应字段修改分享展示的内容，不设置则默认分享当前页。onShareAppMessage (res) {\r\n  // 来自页面内转发按钮    \r\n  if (res.from === 'button') {\r\n     return {\r\n        title: `标题`,      //分享标题        \r\n        path: shareUrl,    //分享的链接        \r\n        imageUrl:‘’        //分享展示的图片           \r\n     };    \r\n   } else {      \r\n     return {        \r\n       title: `分享标题`,        \r\n       imageUrl:''    \r\n     };\r\n   }\r\n}复制代码按钮分享，只需要给button添加一个open-type即可，<button open-type=\"share\"></button>。但是此时按钮会有默认样式，可以通过控制台查看，进行css修复样式，分享回调同样调用上边方法。四、小程序内获取某个元素或者组件距离顶部初始高度答：实际开发中，我们基本会遇到需要获取某个元素位置信息的需求，早在jq一把梭的时代，获取这些属性值是很容易的，直接一个api就可以了。同样的小程序里也有比较实用的方法，我们可以给需要获取位置的元素/组件一个id，然后通过下面方法即可获取：let query = wx.createSelectorQuery().in(this);\r\nquery.select('#testId').boundingClientRect(function(rect){\r\n    //rect即包含了所需要的各种位置信息，如top、left、right、bottom等\r\n})复制代码如果在页面初始化时需要获取到位置，可以在onLoad方法里使用（最好使用setTimeout，否则可能会取不到），获取对应值之后就可以进行后续的处理了。五、scroll-view组件使用答：滚动组件的使用，在开发中可以说很普遍了。小程序也封装了scroll-view组件，并提供了一些封装好的方法，使用起来可以说很方便了，但是也不可避免的有一些需要注意的地方。1、scroll-view的绑定scroll事件不触发当页面组件按照文档方法书写完成后，去滚动页面发现页面滚动事件并没有触发，后面经过仔细查看，确定问题原因是scroll-view没有设置高度，而且必须是精准高度，不能用百分比。2、scroll-view滚动到某一位置我们开发时可能需要用到点击后滚动到某一位置或者初始化时滚动到对应位置，过去通常是通过锚点方式进行触发，同样的scroll-view为我们封装了一个很好用的方法scroll-into-view，对应的值也是一个id值，具体使用方法及注意事项可以参考文档（ scroll-view ）。3、scroll-view中包含fixed定位元素，滚动时fixed定位元素闪动这个问题算是比较坑了，在scroll-view里面，我们设置某个元素或者组件为fixed定位，在滚动页面时，会发现定位的元素会消失一下然后再出现，虽然不是什么严重问题，但是很影响用户体验。这个问题我看到社区里也有很多人在问，但是目前官方还没有给出合理方法。目前简单的应对方法我总结了两点：一是把定位元素放到scroll-view外部，此类方法可以完美避开上述问题，但是某些场景下可能不太适用；二是，在使用scroll-view时我们通常会设置scroll-with-animation=true即开启滚动过度动画效果，当我们把这个值设置为false时，上述问题也能很好的解决，即使定位元素在scroll-view内部也不会有闪现问题。但是此方法牺牲的也是用户体验，如果有短距离的页面滚动可以使用此类方法。欢迎遇到此类问题的小伙伴进行补充，在官方给出完美方案之前，我们也能有自己的应对方案。六、小程序checkbox样式这个就不得不吐槽一下UI了，其他的都还好，但是对于表单相对应的样式，真的是丑爆了！而且，当你想通过css样式覆盖方法修改的时候，会发现，你的修改根本就是不起作用的！！根本原因就是你所看见的wxml结构与内容和样式所定义的根本不是一个样子！！！当然也有机智的小伙伴探究出了方案（以checkbox为例）：//wxml\r\n<label>\r\n    <checkbox>aaa</checkbox>\r\n</label>\r\n\r\n//wxss\r\n//修改checkbox大小\r\ncheckbox .wx-checkbox-input{}\r\n//修改checkbox选中后的样式\r\ncheckbox .wx-checkbox-input.wx-checkbox-input-checked{}\r\n//修改checkbox选中图标样式\r\ncheckbox .wx-checkbox-input.wx-checkbox-input-checked::before{}复制代码当然，如果你不喜欢原组件，不想去修改css，完全可以自己仿写一个checkbox，样式自己写，切换效果通过点击事件（参数e，获取data）自己控制就好。关于表单内容，后面会再总结一个自定义表单及自定义校验方法及自己进行的优化。七、小程序页面跳转，跳转到其他域名页面小程序页面跳转，我们可以通过wx.navigateTo()方法进行，但是当需要跳转到不同域页面时，直接跳转链接的方式就不好用了。小程序也为我们提供了方法，即webb-view( 使用方法见文档)。以上就是在初次开发中遇到的问题及总结的使用方法，后面随着使用的增多，肯定还会有更多的问题出现，随时进行添加吧，算是对小程序使用自己的一个总结，有不足和错误之处，还希望各位大大提出宝贵意见。ps：前期初次接触小程序书写demo时，也遇到了一些小问题，付个传送门：初试微信小程序遇到的问题总结"}
{"title": "红包小程序小结", "author": "Rolan", "time": "2019-12-30 00:33", "content": "最近做了一个红包兑换小程序，遇到了一些问题这里做一下总结。1、需求：回流用户在游戏客户端获取到口令，然后在小程序这边输入口令兑换红包，成功之后钱会发到用户微信账户里。2、流程：若未授权，显示授权按钮。点击授权登录，授权成功后获取到私密字段iv和encryptedData，调取登陆接口，错误则提示相关信息，正确则跳转校验姓名和身份证的页面，校验通过就调取提现接口，成功则提示提现成功，同时显示生成分享图按钮。分享图由用户昵称，头像，二维码，提现金额等等组成。3、框架：uniapp分享图的问题1、 measureText 获取宽度的时候，传入的参数如果是数字，则会返回0。let money = 10;  //这里需要把数字转成字符串\r\nctx.measureText(money).width;\r\n2、绘制图片的时候不要忘了先使用 getImageInfo 转成临时地址，再 drawImage ，如果不经过这步，虽然开发者工具上看到是正常的，但是真机是显示不了。3、需要绘制微信头像的时候，要在后台配置downloadFile合法域名 https://wx.qlogo.cn 4、最初背景图大概170KB，尺寸750*1334，最终绘制出来的分享图太大了。解决方法：把背景图片尽量再压缩，最终是60多KB。调 canvasToTempFilePath 的时候，设置 fileType 为jpg，quality范围是(0,1]，取个合适的值。 5、小程序里面的保存图片并不是长按保存的，需要点击按钮授权。<button  open-type=\"getUserInfo\"  @getuserinfo=\"onGotUserInfo\"></button>、\r\n...\r\nonGotUserInfo(e){\r\n\tuni.saveImageToPhotosAlbum({\r\n\t\tfilePath: this.tempPath,\r\n\t\tsuccess(res) {\r\n\t\t\tuni.showToast({\r\n\t\t\t  title: '保存成功',\r\n\t\t\t  icon: 'success',\r\n\t\t\t  duration: 1500\r\n\t\t\t})\r\n\t\t},\r\n\t\tfail(err){\r\n\t\r\n\t\t}\r\n\t})\r\n}\r\n...\r\n如图：如果用户点击确定，就会正常保存图片到本地相册了。如果用户点击取消，不授权呢？那还能怎么样，点击再弹出原来的弹窗重新授权呗。很遗憾，这里并不能像授权登录弹窗一样点了取消之后，再次点击授权按钮还会唤起那个弹窗。解决方法：在 saveImageToPhotosAlbum 的fail回调函数里面操作，再次获取保存到相册权限。if (err.errMsg === \"saveImageToPhotosAlbum:fail:auth denied\" || err.errMsg === \"saveImageToPhotosAlbum:fail authorize no response\" || err.errMsg === \"saveImageToPhotosAlbum:fail auth deny\") {\r\n  uni.showModal({\r\n\ttitle: '提示',\r\n\tcontent: '需要您授权保存相册',\r\n\tshowCancel: false,\r\n\tsuccess:res=>{\r\n\t  uni.openSetting({\r\n\t\tsuccess(settingdata) {\r\n\t\t  if (settingdata.authSetting['scope.writePhotosAlbum']) {\r\n\t\t\tuni.showModal({\r\n\t\t\t  title: '提示',\r\n\t\t\t  content: '获取权限成功,再次点击保存图片按钮即可保存',\r\n\t\t\t  showCancel: false,\r\n\t\t\t})\r\n\t\t  } else {\r\n\t\t\tuni.showModal({\r\n\t\t\t  title: '提示',\r\n\t\t\t  content: '获取权限失败，将无法保存到相册哦~',\r\n\t\t\t  showCancel: false,\r\n\t\t\t})\r\n\t\t  }\r\n\t\t},\r\n\t\tfail(failData) {\r\n\t\t  console.log(\"failData\",failData)\r\n\t\t},\r\n\t\tcomplete(finishData) {\r\n\t\t  console.log(\"finishData\", finishData)\r\n\t\t}\r\n\t  })\r\n\t}\r\n  })\r\n}\r\n点击取消按钮之后，会跳转到这里。打开设置里的“保存到相册”的开关即可。原生微信小程序和uniapp框架的一些对比针对此次项目，这里挑两点来写。全局变量的管理1、原生微信小程序可以在app.js的globalData对象中对全局变量进行管理app.jsApp({\r\n    globalData: {\r\n        session:\"\"\r\n    }\r\n})\r\npages/index/index.js...\r\nconst app = getApp()//获取应用实例\r\napp.globalData.session = \"xxxx\" //设置\r\napp.globalData.session  //读取\r\n...\r\n2、uniapp用的是vue的那套，所以可以用vuex来管理状态import Vue from 'vue'\r\nimport Vuex from 'vuex'\r\nVue.use(Vuex);\r\nconst store = new Vuex.Store({\r\n\t state : {\r\n\t\tsession:\"\"\r\n\t },\r\n\t mutations : {\r\n\t\tgetSession(state, res){\r\n\t\t\tstate.session = res;\r\n\t\t},\r\n\t }\r\n});\r\nexport default store\r\n设置this.$store.commit('getSession',res.session) //接口返回res.session\r\n获取this.$store.state.session\r\n页面获取全局函数返回的值1、原生微信小程序，比如在app.js中获取用户信息保存在 globalData 中userInfo字段，然后页面在onload的时候获取全局的userInfo，你会发现有时候拿不到。由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回，所以需要加入 callback 以防止这种情况。app.jsApp({\r\n  onLaunch: function() {\r\n    this.init()\r\n  },\r\n  init: function() {\r\n    // 获取用户授权结果\r\n    wx.getSetting({\r\n      success: (res) => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          wx.getUserInfo({ // 获取用户信息\r\n            success: res => {\r\n              this.globalData.userInfo = res.userInfo;\r\n              if (this.userInfoReadyCallback) {\r\n                this.userInfoReadyCallback(res)\r\n              }\r\n            },\r\n            //拒绝授权\r\n            fail: res => {\r\n\r\n            }\r\n          })\r\n        } else {\r\n\r\n        }\r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n    userInfo: \"\"\r\n  }\r\n})\r\npages/index/index.jsconst app = getApp()\r\nPage({\r\n  data: {\r\n\tuserInfo:\"\"\r\n  },\r\n  onLoad: function() {\r\n    if (app.globalData.userInfo) {\r\n      this.setData({\r\n        userInfo: app.globalData.userInfo,\r\n      })\r\n    } else{\r\n      app.userInfoReadyCallback = res => {\r\n        this.setData({\r\n          userInfo: res.userInfo,\r\n        })\r\n      }\r\n    } \r\n  },\r\n})\r\n2、uniapp是配合vuex和计算属性computed来处理的APP.vueexport default {\r\n\tonLaunch: function() {\r\n\t\tthis.getUserInfo();\r\n\t},\r\n\tmethods:{\r\n\t\tgetUserInfo() {\r\n\t\t\tuni.getSetting({\r\n\t\t\t  success: (res) => {\r\n\t\t\t\tif (res.authSetting['scope.userInfo']) {\r\n\t\t\t\t  uni.getUserInfo({ // 获取用户信息 \r\n\t\t\t\t\tsuccess: res => {\r\n\t\t\t\t\t\tthis.$store.commit('userInfo',{\r\n\t\t\t\t\t\t\tavatarUrl:res.userInfo.avatarUrl,\r\n\t\t\t\t\t\t\tnickName:res.userInfo.nickName\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t},\r\n\t\t\t\t\tfail: res => {\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t  })\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t})\r\n\t\t},\t\r\n\t}\r\n}\r\npages/index/index.vue获取到 userInfo 便可以使用了，如果需要，还可以使用watch监听。export default {\r\n\tdata() {\r\n\t\treturn {\r\n\r\n\t\t} \r\n\t},\r\n\tonLoad(){\r\n\t\t\r\n\t},\r\n\tcomputed: {\r\n\t\tuserInfo() {\r\n\t\t\treturn this.$store.state.hasUserInfo\r\n\t\t}\r\n\t},\r\n\twatch:{\r\n\t\tuserInfo(val){\r\n\t\t\tif(val){\r\n\t \t\t \t\r\n\t \t\t}\r\n\t \t}\r\n\t},\r\n\tcreated() {\r\n\r\n\t},\r\n\tmethods: {\r\n\t\t\r\n\t}\r\n}"}
{"title": "小程序中解决网络请求缓存", "author": "Rolan", "time": "2019-12-30 00:45", "content": "需求\r\n提交小程序审核时，有一个体验测评，产品让我们根据小程序的体验测评报告去优化小程序。\r\n其中有一项是网络请求的优化，给我们出了很大的难题。\r\n文档中是这样解释的：3分钟以内同一个url请求不出现两次回包大于128KB且一模一样的内容\r\n看到这个问题的时候，首先想到的是在响应头上加上cache-control，经过测试发现小程序并不支持网路请求缓存。搜索发现官方明确答复，小程序不支持网络请求缓存：wx.request不支持http缓存\r\n既然官方不支持网络请求缓存，那只能自己想办法解决这个问题了。\r\n先来看一下需求：3分钟内，同一请求只能请求一次。\r\n分析\r\n分析：\r\n\r\n只需做GET请求的网络缓存。\r\n缓存时间如何控制。\r\n做了缓存之后，如何知道3分钟，这个请求在服务端数据有没更新。\r\n提交GET请求前，先检查本地有没有缓存\r\n\r\n前两点比较好实现，虽然小程序不支持网络请求缓存，但我们还是可以利用cache-control来实现这个功能。\r\n首先网络请求需不需要情缓存统一交给服务端去做，服务端在处理GET请求时，统一加上响应头cache-control，如果需要缓存就用max-age=180，如果不需要做网络请求就用no-cache。前端根据响应头信息自己做前端缓存。\r\n其中的难点是前端如何知道服务端数据有没更新，如果服务端数据更新了，前端还是使用缓存这是有问题的。\r\n经过一番思考后发现，前端提交数据后，相应的GET请求数据会更新，也就是说前端只要有数据提交，就应该把缓存清空。\r\n这有一个难点，当前端提交数据时，前端是不知道哪些GET请求会因此更新数据，所以这个问题我们没有解决，我的方法比较粗暴：只要前端提交了数据，就将所有缓存清空。这是一个治标不治本的问题。\r\n实现\r\n公司项目封装了HTTP请求\r\n\r\n拦截请求，如果是GET请求，检查缓存，\r\n\r\n如果缓存没过期，将缓存返回出去，不再发请求\r\n如果缓存过期，发请求\r\n\r\n\r\n\r\nif (request.method.toLowerCase() === \"get\"){\r\n  // param 请求信息\r\n  const cache = this.handleCatchControl(request)\r\n  if (!cache.isRequest)\r\n    return this.listener.onApiResponse(request, 200, cache.data), sequence;   //将缓存返回给对应的请求\r\n}\r\n复制代码\r\n缓存网络请求\r\n\r\n// param 响应头，上下文，响应数据\r\nthis.setCatchControl(headers, context, response.data)\r\n复制代码\r\n两个工具函数\r\n\r\n处理网络缓存\r\n设置网络缓存\r\n\r\n\r\n\r\n\r\n设置网络请求\r\n\r\nGET请求缓存数据，其他请求清空数据\r\n数据格式：\r\n\r\n//如果同时发起多个`GET`请求，需要拼接之前缓存数据\r\nApiAgent.cacheData = Object.assign(ApiAgent.cacheData,{\r\n  [context.request.url]: {    //api\r\n    data,   //响应数据\r\n    expireTime: Number(cacheControl.split(\"=\")[1] + '000'),   //过期时间\r\n    cacheTime: new Date().getTime(),    //缓存时间\r\n  }\r\n})\r\n复制代码\r\n\r\n// param 响应头，上下文，响应数据\r\nsetCatchControl(responseHeader: any, context: any, data: any) {\r\n  if (context.request.method.toLowerCase() === \"get\") {\r\n    const headers = HandleHeaders.get(responseHeader)\r\n    const cacheControl = headers[\"cache-control\"]\r\n    if (cacheControl && cacheControl !== \"no-cache\") {\r\n      ApiAgent.cacheData = Object.assign(ApiAgent.cacheData,{\r\n        [context.request.url]: {\r\n          data,\r\n          expireTime: Number(cacheControl.split(\"=\")[1] + '000'),\r\n          cacheTime: new Date().getTime(),\r\n        }\r\n      })\r\n    }\r\n  } else {\r\n    ApiAgent.cacheData = {}\r\n  }\r\n}\r\n复制代码\r\n处理网络缓存\r\n\r\n判断缓存是否存在\r\n判断缓存有没过期，在设置缓存时，比对当前时间和缓存时间，是否小于失效时间\r\n\r\n\r\n\r\n// param 请求信息\r\nhandleCatchControl(request): any {\r\n  const cacheArr = ApiAgent.cacheData\r\n  if (Object.keys(cacheArr).length === 0)\r\n    return { isRequest: true }\r\n  let cache = {}\r\n  Object.keys(cacheArr).forEach(cacheArrKey => {\r\n    if (cacheArrKey === request.url) {\r\n      cache = cacheArr[cacheArrKey]\r\n    }\r\n  })\r\n  const newDate = new Date().getTime()\r\n  if (newDate - cache.cacheTime < expireTime){\r\n    return { isRequest: false, data: cache.data }\r\n  }\r\n  return { isRequest: true}\r\n}\r\n复制代码\r\n响应头全部变成小写，在小程序中，无法确定响应头的大小写会导致报错，所以统一处理响应头\r\n\r\nclass HandleHeaders {\r\n  static get(headers: { [key: string]: string }) {\r\n    const headersData: any = {}\r\n    Object.keys(headers).forEach(key => {\r\n      headersData[key.toLowerCase()] = headers[key]\r\n    })\r\n    return headersData\r\n  }\r\n}\r\n复制代码总结\r\n有一点没有说，就是这个缓存是保存在哪里的？\r\n既没有用localStorage，也没有用globalapp，用的是类的静态属性。\r\n这样做有3个好处：\r\n\r\n使用localStorage数据不好清除，后期可维护性也较差\r\n缓存挂在globalapp和请求无直接联系\r\n无需在退出小程序时手动清理缓存\r\n\r\n我在使用时遇到一个坑，是因为自己没有理解：类能保存数据的，不能保存状态，但类的对象是既可以保存数据，也可以保存状态的。\r\n最后，此方法还是有很大的优化空间。\r\n另外可添加微信ttxbg180218交流"}
{"title": "微信小程序setData复杂数组的更新、删除、添加、拼接", "author": "Rolan", "time": "2019-12-9 00:20", "content": "众所周知，微信小程序里所有对数据的修改只有在setData里修改才会在页面上渲染。在此分享小程序里复杂数组的更新、删除、添加、拼接 初始数据数组嵌套对象data: {\r\n    cartList = [{ id: 1, goods: {id: 1, name: 'wechat'}, checked: true }, { id: 2, goods: {}, checked: false }, { id: 3, goods: {}, checked: true }]\r\n }, 索引部分删除1 let index = 2;\r\n2 let cartList = this.data.cartList\r\n3 cartList.splice(index, 1)\r\n4 this.setData({\r\n5         cartList: cartList\r\n6       }) 内部部分修改只修改数据内某项里的某属性。但此方法对于有引用到被修改的数据的wxs不会刷新页面显示，尚未清楚是bug还是小程序本身就不支持。let index = 2\r\nlet updateTodo = `cartList[${index}].checked`\r\nthis.setData({\r\n          [updateTodo]:  true\r\n        })用一个变量接收要修改的数组，修改好后再整体setData赋值，如果原数据很大的话可能会影响性能。1 let index = 2\r\n2 let cartList = this.data.cartList;\r\n3 cartList[index].checked = res.data.checked\r\n4 this.setData({\r\n5           cartList: cartList\r\n6         }) 添加、拼接push和concat 1 // push改变原数组\r\n 2 let newList=  [{ id: 4, goods: {}, checked: true }, { id: 5, goods: {}, checked: false }}]\r\n 3 let cartList = this.data.cartList;\r\n 4 cartList.push(...newList);\r\n 5 this.setData({\r\n 6           cartList: cartList\r\n 7         })\r\n 8 \r\n 9 // concat返回添加后的副本，并不会修改原有数组\r\n10 let newList=  [{ id: 4, goods: {}, checked: true }, { id: 5, goods: {}, checked: false }}]\r\n11 let cartList = this.data.cartList;\r\n12 this.setData({\r\n13           cartList: cartList.concat(newList)\r\n14         })"}
{"title": "解决微信小程序安卓机器上 backgroundAudioManager 的一个坑", "author": "Rolan", "time": "2019-12-9 10:32", "content": "一句话来说，问题的根源就在于安卓机器上 backgroundAudioManager.pause() 后还会触发一两次 onTimeUpdate背景在做的小程序中要做的一个功能是 AB 定次重复：重复播放音频中 A 秒到 B 秒的声音 N 次。根据我的需求，理想中流程是通过 backgroundAudioManager 的绑定事件完成功能（这里先不讨论 B == backgroundAudioManager.duration 的情况）。设定backgroundAudioManager的title和srcbackgroundAudioManager.seek(A)backgroundAudioManager.onSeeking()backgroundAudioManager.onSeeked()\t4.a backgroundAudioManager.play();backgroundAudioManager.onTimeUpdate\t5.a 如果 backgroundAudioManager.currentTime >= B, backgroundAudioManager.pause()\t5.a.1 如果没达到重复次数，回到步骤2\t5.b 如果 backgroundAudioManager.currentTime < B，回到步骤5问题在几次摸索后 iOS 上可以完美完成，但是安卓上会跳次数，比如希望一共播放3次，在播放完第一次之后会直接跳过第二次进行第三次的播放，最后一共只播放了两次。解决我在网上搜的时候发现有人写到了\tbackgroundAudioManager中的一些坑 ，其中提到暂停状态下跳转到指定位置，在 onSeeked() 回调中，Android 的 currentTime 是跳转前的时间，而 iOS 是跳转后的时间。一开始我以为完全是这个原因，seek 后第一次 onTimeUpdate 时 currentTime >= B导致直接跳次数，所以我就加上一个 boolean 变量，在 onSeeked 中将它赋值为 true，用它判断是否刚执行 seek，如果否再进行 currentTime 的判断。但是改来改去问题还是存在。在加了一堆 console.log，反复和 iOS的结果比较后为发现了问题的根本所在。安卓机器上 backgroundAudioManager.pause() 后还会触发一两次 onTimeUpdate找到了问题解决起来就比较简单啦，在 onTimeUpdate 中先判断 backgroundAudioManager.paused 是否为 true，只有在 backgroundAudioManager.paused == false 时才进行步骤5的流程。结论backgroundAudioManager 和 innerAudioContext 写起来，测试起来都好痛苦。同样的代码 innerAudioContext 在 2.6.1 可以在开发工具中完成我要的效果，但是后面的版本就不行了。而且 iOS，Android 还有开发者工具上的行为都不一样，每次改一点就要用两个手机扫码预览还是挺不方便的。希望官方可以优化一下。这篇文章我原本发在微信小程序交流专区https://developers.weixin.qq.com/community/develop/article/doc/00086c3f998a603d51899109151013"}
{"title": "小程序开发中的一些实践和踩坑", "author": "Rolan", "time": "2019-12-10 00:23", "content": "在公司小程序也开发了一段时间了，中间遇到过很多问题，特此记录几个比较典型的问题和解决方案。01—textarea 的高层级问题此问题提供源码demo，可导入微信开发者工具查看。复制到电脑上打开：https://github.com/dunizb/CodeTest/tree/master/Wechat/textarea-test 症状（表现）textarea 是小程序的原生组件，它的一个表现就是优先级很高，这导致了一些困扰，比如我们有一个表单页面，最下面就是一个textarea和一个保存按钮，这会导致textarea的文字会浮现在按钮上。如下图：它最大的问题是会导致保存按钮可能点击无效或者会弹出键盘，并且开发者工具模拟器和真机表现不一样，这真是个坑！诊断（实验）模拟器中，针对 position:fixed 定位的按钮，我们加一个 z-index:10 即可， z-index 等于多少合适不清楚，试了等于1是不行的，10就可以，其余的值没试过。.submit-cls {  position: fixed;  left: 30px;  right: 30px;  bottom: 300px;  text-align: center;  background-color: green;  color: #fff;  z-index: 10;}模拟器中的表现：然儿，真机上（Android）依然无效！如下图：于是我想到了 cover-view 标签，cover-view 是微信提供的一个原生组件，它是覆盖在原生组件之上的文本视图，可覆盖的原生组件包括 map、video、canvas、camera、live-player、live-pusher之上，只支持嵌套 cover-view、cover-image，可在 cover-view 中使用 button。用 cover-view 标签包裹 button 如何呢？郁闷的事情发生了，真机上按钮不见了！。。。这方法貌似不行。。<cover-view>  <button class=\"submit-cls\" id='button' bindtap=\"onClick\"> Button z-index: 10 </button></cover-view>那我直接用 cover-view 标签作为按钮呢？<cover-view class=\"cover-view-clas\" id='cover-view' bindtap=\"onClick\"> cover-view z-index: 10 </cover-view>.cover-view-clas {  position: fixed;  height: 40px;  line-height: 40px;  left: 30px;  right: 30px;  bottom: 250px;  text-align: center;  background-color: orangered;  color: #fff;}结果在模拟器里不行但是真机上表现很好。于是我也加了一个 z-index: 10 ，这样模拟器和真机表现就一致。药方（总结）综上所述，要解决这个问题似乎只有一个办法，那就是用 cover-view + z-index:10 ，然儿这样会导致一个的副作用，没法使用微信的开放能力比如 open-type。02—setData优化我们知道，与传统的浏览器Web页面最大区别在于，小程序的是基于 双线程 模型的，在这种架构中，小程序的渲染层使用 WebView 作为渲染载体，而逻辑层则由独立的 JsCore 线程运行 JS 脚本，双方并不具备数据直接共享的通道，因此渲染层和逻辑层的通信要由 Native 的 JSBrigde 做中转。每当小程序视图数据需要更新时，逻辑层会调用小程序宿主环境提供的 setData 方法将数据从逻辑层传递到视图层，经过一系列渲染步骤之后完成UI视图更新。然而当 setData 传递大量的新数据、频繁的执行 setData 操作、过多的页面节点数时会影响渲染性能。区分数据类别意思是， setData 只用来通知页面更新，只有需要通知页面更新的时候，页面引用了某个 data 字段时才使用，其它字段数据我们有时候可能只是为了让 js 方便使用。比如如下数据data: {    form: {        name: 'xxxx',        ... ...    },    index: 0}假如 页面上根本没用到 index 来展示，只是我们的逻辑变量，那么我们在赋值的时候就直接 this.data.index = xxx 即可，不要用 setData 去赋值了。合理利用局部更新setData 是支持使用 数据路径 的方式对对象的局部字段进行更新，我们可能会遇到这样的场景：list 列表是从后台获取的数据，并展示在页面上，当 list 列表的第一项数据的 src 字段需要更新时，一般情况下我们会从后台获取新的 list 列表，执行 setData 更新整个 list 列表。// 后台获取列表数据const list = requestSync(); // 更新整个列表this.setData({ list });实际上，只有个别字段需要更新时，我们可以这么写来避免整个 list 列表更新:// 后台获取列表数据const list = requestSync(); // 局部更新列表this.setData({   'list[0].src': list[0].src});善用自定义组件小程序自定义组件的实现是由小程序官方设计的 Exparser 框架所支持，框架实现的自定义组件的组件模型与 Web Components 标准的 Shadow DOM 相似：在页面引用自定义组件后，当初始化页面时，Exparser 会在创建页面实例的同时，也会根据自定义组件的注册信息进行组件实例化，然后根据组件自带的 data 数据和组件WXML，构造出独立的 Shadow Tree ，并追加到页面 Composed Tree 。创建出来的 Shadow Tree 拥有着自己独立的逻辑空间、数据、样式环境及setData调用，这是组件化带来的好处。基于自定义组件的 Shadow DOM 模型设计，我们可以将页面中一些需要高频执行 setData 更新的功能模块（如倒计时、进度条等）封装成自定义组件嵌入到页面中。当这些自定义组件视图需要更新时，执行的是组件自己的 setData ，新旧节点树的对比计算和渲染树的更新都只限于组件内有限的节点数量，有效降低渲染时间开销。03—大表单交互的一点实践经验在项目中，有一个预约模块，字段忒多，保险业务嘛，需要用户填写各种数据的，为了用户体验拆成了多个步骤，如图一开始，业务上要求切换tab的时候数据要缓存，跟Vue的 keep-alive 一样，但是小程序没有这样的机制，所以利用小程序的 hidden 属性，也就是 Vue 中的 v-show，组件始终会被渲染，只是简单的控制显示与隐藏。关于wx:if 和 hidden。这样的导致页面节点太多，在低性能手机上会出现卡死的现象，直接无法渲染或者渲染太慢。后来改为 wx:if 来切换<view wx:if=\"{{current === 0}}\">......</view><view wx:if=\"{{current === 1}}\">......</view><view wx:if=\"{{current === 2}}\">......</view>... ...这样一来一次渲染节点太多的问题解决了，但是怎么实现tab切换的时候输入的内容杯缓存呢？其实我们的笨办法就是切换的时候把前一个表单内容保存到 localStorage 或 gloabData 中，切换回去的时候再取出来填充，这中间会有一个明显的渲染过程，肉眼可见，没办法，目前只能牺牲一点点体验了。对于这种大型表单，数据处理和逻辑交互的时候要非常注意，很容易出现性能问题。这次就说这么多吧，文章如有什么错误，或有什么想法，请留言，不吝赐教！"}
{"title": "Kbone原理解析 & 小程序技术选型", "author": "Rolan", "time": "2019-12-12 00:24", "content": "转载自微信开放社区： https://developers.weixin.qq.com/community/develop/article/doc/0006a6326b8d38e56b998833456813官方介绍“Kbone 是一个致力于微信小程序和 Web 端同构的解决方案。”Web端框架基本原理首先我们来看下普通Web端框架，以Vue框架为例，一份Vue模板对应一个组件，在代码构建阶段编译成调用Dom接口的JS函数，执行此JS函数就会创建出组件对应的Dom树，从而渲染到浏览器页面上。然而，小程序是双线程的，并没有Dom树的概念，逻辑层和视图层完全分离，逻辑层是一个纯粹的JSCore,开发者可以编写JS脚本，但是无法直接调用Dom/Bom的api, 没有任何浏览器相关的实现。在小程序中，视图层和逻辑层的交互是通过数据和时间驱动的。因此，要实现跨端同构，问题是：怎么将web端代码转为小程序代码？业界常规做法目前业界流行的第三方跨端框架们，常规做法都是：静态编译兼容。原理是把代码语法分析一遍，然后将其中的模板部分翻译成对应的跨端需求的模板（微信小程序、支付宝小程序、H5、APP等）。静态编译最大的局限性是无法保证转换的完整性，因为Vue模板和WXML模板的语法并不是直接对等的，Vue的特性设计也和小程序的设计无法划等号，这自然就导致了部分Vue特性的丢失。比如像Vue中的v-html指令、ref获取Dom节点、过滤器等就通通用不了。除了Vue自身的特性外，一些原本依赖Dom/Bom接口的Vue插件页无法使用，例如Vue-Router。Kbone的做法Kbone是通过提供 适配器 的方式来实现同构，即运行时兼容，而非静态编译。Kbone的适配器核心包含两个部分：miniprogram-render： 仿造Dom/Bom接口，构造仿造Dom树；miniprogram-element: 监听仿造Dom树变化，渲染到页面，同时监听用户行为，触发事件。仿造Dom树和浏览器的运行时对比：仿造Dom树：利用内置组件和自定义组件的自引用来进行递归，创建组件树。如图，自定义custom-dom为递归自引用组件：递归的终止条件是遇到特定节点、文本节点或者children空节点。在创建出组件树猴，将Dom节点和自定义组件实例进行绑定，以便后续的Dom更新和操作。kbone这里还对节点数进行了优化：如果一个dom节点对应一个自定义组件的话，就会创建很多自定义组件，这样会很浪费开销，这里做了子树的合并，也就是说3层才创建一个自定义组件，节省开销。优化前：17个dom=17个自定义组件； 优化后：17个dom=4个自定义组件，蓝色那个是单节点，会合并到上面的树；dom 子树作为自定义组件渲染的层级数是可以通过配置传入，理论上层级越多，使用自定义组件数量越少，性能也就越好。一棵很大的 Dom 树，一次性 setData 到视图层，可能会超过 setData 的大小限制（1024kB），拆分成多棵子 Dom 树，然后分批的 setData 到视图层，可以节省开销。事件监听小程序的事件是视图层到逻辑层的通讯方式，事件绑定在组件上，当被触发时，就会执行逻辑层中对应的事件处理函数。小程序的捕获冒泡是在视图层view端，因此逻辑层在整个捕获冒泡流程中各个节点接收到的事件不是同一个对象，小程序事件的捕获冒泡和阻止冒泡等操作必须在WXML模板中生命，无法使用接口实现。为了能够让web端和小程序端的事件系统行为一致，kbone除了仿造了一份Dom树外，也把整个事件系统仿造了一份，即在仿造Dom树上进行捕获冒泡。当自定义组件监听到用户的操作后，就将事件发往仿造Dom树，后续自定义组件监听到的同一个事件的冒泡就直接忽略。当触发改节点，仿造Dom树接收到事件后，再进行捕获和冒泡，让事件在各个节点触发。Kbone的优势支持多个前端框架：Vue、React、Preact 等支持更为完整的前端框架特性： Vue 中的 v-html 指令、Vue-router 插件等提供了常用的 dom/bom 接口可以使用小程序本身的特性： live-player 内置组件、分包功能等提供一些 Dom 扩展接口：getComputedStyle 接口等Kbone实践脚手架kbone-cli官方已经提供了kbone-cli可以用来快速开发：用npm全局安装kbone-cli可以根据自己的技术栈选择不同的开发模板：React/Vue/Omi/Preact然后就可以愉快的进行开发啦~生成的demo项目结构如下：demo中包含了多页跳转、vue-router、vuex等的使用示例，以及mp-webpack-plugin的配置示例。对于多页面的应用，在 Web 端可以直接通过 a 标签或者 location 对象进行跳转，但是在小程序中则行不通。同时 Web 端的页面 url 实现和小程序页面路由也是完全不一样的。Demo示例对比其中，有一部分两端差异的业务逻辑功能，也给出了3中不同的解决方案：利用vue-improve-loader，在构建时对dom树节点进行删减，在需要提出的节点加上check-reduce属性 利用reduce-loader，将业务中不需要被打包的代码进行去除，使用行内loader和环境变量来判断 使用样式隐藏，即设置不需要显示的节点样式为 display:none其他问题在实际开发中，还会碰到一些细节，例如：多页面开发：修改webpack和mp-webpack-plugin配置小程序内置组件： 部分用html标签代替，其他用wx-component + behavior标签小程序自定义组件：修改mp-webpack-plugin配置，补充wxCustomComponents字段，将自定义组件放入组件根目录，使用自定义组件自定义app.js和app.wxss：监听app的生命周期，修改webpack配置补充app.js的构建入口，修改插件配置的generate.app字段，补充app.js扩展dom/bom对象和API：使用 window.$$extend追加方法代码优化：用reduce-loader做体积精简，dom树精简用vue-improve-loader区分环境实现不同功能：process.env.isMiniprogram更新迭代kbone由于目前在快速发展期，更新迭代非常迅速，以下特性是对比了8月份的版本和11月份版本，可以看出已经解决了近2/3的问题。小程序技术选型详细了解了kbone之后，我们来分析下小程序技术框架到底应该怎么选？kbone & 小程序原生已有web版，需要小程序版：kbone跨平台需求（web + 小程序）：kbone对性能特别苛刻 or 追求稳定 or 要用最新功能：小程序原生页面节点数量特别多（ 1000 节点以上），且对渲染性能要求高：静态模板转义方案（第三方框架：mpvue/taro等）第三方框架MpVue ：不推荐再用了，坑越来越多，内部也表示之后不会投入太多维护WePY 1.7.x ：不推荐再用了：1.7.x 的版本在最初的设计上的缺陷导致遗留了很多比较严重的问题WePY 2.0：现在还是 alpha 阶段，内外部有一些小程序在跑，体验和反馈还可以。但依然 issue 比较多。害怕踩坑的也不推荐使用Taro: 也还是有不少问题，但相对来说应该是比 mpVue 和 WePY 更稳定一点Uni-app：mpvue的衍生版，跨端 (官方示例有6端) 支持的很好，在H5端实现了一套微信模拟器，可以尝试，是目前唯一支持app端的商用方案，有独立的编辑器HBuildXChameleon: 统一的多态协议，渐进式跨端，提供脚手架命令工具，规划比较宏大Omi ：基于Taro完成的框架，kbone有支持omi的模板Nanachi: 基于react的编译期间的转义框架总结没有跨端需求，只需要微信小程序 ==> 小程序原生web端转小程序 or 两端 or 想要尝鲜 ==> kbone多端 or Vue 技术栈 ==> uni-app多端 or React 技术栈 ==> taro不介意学习新技术栈 ==> wepy 2.0 or chaemeleon写在最后小程序在非常快速的更新迭代，就算是原生框架也还是有一些坑的，因此没有哪种框架是百分之百完美，需要根据业务具体需求以及自身技术栈偏好来进行选择。文章中提及到的部分第三方框架只是参考了官方文档，没有逐个一一尝试，有问题麻烦指出，鞠躬~~"}
{"title": "小程序 input 使用setData触发bindinput事件", "author": "Rolan", "time": "2019-12-17 00:33", "content": "背景\r\nUI设计如下图\r\n\r\n当有输入内容后显示后面的清除按钮，点击清除删除input里的内容\r\n代码实现\r\n我的代码实现是监听bindinput事件，将输入框中的值this.setData({inputValue}), 清除按钮监听点击事件，触发后this.setData({inputValue: ''})\r\n问题\r\nandroid手机上存在一个问题，当input组件是focus状态时，点击清除按钮输入框会闪一下，键盘保持弹出状态，输入框中的内容并没有删除，再次点击后才能删除， 开发者工具和ios均没有上述问题\r\n解决\r\n我发现出现上面的问题是因为在点击清除按钮时额外的触发了一次bindinput事件，将输入框中的值又重新赋值给inputValue了，我一开始以为，额外触发bindinput事件是因为input失焦导致的，但是后面又发现我点击空白的地方并不会触发bindinput事件\r\n后来我发现是setData导致的，找到了原因就可以对症下药了，查看开发文档发现bindinput的返回值中有一个keyCode属性，这个属性只有在键盘输入的时候才会有，用于记录输入的键值，所以我在bindinput中加了一层判断，如果有keyCode这个属性才会进行后面的运算。\r\n缺陷\r\n在开发者工具中使用键盘输入bindinput的返回值中并没有keyCode这个属性，所以在调试时就会存在输入的值并不会赋值给inputValue,需要注释对keyCode的判断。\r\n疑问\r\n上面的问题只会在input组件是focus状态时才会出现，如果一开始不是focus时直接点击清除按钮并不会出现上述问题，所以这个bug可能还和同时监听bindinput和bindblur或者bindfocus有关，这个有待后面进行验证。"}
{"title": "微信小程序极致的scroll-view的下拉刷新扩展组件", "author": "Rolan", "time": "2019-12-13 00:11", "content": "其实原理很简单，和普通H5以及市面上有的下拉刷新没有特别大的区别，都是基于 touch 手势检测事件来实现下拉刷新的。 touchstart 的时候记录当前触摸点， touchmove 的时候开始计算移动方向和移动距离, touchend 的时候计算是否要进行下拉刷新操作。如图所示：实现方法调研了一些实现方法，目前大部分都是通过js计算，然后setData来改变元素的 transform 值实现下拉刷新。考虑到性能问题，此处使用了 wxs 的响应式能力来实现整个计算逻辑，不用通过逻辑层和视图层通信，直接在视图层进行渲染。具体文档请参考 wxs响应事件 。这里在 list 组件(由 scroll-view 组成)下抽出了一个 scroll.wxs 作为响应事件的事件处理函数集合，源码基本上就在 scroll.wxs 和 list 组件。scroll.wxs 定义了如下变量和函数：var moveStartPosition = 0     //开始位置\r\nvar moveDistance = 0          //移动距离\r\n\r\nvar moveRefreshDistance = 60  //达到刷新的阈值\r\nvar moveMaxDistance = 100     //最大可滑动距离\r\nvar isRefreshMaxDown = false  //是否达到了最大距离， 用来判断是否要震动提示\r\n\r\nvar loading = false           //是否正在loading\r\n\r\n... ...\r\n\r\nmodule.exports = {\r\n  touchStart: touchStart, //手指开始触摸事件\r\n  touchMove: touchMove, //手指移动事件\r\n  touchEnd: touchEnd, //手指离开屏幕事件\r\n  loadingTypeChange: loadingTypeChange, //请求状态变化监听，监听刷新请求开始和请求完成\r\n  triggerRefresh: triggerRefresh //主动触发刷新操作，比如点击页面上一个按钮，重新刷新list，这就需要用到这个方法\r\n}\r\n复制代码touchStart 和 touchMove 就不用说了，代码注释都很明白，普通的监听移动和处理逻辑。touchEnd 主要是判断移动距离是否达到了阈值，然后根据结果，调用监听实例的 callMethod 方法触发 refreshStart 或者 refreshCancel 方法，这两个方法都是写到 list 组件里面的，用来触发刷新方法或者取消刷新。loadingTypeChange 方法主要是监听刷新是否完成，以此来触发动画效果。triggerRefresh 通过监听主动触发的变量来处理。如果需要主动触发刷新，则调用 list 组件内部的 forceRefresh 方法，具体使用示例在 index/index/js 的 onLoad 函数有: this.selectComponent('.list').forceRefresh()scroll.wxs 里面还有一个未导出的方法，叫 drawTransitionY ，这个方法主要是因为 ios12对于 transition 动画效果支持的不好，所以自己写了个Y轴方向的动画（ linear 线性的），大佬们可以自己往上添加各种 ease-in-out 效果。里面具体的实现可以查看代码注释哦~使用好了，前面讲了实现的原理和方法，那么在代码里面，应该怎么直接使用呢？如下代码所示：<!-- 使用示例 -->\r\n<list class=\"list\" refresh-loading=\"{{refreshLoading}}\" loading=\"{{loading}}\" bindrefresh=\"initList\" bindloadmore=\"loadmore\">\r\n  <!-- your code -->\r\n</list>\r\n复制代码refresh-loading 属性用来通过外部loading态来控制刷新动画的开始结束，因为每当变化 refresh-loading 的值时，会将变化同步到组件内的 showRefresh 属性， wxs 通过监听 showRefresh 来处理动画逻辑。loading 属性是上拉加载更多的时候触发的loading态展示，跟刷新无关bindrefresh 是刷新触发时绑定的函数，下拉刷新动画成功开始后触发这个函数bindloadmore 透传 scroll-view 的加载更多方法当然，源码里面也包含了一个 list-item 组件，这个跟本文没太大关系，是用来做瀑布流长列表内容太多时的内存不足问题解决方案的，具体请看 解决小程序渲染复杂长列表，内存不足问题"}
{"title": "小程序Canvas性能优化实战", "author": "Rolan", "time": "2019-12-17 00:18", "content": "案例背景需求：在小程序中使用canvas组件绘制地铁图，地铁图包括地铁线路、站点图标、线及站点名称文字，绘制元素为线、圆、图片、文字。支持拖动平移和双指缩放。问题：小程序中的canvas性能有限，特别在交互的过程中不断触发重绘会引发严重卡顿。基本实现在不考虑优化的情况下，先说说如何实现绘制和交互。数据格式首先看看数据，服务返回的数据中每个元素都是独立的，包括该元素的样式及坐标1234567891011121314// 线路数据lineData = { path: [x0, y0, x1, y1, ...], strokeColor, strokeWidth }// 站点数据：分为普通站点和换乘站点// 普通站点绘制简单圆形stationData = { x, y, r, fillColor, strokeColor, strokeWidth }// 换乘站点绘制换乘图标（png图片）stationData_transfer = { x, y, width, height }// 线路名称lineNameData = { text, x, y, fillColor }// 站点名称stationNameData = { text, x, y }绘图API绘制的时候遍历绘制元素数组，根据元素类型设置上下文样式，绘制及填充。接口参考：https://developers.weixin.qq.com/miniprogram/dev/api/CanvasContext.html。设置样式：setStrokeStyle, setFillStyle, setLineWidth, setFontSize绘制路线：moveTo, lineTo, stroke绘制站点：moveTo, arc, stroke, fill绘制图片：drawImage绘制文字：fillText交互实现实现交互主要步骤如下：通过bindtouchstart、bindtouchmove、bindtouchend实现对用户拖动和双指缩放的监听，得到拖动位移向量、缩放比例，触发重绘绘制时通过scale和translate在不用对数据坐标进行处理的情况下实现缩放和平移最终得到的结果如下，平均渲染时长为42.82ms，真机（ios）验证：龟速移动，画面延迟非常大。优化方法完全不了解canvas优化方案的同学可以先看看： canvas的优化。避免不必要的画布状态改变参考Canvas 最佳实践（性能篇） ，绘图上下文是一个状态机，状态的改变是有一定开销的。画布状态改变这里主要指strokeStyle、fillStyle等样式的改变。如何减少这部分的开销呢？我们可以尽量让样式相同的元素放在一起进行一次性的绘制。观察一下数据可以发现，很多站点元素样式都是相同的，那么在绘制之前可以先做一次数据的聚合，将样式相同的数据组合成一条数据：12345678910111213141516function mergeStationData(mapStation) {  let mergedData = {}  mapStation.forEach(station => {    let coord = `${station.x},${station.y},${station.r}`    let stationStyle = `${station.fillColor}|${station.strokeColor}|${station.strokeWidth}`    if (mergedData[stationStyle]) {      mergedData[stationStyle].push(coord)    } else {      mergedData[stationStyle] = [coord]    }  })  return mergedData}聚合后，329条站点数据合并为24条，有效的减少了90%的冗余状态改变开销。修改之后测试一下，平均渲染时长降到了20.48ms，真机验证：移动稍快了一些，但画面仍有较高延迟。合并数据的时候需要注意，此应用场景下各站点是没有互相压盖的，而如果有压盖顺序的话，在合并时只能合并相邻且样式相同的数据。减少绘制物筛除视野外的绘制物： 当用户在放大图像时，其实大部分绘制物都消失在了视野范围之外，避免绘制视野外的元素可以节省不必要的开销。点元素是比较容易判断是否在视野范围之外的，而站点、站点名、线路名都可以作为点元素处理；线路也可以计算出在视野范围内的部分线段，较为复杂，这里先不做处理。筛除掉视野外的绘制物之后测试一下，平均渲染时长17.02ms，真机验证：同上，没有太多变化。筛除过小的绘制物： 当用户在缩小图像时，文字和站点会由于尺寸太小而看不大清，在不影响用户体验的前提下可以考虑直接去掉。根据测试，最终决定在显示比例小于30%时去除文字和站点，这个级别下的渲染时长从22.12ms，减少到了9.68ms。降低重绘频率虽然平均渲染时长已经低了很多，但是在交互时却仍有较高的延迟，这是因为每次ontouchmove都会将渲染任务加入到异步队列中，事件触发频率远高于每秒能够执行的渲染次数，导致渲染任务严重积压，不断滞后。在PC端一般使用requestAnimationFrame解决这个问题，小程序里没有，但是可以自己实现，参考微信小程序中使用requestAnimationFrame：1234567891011121314151617const requestAnimationFrame = function (callback, lastTime) {  var lastTime;  if (typeof lastTime === 'undefined') {    lastTime = 0  }  var currTime = new Date().getTime();  var timeToCall = Math.max(0, 30 - (currTime - lastTime));  lastTime = currTime + timeToCall;  var id = setTimeout(function () {    callback(lastTime);  }, timeToCall);  return id;};const cancelAnimationFrame = function (id) {  clearTimeout(id);};PC端我们一般将渲染间隔控制在16ms左右，但是在小程序中考虑到性能限制，且移动端各机型性能不一，所以这里留了一些空间，控制在30ms，对应到30FPS左右。但如果一直循环调用也会造成静止状态下不必要的开销，所以可以在交互开始ontouchstart和结束ontouchend时分别开启、停止动画：12345678910animate(lastTime) {  this.animateId = requestAnimationFrame((t) => {    this.render()    this.animate(t)  }, lastTime)},stop() {  cancelAnimationFrame(this.animateId)},修改之后真机验证一下：画面比较流程，有轻微卡顿，但不会延迟。其他注意由于本例中缩放和平移状态是以绝对状态保存的，所以scale和translate要搭配save和restore一起使用；但也可以使用setTransform直接重置矩阵。从理论上看这样应该能节省开销，但实际测试并没什么效果，平均渲染时长在18.12ms。这个问题有待研究。小程序中避免使用setData保存与界面渲染无关的数据，以避免引起页面重绘。优化结果经过以上优化，渲染时长从42降到了17ms左右，真机验证下安卓机型普遍非常流畅，体验很好；ios机型有轻微卡顿，且随着使用时长卡顿逐渐明显，后期可以深入研究下是否有内存管理的问题。"}
{"title": "小程序跨页面数据传递与事件响应", "author": "Rolan", "time": "2019-12-17 00:27", "content": "在实际工作中有很多场景需要在第二个页面中将用户操作之后的将数据回传到上一页面。接下来将我的方案分享给小伙伴。\r\n\r\n本次示例采用 uni-app 框架和 weui 样式库\r\n\r\n实现思路\r\n\r\n创建一个 Emitter，用于事件处理\r\n创建一个全局的 Storage\r\n在第一个页面创建一个 emitter 对象，并添加事件监听，将 emitter 存储到 Storage 中\r\n在第二个页面从 Storage 中取出 emitter 对象， 并触发事件，将数据传递到第一个页面中做处理\r\n\r\n创建 Emitter\r\nfunction isFunc(fn) {\r\n  return typeof fn === 'function';\r\n}\r\n\r\nexport default class Emitter {\r\n  constructor() {\r\n    this._store = {};\r\n  }\r\n\r\n  /**\r\n   * 事件监听\r\n   * @param {String} event 事件名\r\n   * @param {Function} listener 事件回调函数\r\n   */\r\n  on(event, listener) {\r\n    const listeners = this._store[event] || (this._store[event] = []);\r\n\r\n    listeners.push(listener);\r\n  }\r\n\r\n  /**\r\n   * 取消事件监听\r\n   * @param {String} event 事件名\r\n   * @param {Function} listener 事件回调函数\r\n   */\r\n  off(event, listener) {\r\n    const listeners = this._store[event] || (this._store[event] = []);\r\n\r\n    listeners.splice(listeners.findIndex(item => item === listener), 1);\r\n  }\r\n\r\n  /**\r\n   * 事件监听 仅监听一次\r\n   * @param {String} event 事件名\r\n   * @param {Function} listener 事件回调函数\r\n   */\r\n  once(event, listener) {\r\n    const proxyListener = (data) => {\r\n      isFunc(listener) && listener.call(null, data);\r\n\r\n      this.off(event, proxyListener);\r\n    }\r\n\r\n    this.on(event, proxyListener);\r\n  }\r\n\r\n  /**\r\n   * 触发事件\r\n   * @param {String} 事件名\r\n   * @param {Object} 传给事件回调函数的参数\r\n   */\r\n  emit(event, data) {\r\n    const listeners = this._store[event] || (this._store[event] = []);\r\n\r\n    for (const listener of listeners) {\r\n      isFunc(listener) && listener.call(null, data);\r\n    }\r\n  }\r\n}\r\n\r\n复制代码创建 Storage\r\nexport class Storage {\r\n  constructor() {\r\n    this._store = {};\r\n  }\r\n\r\n  add(key, val) {\r\n    this._store[key] = val;\r\n  }\r\n  \r\n  get(key) {\r\n    return this._store[key];\r\n  }\r\n  \r\n  remove(key) {\r\n    delete this._store[key];\r\n  }\r\n  \r\n  clear() {\r\n    this._store = {};\r\n  }\r\n}\r\n\r\nexport default new Storage();\r\n\r\n复制代码第一个页面中的处理\r\n<template>\r\n  <div class=\"page\">\r\n    <div class=\"weui-cells__title\">选择城市</div>\r\n    <div class=\"weui-cells weui-cells_after-title\">\r\n      <navigator :url=\"`../select/select?id=${cityId}`\" class=\"weui-cell weui-cell_access\" hover-class=\"weui-cell_active\">\r\n        <div class=\"weui-cell__hd weui-label\">所在城市</div>\r\n        <div class=\"weui-cell__bd\" :style=\"{color: cityName || '#999'}\">{{ cityName || '请选择' }}</div>\r\n        <div class=\"weui-cell__ft weui-cell__ft_in-access\"></div>\r\n      </navigator>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport Emitter from '../../utils/emitter';\r\nimport storage from '../../utils/storage';\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      cityId: '',\r\n      cityName: '',\r\n    }\r\n  },\r\n  onLoad() {\r\n    const emitter = new Emitter();\r\n\r\n    // 将emitter存到storage中\r\n    storage.add('indexEmitter', emitter);\r\n\r\n    // 添加事件监听\r\n    emitter.on('onSelect', this.handleSelect);\r\n  },\r\n  methods: {\r\n    // 事件处理\r\n    handleSelect(data) {\r\n      this.cityId = data.id;\r\n      this.cityName = data.text;\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n复制代码第二个页面中的处理\r\n<template>\r\n  <div class=\"page\">\r\n    <div class=\"weui-cells__title\">城市列表</div>\r\n    <div class=\"weui-cells weui-cells_after-title\">\r\n      <radio-group @change=\"handleChange\">\r\n        <label class=\"weui-cell weui-check__label\" v-for=\"item in list\" :key=\"item.id\">\r\n          <radio class=\"weui-check\" :value=\"item.id\" :checked=\"`${item.id}` === selectedId\" />\r\n          <div class=\"weui-cell__bd\">{{ item.text }}</div>\r\n          <div v-if=\"`${item.id}` === selectedId\" class=\"weui-cell__ft weui-cell__ft_in-radio\">\r\n            <icon class=\"weui-icon-radio\" type=\"success_no_circle\" size=\"16\" />\r\n          </div>\r\n        </label>\r\n      </radio-group>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport storage from '../../utils/storage';\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      list: [\r\n        { id: 0, text: '北京' },\r\n        { id: 1, text: '上海' },\r\n        { id: 2, text: '广州' },\r\n        { id: 3, text: '深圳' },\r\n        { id: 4, text: '杭州' },\r\n      ],\r\n      selectedId: ''\r\n    }\r\n  },\r\n  onLoad({ id }) {\r\n    this.selectedId = id;\r\n    \r\n    // 取出 emitter\r\n    this.emitter = storage.get('indexEmitter');\r\n  },\r\n  methods: {\r\n    handleChange(e) {\r\n      this.selectedId = e.detail.value;\r\n\r\n      const item = this.list.find(({ id }) => `${id}` === e.detail.value);\r\n\r\n      // 触发事件并传递数据\r\n      this.emitter.emit('onSelect', { ...item });\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n复制代码效果展示\r\n传送门\r\ngithub\r\n总结\r\n之所以将Storage定义成全局的，是为了保证第一个页面放到Storage中和第二个页面从 Storage 中取出的emitter是同一个实例，如此第一个页面才能正确监听到第二个页面触发的事件。也可以使用 vuex，将 emitter 放到 state 中。"}
{"title": "某相册类小程序项目总结", "author": "Rolan", "time": "2019-12-19 00:02", "content": "某相册类小程序项目总结1.项目简介一款为家庭设计的亲密社交产品，分为云端存储、智能电视、小程序三个平台，小程序端主要功能包括：建立相册，上传图片、视频，单张图片(视频)的预览、分享、下载、评论相册集预览、分享、下载、评论相册内容管理，删除、下载、设置封面、重命名、设置成开机视屏及屏保图片等照片共享，手机、电视多端家庭内容同步和管理邀请、删除家庭成员，添加、删除绑定设备个性化设置家庭昵称、自己昵称、相册名称2. 主要工作和疑难点汇总2.1 主要工作封装api请求，改造wx.requeset方法，封装http请求抽取公共样式文件，在每个page文件夹的.wxss文件中，通过import 引入，\t如：@import \"../../lib/base.wxss\";抽取公共组件，如单个相册组件、弹出卡片组件、个人头像组件、照片卡片组件，通过在各个页面配置usingComponents参数使用。封装全局公共函数业务逻辑接入百度统计, 统计实时数据在我的应用中添加小程序appkey，下载解压后的js文件到utils文件夹中去，同时将百度添加到request合法域名中去。2.2 业务亮点2.3 疑难点汇总如何在小程序中使用less，可以实时转化为 .wxss文件？小程序Page里的函数比app.js先执行的解决办法fixed 元素 auto 不生效原因封装一个有输入框的modal层组件微信小程序去除button默认边框样式小程序如何获取点击元素信息小程序如何在页面间传递数组对象？小程序如何批量上传图片chooseImage、chooseVideo的回调函数中，wx.uploadFile\r\n上传，更新进度\r\nthis.data.updated_length + 1\r\n\r\n当所有照片都上传成功，updated_length == total_length时，\r\n显示完全上传完毕\r\n\r\n视频的进度显示和图片的不一样\r\n图片是每次上传成功一张，updated_length + 1\r\n视频是调用\r\nwx.uploadFile 对象的 onProgressUpdate 函数，看到视频上传进度，每500毫秒更新一次小程序几个组件如何让swiper 跳转到点击的index ？current 参数\r\npreview了, 还能点击图片么,  失败，不使用\r\nhttps://www.cnblogs.com/BlueCc/p/10172742.html动态设置小程序背景图片如何实现分享、点赞功能分享： onShareAppMessage, 点赞：根据本人是否点赞过，是否有点赞权限\r\n\r\nonShareAppMessage: function(res) {\r\n    var obj = {\r\n      from: 'sharephoto',\r\n      mac: app.globalData.mac,\r\n      open_id: app.globalData.open_id,\r\n      member_id: app.globalData.current_member.member_id,\r\n      family_id: app.globalData.family_id,\r\n      album_id: this.data.album_id\r\n    }\r\n    obj = JSON.stringify(obj);\r\n    var name = app.globalData.current_member.nick_name;\r\n    var shareObj = {\r\n　　　　title: `${name}跟你分享了一本有趣的相册集‘${this.data.album_title}’`,        // 默认是小程序的名称(可以写slogan等)\r\n       path:`pages/login/login?message=${obj}`,\r\n　　　　imageUrl: this.data.album_cover,     //自定义图片路径，可以是本地文件路径、代码包文件路径或者网络图片路径，支持PNG及JPG，不传入 imageUrl 则使用默认截图。显示图片长宽比是 5:4\r\n　　　　success: function(res){\r\n　　　　},\r\n　　　　fail: function(){\r\n　　　　}\r\n　　};\r\n　　return shareObj;\r\n  },\r\n        \r\n\r\n\r\n\r\n//节流,300ms才能点一次\r\nif (this.timer) {\r\n  clearTimeout(this.timer)\r\n}\r\nthis.timer = setTimeout(() => {\r\n  console.log('点击点赞', this.data.like_id);\r\n  server.like(family_id, this.data.album_id, mac, member_id, open_id, app.globalData.open_id, form_id,  this.data.like_id).then((res)=>{\r\n    this.getPhotoBlock();\r\n  })\r\n}, 300)如何实现全选、单选功能对某一天日期的照片，如果没张都选了，传递今天整个相册\r\n每次单选照片都会重新判断是否全选小程序时间过滤器 formatTime util的使用wxs中new Date()等js方法不可用,  所以不能用过滤器，还是用方法为什么多个 formId 会重复，因为不支持同时获取多个 formId, 每次只能获取一个如何实现预览照片，点击后跳转到单张照片？wx.previewImage，这里注意 swiper中，currentIndex 左右滑动是否一致，change函数的处理。如何支持同时预览图片和视频？直接使用 wx.previewImage缺点：不能支持视频，不支持对单张照片做其他操作，智能预览，所以先跳转到 swiper页面\r\n点击照片，预览单张照片。点击视频，跳转到vediofull页面。视频播放是否全屏videofullchange，监听全屏事件，小程序视频根据尺寸判断全屏\r\n在 chooseVideo 的时候， 获取视频的高宽解决，如果有其他照片上传失败怎么办？每次调用 showProgress如何判断小程序来源？分享？邀请？this.data.message.from几个值判断，一共有9种情况\r\n\r\n邀请、分享、在家庭中，不在家庭中，是不是管理员，是否来源扫一扫\r\n\r\n单张相片\r\n相册\r\n受到邀请，不在家庭\r\n受到邀请，在家庭中\r\n扫一扫，不在家庭中\r\n扫一扫，在家庭中，是管理员\r\n扫一扫，在家庭中，不是管理员\r\n不是成员，不是扫一扫\r\n已经在家庭中\r\n其他showActionSheet 有长度限制吗？有6个，超过怎么办？二层底部弹卡如何见人照片与视频内容过滤接入百度移动统计授权问题问题出现在，分享给第三人单张照片的时候，未先授权小程序前，不能查看照片，改变login页面逻辑，去掉入门授权，在点击分享、下载时候再询问授权\r\n首页、家庭页，操作后才授权，点击前会有蒙层安全问题需要操作的页面，onLoad都会 checkInFamily，如果不在任何家庭中，跳转到scan页面哪些情况下展示红包？创建相册、邀请成功成员如何通过扫描二维码获得数据wx.scanCode, 获取返回参数如何判断自己有没有全选评论、点赞、编辑？如果照片、视频来源于分享者，且分享人的id=评论id，用分享人的信息给后端传递参数。无论是获取评论、删除评论、发送评论，被分享人都是使用的分享者信息。一级tab页面需要哪些验证？1，首先检查有没有授权，wx.getUserInfo，授权后下一步操作  \r\n2，检查checkIn，在不在家庭中，有没有操作权限，没有退出  \r\n3，获取成员信息，检查有没有红包，有，领取后下一步操作如何拿到信息扫描？wx.scanCode({\r\n      success: (res)...\r\n      \r\n  通过res值获取获取验证码逻辑me.data.timerFun = setInterval(function () {\r\n    if (me.data.timer > 0) {\r\n    me.setData({timer:me.data.timer-1})\r\n    }else {\r\n    me.setData({timer:'重新发送'})\r\n      clearInterval(me.data.timerFun);\r\n    }\r\n    }, 1000);4. 业务逻辑梳理4.1 项目哪几个page组成？有几个组件？| 16个page  | 5个组件 |\r\n|  ----  | ----  |\r\n| login  | 获取token、管理跳转 |\r\n| le_login  | 同步账号 |\r\n| about | 账号绑定、消息、关于、意见反馈 |\r\n|  photo-edit | 照片编辑页 |\r\n| select-device | 选择屏保页面 |\r\n| h5 | 红包页面 |\r\n| comment | 评论列表页面 |\r\n| swiperphotos | 视频、照片滑动页面 |\r\n| vediofull | 全屏播放视频页面 |\r\n| photomanage | 照片管理页面，全选、反选、下载 |\r\n| photos | 相册所有照片页面 |\r\n| one-photo | 单张照片分享页面 |\r\n| homepage | 首页，我的相册页面 |\r\n| familypage | 家庭首页 |\r\n| del-member | 删除成员、设备页面 |\r\n| my-modal | 弹卡组件|\r\n| member-icon | 头像组件|\r\n| photo-album | 相册组件|\r\n| photo-detail | 相册详情组件|\r\n| red-packet | 红包组件|4.2 挑几个页面看看family 页面？1.1 邀请成员主要通过 onShareAppMessage 函数，将邀请人的信息添加在 path的参数中，在login页面中获得1.2 添加设备调整到 homescan页面1.3 退出家庭//如果只剩本人自己, 解散家庭，否则按照退出家庭算photomanage 页面？（点击，下载、设置壁纸，设置屏保后跳转的页面）全选，反选逻辑\r\n\r\n\r\n\r\n设置封面逻辑，如何做到 所有天，只有一个封面？每一天的照片、视频，是一个组件\r\n\r\nselect_photos  所有选中的照片\r\n\r\n\r\n选照片、下载、删除逻辑：\r\n传值过来的是 按日期分布的数组，按照日期对应，修改当天的照片数组。\r\n遍历所有天的照片，计算选中张数，编号。\r\n\r\n设置封面逻辑：\r\n所有天照片，只有有一天选中了，其他所有置灰。photos 页面？ 点击相册进入的页面功能：上传照片、视频，点赞、评论vediofull 页面首先需要创建视频播放上下文对象   \r\nwx.createVideoContext('myVideo');\r\n\r\n退出：\r\n视频对象 pause，退出全屏， 对象置为null\r\n\r\n监听是否需要横屏：\r\n如果视频宽度大于高度，横屏swiperphotos 页面如何支持，同时预览照片和视频？  \r\n不使用原生自带的 wx.previewImage\r\n视频，跳转到 vediofull 页面\r\n\r\n定位到当前照片是，所有 swiper数组的第几章照片  \r\n初始状态，当前滑动照片数，预览照片上面的显示数字，current_index，和 swiper组件绑定的，current值差1，change函数滑动照片，改变current_index值5. 几个组件简介member-icon:支持头像组件两种形态：文字在头像下方、文字在头像右方my-modal:支持弹出会话层有input文本框，支持编辑和新建功能\r\n    \r\n    新建相册名称为空，编辑相册名称为相册名称，怎么做到的？\r\n    新建，文本框内容为update_value，编辑为从父类传过来的数据，textvalue\r\n    \r\n    如何在操作完编辑后，新建，相册名称为空？\r\n    每次确认后，input框内容置空\r\n    \r\n    实时计算文本框字数？\r\n    bindinput函数photo-album: 相册组件每个相册组件，点击跳转到该相册详情页面red-packet: 红包组件//将红包信息参数发送给后端，传递给前端一个web-view 地址链接\r\n    //webview src指向网页的链接。（承载网页的容器，会自动铺满整个小程序页面）\r\n    <web-view src=\"{{link}}\"></web-view>photo-detail: 相册详情组件，支持同一天照片全选、反选，设置屏保、删除、下载等功能如何区分对照片的操作类型？设置封面？下载？删除？根据前一个页面传过来的操作类型判断\r\n    photo-detail只是一天的照片、视频操作，如何将所有日期选中照片传递给后端？\r\n    每次触发某一天的照片，是一个数组，向父元素触发事件，\r\n    \r\n    this.data.photo_block.forEach((item, index)=> {\r\n     if(item.days == photo.days) {\r\n       this.data.photo_block[index] = photo;\r\n     }\r\n   })\r\n   \r\n     \r\n     如何统计总数？\r\n     每次重新计算选中照片。遍历。6. 问题汇总解答1. 如何在小程序中使用less，可以实时转化为 .wxss文件？微信小程序只支持原生css写法，但是很浪费时间，使用 wxss-cli 可以实时将编写的 .less 文件自动编译为 .wxss 文件1、npm或者yarn全局安装wxss-clinpm install -g wxss-cli2、运行wxss-cli命令(miniProject为小程序目录)，less文件保存时自动编译wxss ./miniProject参考资料2. 小程序Page里的函数比app.js先执行的解决办法问题描述：当我们初始化一个小程序时，默认文件 app.js 中有onLaunch函数，onLaunch: function () {\r\n    console.log(\"onLaunch\");\r\n    wx.login({\r\n      success: res => {\r\n        console.log(\"login\");\r\n        // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n      }\r\n    })\r\n}默认目录，\"pages/index/index\", 中index.js 有 onLoad函数onLoad: function () {\r\n    console.log(\"index onLoad\");\r\n}小程序网络请求默认为异步请求，在app.js的onLaunch运行后进行异步请求时，程序不会停止，index.js页已执行onload, onload里面的数据会因为没有获取到app.js里的东西而报错, 我们希望onLaunch执行完后再执行onLoad。他们的执行顺序是，onLaunch > index onLoad > login我们希望的执行顺序是：onLaunch > login > index onLoad解决办法定义回调函数, onload里获取不到东西就一直获取，不执行下一步操作，直到获取到app.js的数据才继续执行。若login返回为空，则给app.js注册一个loginSuccessCallback回调，这个回调方法的执行时机，就是app.js中的异步请求完毕把 app.js 中的 onLaunch 中方法拿到 index.js 文件中，按照自己的逻辑写使用promise方法1：App({\r\n  onLaunch: function () {\r\n    wx.login({\r\n      success: res => {\r\n        this.globalData.checkLogin = true;\r\n        //由于这里是网络请求，可能会在 Page.onLoad 之后才返回\r\n        // 所以此处加入 callback 以防止这种情况\r\n        if (this.checkLoginReadyCallback){\r\n          this.checkLoginReadyCallback(res);\r\n        }\r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n    checkLogin: false\r\n  }\r\n  \r\n  ...\r\n})\r\n \r\n\r\n//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n \r\nPage({\r\n  data: {\r\n    test: false\r\n  },\r\n  onLoad: function () {\r\n    let that = this;\r\n    //判断onLaunch是否执行完毕\r\n    if (app.globalData.checkLogin){\r\n      that.setData({\r\n        test:true\r\n      })\r\n    }else{\r\n      app.checkLoginReadyCallback = res => {\r\n            //登陆成功后自己希望执行的，和上面一样\r\n        that.setData({\r\n          test:true\r\n        })\r\n      };\r\n    }\r\n  }\r\n})方法2：把 app.js 中的 onLaunch 中登陆后才执行的方法拿到 index.js 文件中，这是最简单的方法//index.js\r\n\r\nonLoad: function () { \r\n    wx.login({\r\n      success: res => {\r\n        resolve(res); \r\n      }\r\n    })\r\n}方法3：// app.js中定义一个新的方法\r\nApp({\r\n  onLaunch: function () {\r\n      ...\r\n  },\r\n  getAuthKey: function (argument) {\r\n    var that = this;\r\n    return new Promise(function(resolve, reject){\r\n        wx.login({\r\n          success: res => {\r\n            resolve(res); \r\n          }\r\n        })\r\n    })\r\n  }\r\n  ...\r\n  \r\n})\r\n\r\n//index.js\r\nonLoad: function () {\r\n    ...\r\n        \r\n    app.getAuthKey().then(function(res){\r\n      console.log('res')\r\n    })\r\n }参考资料：\t参考1 参考2 参考33. fixed 元素 auto 必须要同时设置 top、leftposition: fixed;\r\ntop: 132rpx;\r\nleft: 30rpx;\r\nwidth: 690rpx;\r\nmargin: 0 auto;4.封装一个有输入框的modal层组件其实很简单，就是在modal中添加新的 input,<view>\r\n    <modal class=\"modal\" wx:if=\"{{!hiddenModal}}\"\r\n     title=\"{{title}}\" confirm-text=\"确定\" cancel-text=\"取消\" bindconfirm=\"modalconfirm\" bindcancel=\"modalcancel\">\r\n        <view class=\"input-line\">\r\n            <input placeholder='请输入内容' maxlength=\"{{ maxlength }}\" bindinput='input' type=\"text\" type=\"text\"  value=\"{{ textvalue }}\" />\r\n            <text>{{ currentlength}}/{{ maxlength }}</text>\r\n        </view>\r\n    </modal>\r\n</view>\r\n\r\n.modal{\r\n    width: 540rpx;\r\n    max-width: 540rpx;\r\n    border-radius: 28rpx;\r\n    .input-line {\r\n        display: flex;\r\n        border: 2rpx solid rgba(0, 0, 0, 0.05);\r\n        font-size: 28rpx;\r\n        padding: 16rpx;\r\n        height: 40rpx;\r\n        line-height: 40rpx;\r\n    }\r\n    input,  text{\r\n        display: inline-block;\r\n        vertical-align: top;\r\n    }\r\n    input {\r\n        flex: 1;\r\n    }\r\n    text {\r\n        width: 90rpx;\r\n        color: #FFA004 ;\r\n    }\r\n}5.微信小程序去除button默认边框样式button::after{\r\n    border: none;\r\n}6.小程序如何获取点击元素信息使用驼峰模式，给点击元素绑定 data-\t* ，通过 event.currentTarget.dataset 获取<image src=\"{{ item.mini_pic }}\" class=\"{{ item.show_opacity ? 'show_opacity' : ''}}\" bindtap=\"tap\" data-message=\"{{ item }}\">\r\n</image>\r\n\r\n// 获取的点击节点元素是一个对象\r\n tap: function(event) {\r\n    var message = event.currentTarget.dataset.message;\r\n}7. 小程序如何在页面间传递数组对象？方法1：A页面跳转链接添加参数，B页面onLoad 接受方法2：设置全局变量 globalData，用的少，一般适用于全局共享的一份信息，如用户open_id等// A页面\r\n// 数组、对象都需要stringify\r\nvar listData = JSON.stringify(that.data.listData)\r\nvar taskArray = JSON.stringify(that.data.taskArray)\r\nwx.navigateTo({\r\n    url: '../workRecord/updateBatch?listData=' + listData + '&taskArray=' + taskArray \r\n})\r\n\r\n//B页面\r\nonLoad: function (options) {\r\n    var that = this\r\n    var listData = JSON.parse(options.listData)\r\n    var taskArray = JSON.parse(options.taskArray)\r\n}\r\n\r\n\r\n\r\n//A页面：\r\napp.globalData.open_id = 3;\r\n//B页面：\r\nvar lala = app.globalData.open_id;8. 小程序如何批量上传图片chooseImage、的回调函数中，wx.uploadFile\r\n    上传，更新进度6. 其他封装http请求class HTTP{request({url,data={},method='POST', header={'content-type':'application/json'} }){\r\n            return new Promise((resolve, reject)=>{\r\n                this._request(url,resolve,reject,data, method, header)\r\n            })\r\n        }\r\n        _request(url,resolve, reject, data={}, method='POST', header){\r\n            wx.request({\r\n                url:url,\r\n                method:method,\r\n                data:data,\r\n                header: header,\r\n                success:(res)=>{\r\n                    const code = res.statusCode.toString()\r\n                    if (code.startsWith('2') && res.data.errno == 10000){\r\n                        resolve(res.data)\r\n                    }\r\n                    else{\r\n                        if(res && res.data && res.data.errmsg) {\r\n                            this._show_error(res.data.errmsg)\r\n                        }\r\n                        else {\r\n                            this._show_error(tips[1])\r\n                        }\r\n                        console.log('错111111111')\r\n                        reject(res)\r\n                    }\r\n                },\r\n                fail:(err)=>{\r\n                    reject(err)\r\n                    console.log('错22222222')\r\n                    this._show_error(tips[1])\r\n                }\r\n            })\r\n    \r\n        }\r\n    \r\n        _show_error(tip){\r\n            if(!tip){\r\n                tip = tips[1]\r\n            }\r\n            wx.showToast({\r\n                title: tip,\r\n                icon:'none',\r\n                duration:2000\r\n            })\r\n        }\r\n    }"}
{"title": "小程序自定义组件之下拉菜单", "author": "Rolan", "time": "2020-5-6 00:23", "content": "图例中筛选是另外一个组件一般在筛选的场景中需要使用下拉菜单，动态设置筛选条件，比如淘宝，京东的产品筛选列表，携程的旅游目的地的筛选列表。支持配置化设置弹层内容支持动态刷新弹层内容支持动态修改分类标题支持遮罩层支持api关闭弹层配置wxml模板<view class=\"container\">\r\n  <ui-list list=\"{{tabConfig}}\" />\r\n</view>\r\n复制代码jsconst Pager = require('../../components/aotoo/core/index')\r\nconst mkDropdown = require('../../components/modules/dropdown')\r\n\r\nPager({\r\n  data: {\r\n    tabConfig: mkDropdown({\r\n      id: 'xxx',\r\n      data: [\r\n        {title: '选项-1'}, \r\n        {title: '选项-2'}, \r\n        {title: '选项-3'},\r\n        {title: '选项-3'},\r\n      ],\r\n      tap(data, index){\r\n        if (index === 0) {\r\n          this.updateContent({ ...checkListConfig })  // 配置弹层内容\r\n          let title = this.getTitle()\r\n        }\r\n      }\r\n    }),\r\n  },\r\n})\r\n复制代码updateContent更新的结构是一次性的，即再次打开时，实例维持不变，如果需要强制刷新，指定第二参数为true属性说明id{String}指定实例名称，在page中可通过this[id]找到实例data{Array}配置下拉菜单的列表，组件自动生成器对应的弹层tap{Function}下拉菜单项点击时的响应事件如何设置如何设置data数据data数组展示下拉菜单的所有菜单项，每一项必须为Object类型的数据，每一项数据可自定义，支持图片，文字，图片组，文字组等等菜单项由item组件构成，因此可以支持非常丰富的结构用于展示指定图片{img: 'path/to/imgsrc'}\r\n复制代码指定文字{title: '文字标题'}\r\n复制代码指定图文{title: '文字标题', img: 'path/to/imgsrc'}  \r\n\r\n// 更改图文顺序只需要把属性位置倒置  \r\n{img: 'path/to/imgsrc', title: '文字标题'}\r\n复制代码指定图组，文字组// 文字组\r\n{title: ['文字标题-1', '文字标题-2']}  \r\n\r\n// 图片组\r\n{img: [{src: 'path/to/imgsrc'}, {src: 'path/to/imgsrc'}]}\r\n复制代码同时也支持图组，文字组混排，根据需求如何获取实例当指定id后，便可以在page页中，方便的获取下拉菜单的实例，调用实例方法注意Pager和Page的区别，Page是微信小程序原生方法，Pager是对Page的二次封装，Pager支持原生Page的所有属性、方法，但反过来则不能支持mkDropdown({ id: 'xxx' })\r\n\r\n// 获取实例  \r\nPager({\r\n  onReady(){\r\n    const instance = this['xxx']\r\n    console.log(instance)\r\n  }\r\n})\r\n复制代码如何配置弹层内容通过tap响应方法支持，设置弹出内容和菜单项标题tap方法的上下文(context)环境updateContent{Function} 更新菜单项弹出层内容updateTitle{Function}更新菜单项标题getTitle{Function}获取当前菜单项标题mkDropdown({ \r\n  id: 'xxx',\r\n  data: [...],\r\n  tap(data, index){ // data为菜单项数据，index为菜单项位置  \r\n    if (index === 0) {  // 菜单栏第一项\r\n      this.updateTitle()  // 更新标题\r\n      // this.updateContent()  更新内容\r\n    }\r\n  }\r\n})\r\n复制代码更新弹出类容为列表下列配置，会在弹出框中渲染列表结构this.updateContent({\r\n  \"@list\": {\r\n    data: [\r\n      {title: '1'},\r\n      {title: '2'},\r\n    ]\r\n  }\r\n})\r\n复制代码更新弹出类容为表单下列配置，会在弹出框中渲染列表结构this.updateContent({\r\n  \"@form\": {\r\n    data: [\r\n      {title: '表单区域1', input: [...]},\r\n      {title: '表单区域2', input: [...]},\r\n    ]\r\n  }\r\n})\r\n复制代码更新弹出类容为多层筛选列表下列配置，会在弹出框中渲染列表结构this.updateContent({\r\n  \"@list\": mkChecklist({\r\n    ...\r\n  })\r\n})\r\n复制代码"}
{"title": "企业数字化转型，都开始做私域流量转投小程序直播了？", "author": "Rolan", "time": "2020-5-7 00:01", "content": "直播带货，为电商营销赋予创新红利。这是直播带货大行其道，为电商营销赋予创新红利的泛商业时代，尤其在2020年这场疫情期间，突显出了巨大的商业价值，给企业数字化转型自救提供了便捷的途径。尽管眼看有人一场直播带货，销售过亿，也有人坐拥百万流量但成交寥寥无几，甚至还有人直播当场翻车，惨遭滑铁卢，但商户和品牌主们追逐直播带货的热情从未停下来，争先恐后地闯进了这片红海，寄望真金白银的投放能换来一个网红品牌，又或者实现销量暴增的目标。一、直播带货注定烽火燎原在疫情这层阴影的笼罩下，首当其冲的就是零售业企业。从CCFA中国经营连锁协会获取的数据来看，疫情期间门店关店率高达70%以上，业绩普遍下滑超过90%，员工闲置在家的情况比比皆是。遭受突如其来的黑天鹅事件，处于冰封状态的零售业，自救回血就是首要目标，于是转投直播获取流量卖货，成为了顺理成章的重要选择。2019年双11，淘宝直播带货销售额1天就突破200亿元，这让所有商户都看到了直播带货的威力和潜力。而且，有权威机构指出，预计2020全年主流直播电商平台，全年带货金额将突破4000亿元。所以，直播带货在2020年注定是烽火燎原的。二、始于流量，终于运营1.直播带货：货找人，更高效直播带货的出现，正在加速改变互联网的供需关系。从人货场的角度去看，直播工具创造出了全新的消费场景，承载了在线沟通的功能，能直接地传递品牌的观念，依托电商平台的服务保障，能充分地给用户带来顺畅的购买体验。可见，直播带货改变了过去电商行业人找货的模式，实现了交易更高效的货找人模式。正是因为如此，互联网巨头不可能错失这个分一杯羹的机会，纷纷入局沉浸在这场流量红利的狂欢之中，不断推出一系列扶持计划，让更多品牌和商户加入这场流量博弈的游戏。2.直播带货：拼流量，更要拼运营和管理在这股全民直播的浪潮下，流量似乎是万能的。然而，有些问题并非流量所能解决的，所有人也千万别寄望流量能解决电商卖货的所有问题。主播带不动货，怎么办？为什么直播间观看人数不够多，实时在线人数增长缓慢？直播间进来的粉丝不精准，互动低，新增粉丝也不多，如何解决？进来直播间的粉丝很快又离开了，流失率很高，有哪些方法可应对？归根到底，直播带货离不开运营和管理，毕竟互联网是依靠多方面的运营管理手段来实现商业系统持续产生效益。众所周知，广告投放的方式能够带来大批精准的流量，当中就需要不断对广告投放进行精细化运营和优化，根据目标用户分类理解人群价值，针对性地进行定向的广告投放。例如品类内容关注的用户，未曾有过直播相关的行为，那么就应该把运营的重心放在如何合理利用对品类内容的关注，来引导到直播间，最终把看播和加粉作为运营的目标。再例如选品的管理，除了要考虑成本和供应链的能力，还要考虑商品是否具备成为爆款的潜力，一旦商品能成为爆款，那意味着用户会复购，对店铺的粘性也会更强，有利于带动其他商品销售。如果商品销量一般，商品的更替计划也要提前准备好。而且，随着商品的转化成交不断提升，就会沉淀下来更丰富的数据，能够为后续的广告投放提供更精准可靠的依据。毫无疑问，直播带货拼的不只是流量，要持续产生价值，还要拼运营和管理，遵循互联网商业的常识和发展规律。三、小程序直播，已成为电商必争之地纵观当下，传统电商平台的直播带货如火如荼，头部和腰部主播的热度高企，坑位费普遍上涨，卖货的佣金比例也有所增加，因此按照二八法则，后入者门槛相对变高。于是，不少商户和品牌主把小程序作为直播带货的第二战场，因为背靠微信成熟的生态和巨大的流量池，具备强社交和易传播的优势，借力小程序能够高效连接线上和线下，把零售电商的核心要素（即人流、信息流、资金流、物流）充分联结起来，实现私域流量池的建立和变现。1. 小程序直播的护城河(1)原生优势，获客效率更高使用即安装，更有效留存，留存才是真正的增长；多种访问路径，用户更方便回访，可随时触达用户；具备广告、搜索功能，意味着拥有更丰富的流量入口，可推送开播预告、秒杀活动等信息。可见，直播小程序相对其他直播平台而言，获客效率是更高的。(2)从引爆私域流量开始，实现流量沉淀在直播开播前，商户可以通过朋友圈、社群、公众号消息模板引导用户关注直播间，开播前收到提醒，提前激活私域流量，锁住忠诚客户；商户还能引导用户关注公众号，持续积累私域流量，多通道触达粘性更高，也方便后续对用户进行二次营销，可利用多元化的会员玩法，增进复购。在开播进行的过程中，直播间广告位还可以导流到商城小程序，引导用户跳转到商城里面选购商品，提升了单uv的价值，最终完成私域流量沉淀。(3)借助营销工具组合，提升成交效率在微信生态里，分销、砍价这些常见的营销工具都可以为直播小程序提供有效的帮助，能让观众主动分享转发，达到刺激购买的目的。商户还可以通过优惠券和秒杀的方式，吸引更多的用户下单，同时在直播间还可以发放礼盒小奖品，提升用户留存，有利于促成交易。(4)处于封闭的生态循环，赋能数据决策直播小程序，与小程序商城、社群、公众号、支付、社交广告，共同构成了微信的封闭生态。微信生态的一体化加速了变现的同时，也为用户管理、渠道管理、运营策略的数据决策提供了必要的支撑。所以，我们可以结合流量监控、推广效果跟踪、成交分析等来评估每场直播带货的活动效果，进行复盘和优化，基于数据结果，为后续直播策划提供更好的决策。(5)不止直播，引流到店对于品牌主而言，人货场都是数字化经营，线上直播带货不仅是高效的传播推广方式，触达广大的消费者，给线下门店带来流量，还能从用户消费和商品热销数据里洞察到品牌的市场反馈，能够为线下门店的商品经营提供参考依据。对于商户而言，线上直播带货的流量当沉淀成为私域流量后，可导入到线下门店，提高门店流量，帮助线下门店更好卖货，实现线上线下一体化联动。2. 小程序直播，本质是私域流量直播疫情考验了企业的造血自救能力，尤其很多企业在预算非常有限的情况下，没有选择网红主播和MCN机构来做直播带货，纷纷让自家的员工、门店导购利用小程序做直播带货，小程序直播无疑提供了企业快速实现数字化的通道。(1)小程序直播，普通素人的最佳秀场小程序直播确实很适合品牌商员工、门店导购等普通素人，因为他们对用户和产品非常熟悉，具备丰富的销售技巧，基于微信的熟人社交关系，更容易互动，提升转化成交。而且，公众号、消息模板、菜单、小程序商城、社群、朋友圈都可以直接成为直播活动的流量入口，再配合微信的裂变和推广，还有门店海报的二维码，最终构成了小程序直播得天独厚的条件。(2)小程序直播，私域流量的复用利器不难发现，这些天然的流量入口，在直播还没到来之前，就已经成为触达用户的私域矩阵，所以小程序直播是提升了微信生态流量资源的利用率，并且借助小程序直播，还能反哺社群、朋友圈、公众号这些私域流量得到不断壮大，形成螺旋式上升的增长趋势，从而更有力地推动微信生态流量持续变现，体现出了复利，完全符合微信生态的价值主张。由此看来，小程序直播，就是私域流量直播。从人货场的角度去看，微信生态这个场提供了多层面和多渠道的推广触点入口，不管是KOC、社群还是品牌官方和门店对个人用户而言，都是属于本来就存在的私域流量关系，并且还可以基于社交关系链产生多次裂变传播，这是只有微信才拥有的壁垒。所以，小程序直播是复用了这些私域流量，与直播平台+网红主播+MCN机构的模式相比，最显著的区别就在于让品牌商的员工和门店导购，替代了网红主播和MCN机构。其实，两种模式各有优势，网红主播和MCN机构这样的公域流量能带来强曝光，可以帮助品牌打响品宣的第一枪，配合话题营销，很容易被广泛认识；员工和导购的小程序直播，会把销量作为首要目标，凭借微信的私域流量可进行高频互动和触达，不断积累用户信任，加强用户与品牌的粘性，配合多元化的促销玩法，最终能实现销售业绩倍增。值得一说的是，朋友圈广告也能把流量引导到小程序的直播间，通过精准的投放，能带来强流量和强转化，这也是基于私域流量所展开的营销动作，当中需要品牌主对目标消费群体有深度的洞察，辅以创意内容和优化投放，来充分实现品效合一。四、品牌企业的新增长：小程序直播与私域流量双驱动1. Cabbeen卡宾服饰，7天1500W+销售额疫情期间，很多零售企业正遭受着不同程度的冲击，都纷纷启动了线上直播带货，Cabbeen卡宾服饰也不例外，选择了小程序直播的方式。据官方透露，直播以来共有280万+人观看、新增会员45w人，并创下了38秒成交金额高达100w、7天销售额突破1500w的记录，领跑全国小程序男装类目。Cabbeen卡宾服饰直播卖货之所以取得这么夺目的成绩，我认为可以归结为充分利用了私域流量的优势：(1)激励导购和员工，通过社群和朋友圈开展全员分销(2)根据社群的活跃度，进行精细化的分层运营(3)发起秒杀、抽奖、大转盘等互动活动增强了社群用户粘性(4)小程序直播结合社群，使用优惠券、赠品等激励手段，促进用户下单Cabbeen卡宾服饰小程序直播&社群抢购Cabbeen卡宾服饰通过私域流量运营和小程序直播，与消费者之间搭建起了高效的营销互动场景，在零售实体门店受疫情影响的情况下，无疑创造了新的增长，相信这能够给更多零售企业带来启发，为业务升级转型提供了可借鉴的思路和方法。2.梦洁家纺，4小时2500W+销售额梦洁家纺通过小程序直播卖货的方式，也同样达成了相当亮眼的业绩：130万+的在线观看人数，其中近60W人同时在线，最终4个小时完成了2500多万销售额。梦洁家纺从直播创建、流量获取以及交易转化的营销闭环，都做足了准备：(1)在直播开始前，让门店导购将线下流量快速导入线上社群(2)在朋友圈、社群预告直播内容，导购负责在群里介绍商品(3)直播开启后，群里发起砍价活动，让用户积极分享出去，形成裂变传播(4)直播间发放秒杀和限时折扣券，刺激用户把商品加入到购物车(5)在评论区与用户互动，活跃直播间氛围，激发用户购买欲望(6)直播结束后，采用了直播回放功能，让用户在回顾直播的过程中下单购买梦洁家纺直播间及互动梦洁家纺直播带货的销量持续上涨，全靠私域流量的推动，直面用户的门店导购、社群、朋友圈等多样化的社交触点一直都在为小程序直播的推广和转化，快速蓄积了流量，最终让直播的投入获得最大化的回报。相信梦洁家纺的小程序直播案例，能让品牌主理解，私域流量运营得当，可改进流量获取和直播推广的效率。五、小程序直播，释放私域流量新价值当企业逐渐建设了自己的私域流量池，往往会遇到一个很现实的问题，那就是如何与用户进行有效的互动，实现用户留存的转化。别简单以为建立了社群，在群里发放优惠折扣，发起拼团砍价的活动，就是在做私域流量运营。不难理解，用户也不会喜欢这样轰炸式的内容推送，非常容易引起反感，最终就是退出社群。小程序直播的出现，是私域流量运营的一个重要拐点。因为小程序直播离用户很近，可以有效形成社交互动，直播内容从而承接和转化了私域流量。通过小程序直播，企业能直接地给用户传递最新的品牌动态，进行友好的双向互动交流，从交易数据中能洞察到用户对品牌的喜好，这把私域流量的价值发挥到极致。直播已经成为营销增长的利器，尤其依靠在微信生态下的小程序直播，对企业实现数字化增长而言具有战略性的意义，当中私域流量作为触点的重要载体，我们有必要深入了解小程序直播的私域流量运营全链路，更好把握转化关键。1.蓄量环节企业的私域流量池，通常由门店导购微信号、自建社群、公众号粉丝、小程序的自然流量组成。所以，朋友圈、社群、公众号的直播预告必不可少，可以邀约用户进群领取优惠券等福利，观看直播，提前锁定用户。即使用户错过直播，在社群里发起抢购活动还是能刺激用户下单的。 服务号的消息模板也能提醒用户，可引导用户添加直播助手的微信号，然后邀请进群。2.增量环节蓄量环节过后，我们该思考如何持续为直播间带来新的流量，这就是增量环节的任务。有吸引力的内容再加上高频的互动，会更容易让用户产生裂变的行为，从而传播引进新的流量，比如直播间的抽奖和砍价，就能够让直播间的用户，主动转发邀请好友参与。举个例子，当前直播间的在线观看人数8万，我们可以告诉直播间里的用户，如果超过10万，将会抽出万元大奖，那么用户就会积极分享直播间的海报到朋友圈。显然，直播间的增量会因为庞大的蓄量基础而实现快速的增长，可见蓄量水平能影响增量的增长空间。另外，在预算充足的前提下，还可以在朋友圈投放精准的微信社交广告，直接引流到直播间，这也是非常有效的方法。3.转化环节在转化环节中，除了秒杀、优惠券和买增的方式，我认为有几个要素可以提升转化，使直播带货的效益最大化。(1)加强对导购的激励，实行分销导购员对于商品和消费者心理都非常了解，因此导购完全有能力去转化直播间和朋友圈以及社群这些私域的流量，只需要制定好佣金策略，导购就会有更强的意愿去卖货。一般建议佣金比例可以按完成的销售额分为几个等级，业绩越好，等级越高，佣金比例越高，导购的动力更大，从而形成正向的循环。与此同时，业绩突出的导购可以作为全员学习的榜样和标杆，让其他人学习到有用的卖货技巧，这样能给到导购精神层面的激励，还可以带动整个团队氛围做好业务。(2)加强直播间互动，提升留存互动的方式有很多种，例如直播间不定时抽奖，能减少用户流失离开直播间；又或者直播间点赞量超过多少，送出福利回馈给直播间的用户等。总之，不能让直播间冷场，要营造出很热闹的氛围，增进用户留存，激发用户消费的冲动情绪。(3)提供直播回放，持续转化在直播结束后，可以把直播回放链接发到社群里，借助直播的余温让用户感知最后的优惠抢购机会，这样也有助于促使用户转化，带来销量持续增长。六、结束语艾瑞咨询权威的调查数据表明，直播可预见是一个万亿规模的市场，这意味着是各家品牌和企业空前难得的大好机遇，绝不能视而不见的红利。作为高度依赖社交传播的场景，直播必然能够与微信生态形成高效的商业适配，因此基于私域流量的小程序直播具备了先天优势，这是其他直播平台无法比拟的，因此小程序直播将会引领各家企业走进直播2.0时代。历史总是相似的，回望中国移动互联网的发展史，业态日趋成熟的背后总是离不开生态布局者与其战略伙伴的携手合作，当前微信生态与微盟这类第三方解决方案服务商共同赋能企业加快数字化转型，私域流量和小程序直播正是当打之处。黑天鹅冲击之下，数字化浪潮已掀起，没有谁愿意掉队，这是一个人人都需要深耕私域流量，完成小程序直播良性互动闭环的商业时代。-END-"}
